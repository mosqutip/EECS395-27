# 1 "src/smtp_in.c"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* This header is separate from features.h so that the compiler can
   include it implicitly at the start of every compilation.  It must
   not itself include <features.h> or any other header that includes
   <features.h> because the implicit include comes before any feature
   test macros that may be defined in a source file before it first
   explicitly includes a system header.  GCC knows the name of this
   header in order to preinclude it.  */

/* We do support the IEC 559 math functionality, real and complex.  */



/* wchar_t uses ISO/IEC 10646 (2nd ed., published 2011-03-15) /
   Unicode 6.0.  */


/* We do not support C11 <threads.h>.  */
# 1 "<command-line>" 2
# 1 "src/smtp_in.c"
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2012 */
/* See the file NOTICE for conditions of use and distribution. */

/* Functions for handling an incoming SMTP call. */


# 1 "src/exim.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2012 */
/* See the file NOTICE for conditions of use and distribution. */


/* Source files for exim all #include this header, which drags in everything
that is needed. They don't all need everything, of course, but it's far too
messy to have each one importing its own list, and anyway, most of them need
most of these includes. */

/* Assume most systems have statfs() unless os.h undefines this macro */



/* Similarly, assume most systems have srandom() unless os.h undefines it.
This call dates back at least as far as SUSv2. */



/* This is primarily for the Gnu C library; we define it before os.h so that
os.h has a chance to hurriedly undef it, Just In Case.  We need C99 for some
64-bit math support, and defining _ISOC99_SOURCE breaks <resolv.h> and friends.
*/



/* First of all include the os-specific header, which might set things that
are needed by any of the other headers, including system headers. */

# 1 "build-Linux-x86_64/os.h" 1
/* Exim: OS-specific C header file for Linux */

/* Some old systems we've received bug-reports for have a <limits.h> which
does not pull in <features.h>.  Best to just pull it in now and have done
with the issue. */

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* These are defined by the user (or the compiler)
   to specify the desired environment:

   __STRICT_ANSI__	ISO Standard C.
   _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
   _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
   _POSIX_SOURCE	IEEE Std 1003.1.
   _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
			if >=199309L, add IEEE Std 1003.1b-1993;
			if >=199506L, add IEEE Std 1003.1c-1995;
			if >=200112L, all of IEEE 1003.1-2004
			if >=200809L, all of IEEE 1003.1-2008
   _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
			Single Unix conformance is wanted, to 600 for the
			sixth revision, to 700 for the seventh revision.
   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
   _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
   _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
   _FILE_OFFSET_BITS=N	Select default filesystem interface.
   _BSD_SOURCE		ISO C, POSIX, and 4.3BSD things.
   _SVID_SOURCE		ISO C, POSIX, and SVID things.
   _ATFILE_SOURCE	Additional *at interfaces.
   _GNU_SOURCE		All of the above, plus GNU extensions.
   _REENTRANT		Select additionally reentrant object.
   _THREAD_SAFE		Same as _REENTRANT, often used by other systems.
   _FORTIFY_SOURCE	If set to numeric value > 0 additional security
			measures are defined, according to level.

   The `-ansi' switch to the GNU C compiler defines __STRICT_ANSI__.
   If none of these are defined, the default is to have _SVID_SOURCE,
   _BSD_SOURCE, and _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
   200112L.  If more than one of these are defined, they accumulate.
   For example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE
   together give you ISO C, 1003.1, and 1003.2, but nothing else.

   These are defined by this file and are used by the
   header files to decide what to declare or define:

   __USE_ISOC11		Define ISO C11 things.
   __USE_ISOC99		Define ISO C99 things.
   __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
   __USE_POSIX		Define IEEE Std 1003.1 things.
   __USE_POSIX2		Define IEEE Std 1003.2 things.
   __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
   __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
   __USE_XOPEN		Define XPG things.
   __USE_XOPEN_EXTENDED	Define X/Open Unix things.
   __USE_UNIX98		Define Single Unix V2 things.
   __USE_XOPEN2K        Define XPG6 things.
   __USE_XOPEN2KXSI     Define XPG6 XSI things.
   __USE_XOPEN2K8       Define XPG7 things.
   __USE_XOPEN2K8XSI    Define XPG7 XSI things.
   __USE_LARGEFILE	Define correct standard I/O things.
   __USE_LARGEFILE64	Define LFS things with separate names.
   __USE_FILE_OFFSET64	Define 64bit interface as default.
   __USE_BSD		Define 4.3BSD things.
   __USE_SVID		Define SVID things.
   __USE_MISC		Define things common to BSD and System V Unix.
   __USE_ATFILE		Define *at interfaces and AT_* constants for them.
   __USE_GNU		Define GNU extensions.
   __USE_REENTRANT	Define reentrant/thread-safe *_r functions.
   __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
   __FAVOR_BSD		Favor 4.3BSD things in cases of conflict.

   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
   only for compatibility.  All new code should use the other symbols
   to test for features.

   All macros listed above as possibly being defined by this file are
   explicitly undefined if they are not explicitly defined.
   Feature-test macros that are not defined by the user or compiler
   but are implied by the other feature-test macros defined (or by the
   lack of any definitions) are defined by the file.  */


/* Undefine everything, so we get a clean slate.  */
# 126 "/usr/include/features.h" 3 4
/* Suppress kernel-name space pollution unless user expressedly asks
   for it.  */




/* Always use ISO C things.  */


/* Convenience macros to test the versions of glibc and gcc.
   Use them like this:
   #if __GNUC_PREREQ (2,8)
   ... code requiring gcc 2.8 or later ...
   #endif
   Note - they won't work for gcc1 or glibc1, since the _MINOR macros
   were not defined then.  */
# 150 "/usr/include/features.h" 3 4
/* If _BSD_SOURCE was defined by the user, favor BSD over POSIX.  */






/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */
# 183 "/usr/include/features.h" 3 4
/* If nothing (other than _GNU_SOURCE) is defined,
   define _BSD_SOURCE and _SVID_SOURCE.  */







/* This is to enable the ISO C11 extension.  */





/* This is to enable the ISO C99 extension.  */





/* This is to enable the ISO C90 Amendment 1:1995 extension.  */





/* This is to enable compatibility for ISO C++11.

   So far g++ does not provide a macro.  Check the temporary macro for
   now, too.  */





/* If none of the ANSI/POSIX macros are defined, use POSIX.1 and POSIX.2
   (and IEEE Std 1003.1b-1993 unless _XOPEN_SOURCE is defined).  */
# 343 "/usr/include/features.h" 3 4
/* Get definitions of __STDC_* predefined macros, if the compiler has
   not preincluded this header automatically.  */
# 1 "/usr/include/stdc-predef.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 346 "/usr/include/features.h" 2 3 4

/* This macro indicates that the installed library is the GNU C Library.
   For historic reasons the value now is 6 and this will stay from now
   on.  The use of this variable is deprecated.  Use __GLIBC__ and
   __GLIBC_MINOR__ now (see below) when you want to test for a specific
   GNU C library version and use the values in <gnu/lib-names.h> to get
   the sonames of the shared libraries.  */



/* Major and minor version number of the GNU C library package.  Use
   these macros to test for features in specific releases.  */






/* Decide whether a compiler supports the long long datatypes.  */







/* This is here only because every header file already includes this one.  */


# 1 "/usr/include/sys/cdefs.h" 1 3 4
/* Copyright (C) 1992-2002, 2004, 2005, 2006, 2007, 2009, 2011, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* We are almost always included from features.h. */




/* The GNU libc does not support any K&R compilers or the traditional mode
   of ISO C compilers anymore.  Check for some of the combinations not
   anymore supported.  */




/* Some user header file might have defined this before.  */





/* All functions, except those with callbacks or those that
   synchronize memory, are leaf functions.  */
# 50 "/usr/include/sys/cdefs.h" 3 4
/* GCC can always grok prototypes.  For C++ programs we add throw()
   to help it optimize the function calls.  But this works only with
   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
   as non-throwing using a function attribute since programs can use
   the -fexceptions options for C code as well.  */
# 81 "/usr/include/sys/cdefs.h" 3 4
/* These two macros are not used in glibc anymore.  They are kept here
   only because some other projects expect the macros to be defined.  */



/* For these things, GCC behaves the ANSI way normally,
   and the non-ANSI way under -traditional.  */




/* This is not a typedef so `const __ptr_t' does the right thing.  */




/* C++ needs to know that types and declarations are C, not C++.  */
# 107 "/usr/include/sys/cdefs.h" 3 4
/* The standard library needs the functions from the ISO C90 standard
   in the std namespace.  At the same time we want to be safe for
   future changes and we include the ISO C99 code in the non-standard
   namespace __c99.  The C++ wrapper header take case of adding the
   definitions to the global namespace.  */
# 120 "/usr/include/sys/cdefs.h" 3 4
/* For compatibility we do not add the declarations into any
   namespace.  They will end up in the global namespace which is what
   old code expects.  */
# 132 "/usr/include/sys/cdefs.h" 3 4
/* Support for bounded pointers.  */







/* Fortify support.  */
# 157 "/usr/include/sys/cdefs.h" 3 4
/* Support for flexible arrays.  */

/* GCC 2.97 supports C99 flexible array members.  */
# 175 "/usr/include/sys/cdefs.h" 3 4
/* __asm__ ("xyz") is used throughout the headers to rename functions
   at the assembly language level.  This is wrapped by the __REDIRECT
   macro, in order to support compilers that can do this some other
   way.  When compilers don't support asm-names at all, we have to do
   preprocessor tricks instead (which don't have exactly the right
   semantics, but it's the best we can do).

   Example:
   int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); */
# 202 "/usr/include/sys/cdefs.h" 3 4
/*
#elif __SOME_OTHER_COMPILER__

# define __REDIRECT(name, proto, alias) name proto; 	_Pragma("let " #name " = " #alias)
)
*/


/* GCC has various useful declarations that can be made with the
   `__attribute__' syntax.  All of the ways we use this do fine if
   they are omitted for compilers that don't understand it. */




/* At some point during the gcc 2.96 development the `malloc' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */






/* At some point during the gcc 2.96 development the `pure' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */






/* This declaration tells the compiler that the value is constant.  */






/* At some point during the gcc 3.1 development the `used' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */
# 253 "/usr/include/sys/cdefs.h" 3 4
/* gcc allows marking deprecated functions.  */






/* At some point during the gcc 2.8 development the `format_arg' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.
   If several `format_arg' attributes are given for the same function, in
   gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
   all designated arguments are considered.  */






/* At some point during the gcc 2.97 development the `strfmon' format
   attribute for functions was introduced.  We don't want to use it
   unconditionally (although this would be possible) since it
   generates warnings.  */







/* The nonull function attribute allows to mark pointer parameters which
   must not be NULL.  */






/* If fortification mode, we warn about unused results of certain
   function calls which can lead to problems.  */
# 306 "/usr/include/sys/cdefs.h" 3 4
/* Forces a function to be always inlined.  */






/* Associate error messages with the source location of the call site rather
   than with the source location inside the function.  */






/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
   inline semantics, unless -fgnu89-inline is used.  */
# 341 "/usr/include/sys/cdefs.h" 3 4
/* GCC 4.3 and above allow passing all anonymous arguments of an
   __extern_always_inline function to some other vararg function.  */





/* It is possible to compile containing GCC extensions even if GCC is
   run in pedantic mode if the uses are carefully marked using the
   `__extension__' keyword.  But this is not generally available before
   version 2.8.  */




/* __restrict is known in EGCS 1.2 and above. */




/* ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
     array_name[restrict]
   GCC 3.1 supports this.  */
# 385 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 386 "/usr/include/sys/cdefs.h" 2 3 4
# 376 "/usr/include/features.h" 2 3 4


/* If we don't have __REDIRECT, prototypes will be missing if
   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. */







/* Decide whether we can define 'extern inline' functions in headers.  */







/* This is here only because every header file already includes this one.
   Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
   <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
   that will always return failure (and set errno to ENOSYS).  */
# 1 "/usr/include/gnu/stubs.h" 1 3 4
/* This file is automatically generated.
   This file selects the right generated file of `__stub_FUNCTION' macros
   based on the architecture being compiled for.  */






# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
/* This file is automatically generated.
   It defines a symbol `__stub_FUNCTION' for each function
   in the C library which is a stub, meaning it will fail
   every time called, usually setting errno to ENOSYS.  */
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 400 "/usr/include/features.h" 2 3 4
# 8 "build-Linux-x86_64/os.h" 2
# 18 "build-Linux-x86_64/os.h"
/* When using the DKIM, setting HAVE_LINUX_SENDFILE can increase
performance on outgoing mail a bit. Note: With older glibc versions
this setting will conflict with the _FILE_OFFSET_BITS=64 setting
defined as part of the Linux CFLAGS. */

/* #define HAVE_LINUX_SENDFILE */


typedef struct flock flock_t;
# 38 "build-Linux-x86_64/os.h"
/* Some versions of Linux need explicit sync-ing of directories as well as
files. This setting requests that. If the directory is on NFS, it may not
be possible to sync it - in that case, Exim now should ignore the error. But
if you have problems in that area, try undefining this. But be aware that you
may be in a situation where files are not being properly "committed to stable
storage" as quickly as Exim thinks they are. */



/* Other OS have "const" in here */




/* Need a prototype for the Linux-specific function. The structure hasn't
been defined yet, so we need to pre-declare it. */

struct ip_address_item;
extern struct ip_address_item *os_find_running_interfaces_linux(void);



/* End */

/* Fudge added because this Linux doesn't appear to have a definition
for ip_options in /usr/include/linux/ip.h. */
# 34 "src/exim.h" 2

/* If it didn't define os_find_running_interfaces, use the common function. */





/* If it didn't define the base for "base 62" numbers, we really do use 62.
This is the case for all real Unix and Unix-like OS. It's only Cygwin and
Darwin, with their case-insensitive file systems, that can't use base 62 for
making unique names. */





/* The maximum value of localhost_number depends on the base being used */







/* If not overridden by os.h, dynamic libraries have filenames ending .so */




/* ANSI C standard includes */

# 1 "/usr/include/ctype.h" 1 3 4
/* Copyright (C) 1991,92,93,95,96,97,98,99,2001,2002,2004,2007-2009,2011,2012
	Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard 7.4: Character handling	<ctype.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/ctype.h" 2 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/bits/types.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 28 "/usr/include/bits/types.h" 2 3 4

/* Convenience types.  */
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;

/* Fixed-size types, underlying types depend on word size and compiler.  */
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;





/* quad_t is also 64 bits.  */

typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 69 "/usr/include/bits/types.h" 3 4
/* The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
   macros for each of the OS types we define below.  The definitions
   of those macros must use the following macros for underlying types.
   We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
   variants of each of the following integer types on this machine.

	16		-- "natural" 16-bit type (always short)
	32		-- "natural" 32-bit type (always int)
	64		-- "natural" 64-bit type (long or long long)
	LONG32		-- 32-bit type, traditionally long
	QUAD		-- 64-bit type, always long long
	WORD		-- natural type of __WORDSIZE bits (int or long)
	LONGWORD	-- type of __WORDSIZE bits, traditionally long

   We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
   conventional uses of `long' or `long long' type modifiers match the
   types we define, even when a less-adorned type would be the same size.
   This matters for (somewhat) portably writing printf/scanf formats for
   these types, where using the appropriate l or ll format modifiers can
   make the typedefs and the formats match up across all GNU platforms.  If
   we used `long' when it's 64 bits where `long long' is expected, then the
   compiler would warn about the formats not matching the argument types,
   and the programmer changing them to shut up the compiler would break the
   program's portability.

   Here we assume what is presently the case in all the GCC configurations
   we support: long long is always 64 bits, long is always word/address size,
   and int is always 32 bits.  */
# 125 "/usr/include/bits/types.h" 3 4
/* No need to mark the typedef with __extension__.   */




# 1 "/usr/include/bits/typesizes.h" 1 3 4
/* bits/typesizes.h -- underlying types for *_t.  Linux/x86-64 version.
   Copyright (C) 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/bits/typesizes.h" 3 4
/* See <bits/types.h> for the meaning of these macros.  This file exists so
   that <bits/types.h> need not vary across different GNU platforms.  */

/* X32 kernel interface is 64-bit.  */
# 76 "/usr/include/bits/typesizes.h" 3 4
/* Tell the libc code that off_t and off64_t are actually the same type
   for all ABI purposes, even if possibly expressed as different base types
   for C type-checking purposes.  */


/* Same for ino_t and ino64_t.  */



/* Number of descriptors that can fit in an `fd_set'.  */
# 131 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t; /* Type of device numbers.  */
typedef unsigned int __uid_t; /* Type of user identifications.  */
typedef unsigned int __gid_t; /* Type of group identifications.  */
typedef unsigned long int __ino_t; /* Type of file serial numbers.  */
typedef unsigned long int __ino64_t; /* Type of file serial numbers (LFS).*/
typedef unsigned int __mode_t; /* Type of file attribute bitmasks.  */
typedef unsigned long int __nlink_t; /* Type of file link counts.  */
typedef long int __off_t; /* Type of file sizes and offsets.  */
typedef long int __off64_t; /* Type of file sizes and offsets (LFS).  */
typedef int __pid_t; /* Type of process identifications.  */
typedef struct { int __val[2]; } __fsid_t; /* Type of file system IDs.  */
typedef long int __clock_t; /* Type of CPU usage counts.  */
typedef unsigned long int __rlim_t; /* Type for resource measurement.  */
typedef unsigned long int __rlim64_t; /* Type for resource measurement (LFS).  */
typedef unsigned int __id_t; /* General type for IDs.  */
typedef long int __time_t; /* Seconds since the Epoch.  */
typedef unsigned int __useconds_t; /* Count of microseconds.  */
typedef long int __suseconds_t; /* Signed count of microseconds.  */

typedef int __daddr_t; /* The type of a disk address.  */
typedef int __key_t; /* Type of an IPC key.  */

/* Clock ID used in clock and timer functions.  */
typedef int __clockid_t;

/* Timer ID returned by `timer_create'.  */
typedef void * __timer_t;

/* Type to represent block size.  */
typedef long int __blksize_t;

/* Types from the Large File Support interface.  */

/* Type to count number of disk blocks.  */
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;

/* Type to count file system blocks.  */
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;

/* Type to count file system nodes.  */
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

/* Type of miscellaneous file system fields.  */
typedef long int __fsword_t;

typedef long int __ssize_t; /* Type of a byte count, or error.  */

/* Signed long type used in system calls.  */
typedef long int __syscall_slong_t;
/* Unsigned long type used in system calls.  */
typedef unsigned long int __syscall_ulong_t;

/* These few don't really vary by system, they always correspond
   to one of the other defined types.  */
typedef __off64_t __loff_t; /* Type of file sizes and offsets (LFS).  */
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;

/* Duplicates info from stdint.h but this is used in unistd.h.  */
typedef long int __intptr_t;

/* Duplicate info from sys/socket.h.  */
typedef unsigned int __socklen_t;
# 28 "/usr/include/ctype.h" 2 3 4




/* These are all the characteristics of characters.
   If there get to be more than 16 distinct characteristics,
   many things must be changed that use `unsigned short int's.

   The characteristics are stored always in network byte order (big
   endian).  We define the bit value interpretations here dependent on the
   machine's byte order.  */

# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/endian.h" 2 3 4

/* Definitions for byte order, according to significance of bytes,
   from low addresses to high addresses.  The value is what you get by
   putting '4' in the most significant byte, '3' in the second most
   significant byte, '2' in the second least significant byte, and '1'
   in the least significant byte, and then writing down one digit for
   each byte, starting with the byte at the lowest address at the left,
   and proceeding to the byte with the highest address at the right.  */





/* This file defines `__BYTE_ORDER' for the particular machine.  */
# 1 "/usr/include/bits/endian.h" 1 3 4
/* i386/x86_64 are little-endian.  */
# 37 "/usr/include/endian.h" 2 3 4

/* Some machines may need to use a different endianness for floating point
   values.  */
# 59 "/usr/include/endian.h" 3 4
/* Conversion interfaces.  */
# 1 "/usr/include/bits/byteswap.h" 1 3 4
/* Macros to swap the order of bytes in integer values.
   Copyright (C) 1997-2012   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/bits/byteswap.h" 2 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 28 "/usr/include/bits/byteswap.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 29 "/usr/include/bits/byteswap.h" 2 3 4

/* Swap bytes in 16 bit value.  */



/* Get __bswap_16.  */
# 1 "/usr/include/bits/byteswap-16.h" 1 3 4
/* Macros to swap the order of bytes in 16-bit integer values.
   Copyright (C) 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 36 "/usr/include/bits/byteswap.h" 2 3 4

/* Swap bytes in 32 bit value.  */






static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 96 "/usr/include/bits/byteswap.h" 3 4
/* Swap bytes in 64 bit value.  */
# 108 "/usr/include/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 41 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)), /* UPPERCASE.  */
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)), /* lowercase.  */
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)), /* Alphabetic.  */
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)), /* Numeric.  */
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)), /* Hexadecimal numeric.  */
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)), /* Whitespace.  */
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)), /* Printing.  */
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)), /* Graphical.  */
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)), /* Blank (usually SPC and TAB).  */
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)), /* Control character.  */
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)), /* Punctuation.  */
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8)) /* Alphanumeric.  */
};


/* These are defined in ctype-info.c.
   The declarations here must match those in localeinfo.h.

   In the thread-specific locale model (see `uselocale' in <locale.h>)
   we cannot use global variables for these as was done in the past.
   Instead, the following accessor functions return the address of
   each variable, which is local to the current thread if multithreaded.

   These point into arrays of 384, so they can be indexed by any `unsigned
   char' value [0,255]; by EOF (-1); or by any `signed char' value
   [-128,-1).  ISO C requires that the ctype functions work for `unsigned
   char' values and for EOF; we also support negative `signed char' values
   for broken old programs.  The case conversion arrays are of `int's
   rather than `unsigned char's because tolower (EOF) must be EOF, which
   doesn't fit into an `unsigned char'.  But today more important is that
   the arrays are also used for multi-byte character sets.  */
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 105 "/usr/include/ctype.h" 3 4


/* The following names are all functions:
     int isCHARACTERISTIC(int c);
   which return nonzero iff C has CHARACTERISTIC.
   For the meaning of the characteristic names, see the `enum' above.  */
extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));


/* Return the lowercase version of C.  */
extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));

/* Return the uppercase version of C.  */
extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));




/* ISO C99 introduced one new function.  */



extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));





/* Test C for a set of character classes according to MASK.  */
extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ , __leaf__));




/* Return nonzero iff C is in the ASCII set
   (i.e., is no more than 7 bits wide).  */
extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));

/* Return the part of C that is in the ASCII set
   (i.e., the low-order 7 bits of C).  */
extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));

/* These are the same as `toupper' and `tolower' except that they do not
   check the argument for being in the range of a `char'.  */
extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));


/* This code is needed for the optimized mapping functions.  */
# 245 "/usr/include/ctype.h" 3 4
/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */
# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997,2000,2002,2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  The file and
   this data structure is not standardized.  Don't rely on it.  It can
   go away without warning.  */
typedef struct __locale_struct
{
  /* Note: LC_ALL is not a valid index into this array.  */
  struct __locale_data *__locales[13]; /* 13 = __LC_LAST. */

  /* To increase the speed of this solution we add some special members.  */
  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;

  /* Note: LC_ALL is not a valid index into this array.  */
  const char *__names[13];
} *__locale_t;

/* POSIX 2008 makes locale_t official.  */
typedef __locale_t locale_t;
# 259 "/usr/include/ctype.h" 2 3 4

/* These definitions are similar to the ones above but all functions
   take as an argument a handle for the locale which shall be used.  */






/* The following names are all functions:
     int isCHARACTERISTIC(int c, locale_t *locale);
   which return nonzero iff C has CHARACTERISTIC.
   For the meaning of the characteristic names, see the `enum' above.  */
extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));


/* Return the lowercase version of C in locale L.  */
extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));

/* Return the uppercase version of C.  */
extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 348 "/usr/include/ctype.h" 3 4

# 66 "src/exim.h" 2
# 1 "/usr/include/locale.h" 1 3 4
/* Copyright (C) 1991,1992,1995-2002,2007,2009,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.11 Localization	<locale.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/locale.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 162 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
/* Definition of locale category symbol values.
   Copyright (C) 2001-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 31 "/usr/include/locale.h" 2 3 4



/* These are the possibilities for the first argument to setlocale.
   The code assumes that the lowest LC_* symbol has the value zero.  */
# 51 "/usr/include/locale.h" 3 4


/* Structure giving information about numeric and monetary notation.  */
struct lconv
{
  /* Numeric (non-monetary) information.  */

  char *decimal_point; /* Decimal point character.  */
  char *thousands_sep; /* Thousands separator.  */
  /* Each element is the number of digits in each group;
     elements with higher indices are farther left.
     An element with value CHAR_MAX means that no further grouping is done.
     An element with value 0 means that the previous element is used
     for all groups farther left.  */
  char *grouping;

  /* Monetary information.  */

  /* First three chars are a currency symbol from ISO 4217.
     Fourth char is the separator.  Fifth char is '\0'.  */
  char *int_curr_symbol;
  char *currency_symbol; /* Local currency symbol.  */
  char *mon_decimal_point; /* Decimal point character.  */
  char *mon_thousands_sep; /* Thousands separator.  */
  char *mon_grouping; /* Like `grouping' element (above).  */
  char *positive_sign; /* Sign for positive values.  */
  char *negative_sign; /* Sign for negative values.  */
  char int_frac_digits; /* Int'l fractional digits.  */
  char frac_digits; /* Local fractional digits.  */
  /* 1 if currency_symbol precedes a positive value, 0 if succeeds.  */
  char p_cs_precedes;
  /* 1 iff a space separates currency_symbol from a positive value.  */
  char p_sep_by_space;
  /* 1 if currency_symbol precedes a negative value, 0 if succeeds.  */
  char n_cs_precedes;
  /* 1 iff a space separates currency_symbol from a negative value.  */
  char n_sep_by_space;
  /* Positive and negative sign positions:
     0 Parentheses surround the quantity and currency_symbol.
     1 The sign string precedes the quantity and currency_symbol.
     2 The sign string follows the quantity and currency_symbol.
     3 The sign string immediately precedes the currency_symbol.
     4 The sign string immediately follows the currency_symbol.  */
  char p_sign_posn;
  char n_sign_posn;

  /* 1 if int_curr_symbol precedes a positive value, 0 if succeeds.  */
  char int_p_cs_precedes;
  /* 1 iff a space separates int_curr_symbol from a positive value.  */
  char int_p_sep_by_space;
  /* 1 if int_curr_symbol precedes a negative value, 0 if succeeds.  */
  char int_n_cs_precedes;
  /* 1 iff a space separates int_curr_symbol from a negative value.  */
  char int_n_sep_by_space;
  /* Positive and negative sign positions:
     0 Parentheses surround the quantity and int_curr_symbol.
     1 The sign string precedes the quantity and int_curr_symbol.
     2 The sign string follows the quantity and int_curr_symbol.
     3 The sign string immediately precedes the int_curr_symbol.
     4 The sign string immediately follows the int_curr_symbol.  */
  char int_p_sign_posn;
  char int_n_sign_posn;
# 121 "/usr/include/locale.h" 3 4
};


/* Set and/or return the current locale.  */
extern char *setlocale (int __category, const char *__locale) __attribute__ ((__nothrow__ , __leaf__));

/* Return the numeric/monetary information for the current locale.  */
extern struct lconv *localeconv (void) __attribute__ ((__nothrow__ , __leaf__));





/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Get locale datatype definition.  */
# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997,2000,2002,2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 147 "/usr/include/locale.h" 2 3 4

/* Return a reference to a data structure representing a set of locale
   datasets.  Unlike for the CATEGORY parameter for `setlocale' the
   CATEGORY_MASK parameter here uses a single bit for each category,
   made by OR'ing together LC_*_MASK bits above.  */
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) __attribute__ ((__nothrow__ , __leaf__));

/* These are the bits that can be set in the CATEGORY_MASK argument to
   `newlocale'.  In the GNU implementation, LC_FOO_MASK has the value
   of (1 << LC_FOO), but this is not a part of the interface that
   callers can assume will be true.  */
# 185 "/usr/include/locale.h" 3 4
/* Return a duplicate of the set of locale in DATASET.  All usage
   counters are increased if necessary.  */
extern __locale_t duplocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));

/* Free the data associated with a locale dataset previously returned
   by a call to `setlocale_r'.  */
extern void freelocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));

/* Switch the current thread's locale to DATASET.
   If DATASET is null, instead just return the current setting.
   The special value LC_GLOBAL_LOCALE is the initial setting
   for all threads and can also be installed any time, meaning
   the thread uses the global settings controlled by `setlocale'.  */
extern __locale_t uselocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));

/* This value can be passed to `uselocale' and may be returned by it.
   Passing this value to any other function has undefined behavior.  */





# 67 "src/exim.h" 2
# 1 "/usr/include/math.h" 1 3 4
/* Declarations for math functions.
   Copyright (C) 1991-1993, 1995-1999, 2001, 2002, 2004, 2006, 2009, 2011, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.12 Mathematics	<math.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 28 "/usr/include/math.h" 2 3 4



/* Get machine-dependent HUGE_VAL value (returned on overflow).
   On all IEEE754 machines, this is +Infinity.  */
# 1 "/usr/include/bits/huge_val.h" 1 3 4
/* `HUGE_VAL' constant for IEEE 754 machines (where it is infinity).
   Used by <stdlib.h> and <math.h> functions for overflow.
   Copyright (C) 1992, 1995, 1996, 1997, 1999, 2000, 2004
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */
# 34 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
/* `HUGE_VALF' constant for IEEE 754 machines (where it is infinity).
   Used by <stdlib.h> and <math.h> functions for overflow.
   Copyright (C) 1992, 1995, 1996, 1997, 1999, 2000, 2004
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */
# 36 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
/* `HUGE_VALL' constant for ix86 (where it is infinity).
   Used by <stdlib.h> and <math.h> functions for overflow.
   Copyright (C) 1992, 1995, 1996, 1997, 1999, 2000, 2004
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 37 "/usr/include/math.h" 2 3 4

/* Get machine-dependent INFINITY value.  */
# 1 "/usr/include/bits/inf.h" 1 3 4
/* `INFINITY' constant for IEEE 754 machines.
   Copyright (C) 2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* IEEE positive infinity.  */
# 40 "/usr/include/math.h" 2 3 4

/* Get machine-dependent NAN value (returned for some domain errors).  */
# 1 "/usr/include/bits/nan.h" 1 3 4
/* `NAN' constant for IEEE 754 machines.
   Copyright (C) 1992,1996,1997,1999,2004,2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* IEEE Not A Number.  */
# 43 "/usr/include/math.h" 2 3 4


/* Get general and ISO C99 specific information.  */
# 1 "/usr/include/bits/mathdef.h" 1 3 4
/* Copyright (C) 2001-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/bits/mathdef.h" 3 4
/* The x86-64 architecture computes values with the precission of the
   used type.  Similarly for -m32 -mfpmath=sse.  */
typedef float float_t; /* `float' expressions are evaluated as `float'.  */
typedef double double_t; /* `double' expressions are evaluated
				   as `double'.  */
# 41 "/usr/include/bits/mathdef.h" 3 4
/* The values returned by `ilogb' for 0 and NaN respectively.  */



/* The GCC 4.6 compiler will define __FP_FAST_FMA{,F,L} if the fma{,f,l}
   builtins are supported.  */
# 47 "/usr/include/math.h" 2 3 4

/* The file <bits/mathcalls.h> contains the prototypes for all the
   actual math functions.  These macros are used for those prototypes,
   so we can easily declare each function as both `name' and `__name',
   and can declare the float versions `namef' and `__namef'.  */
# 70 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
/* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2003, 2006, 2011, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  */






/* Trigonometric functions.  */


/* Arc cosine of X.  */
extern double acos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acos (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc sine of X.  */
extern double asin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asin (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of X.  */
extern double atan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of Y/X.  */
extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Cosine of X.  */
extern double cos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cos (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Sine of X.  */
extern double sin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sin (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Tangent of X.  */
extern double tan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tan (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
extern double cosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cosh (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic sine of X.  */
extern double sinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sinh (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic tangent of X.  */
extern double tanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tanh (double __x) __attribute__ ((__nothrow__ , __leaf__));



/* Cosine and sine of X.  */
extern void sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                           ;




/* Hyperbolic arc cosine of X.  */
extern double acosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acosh (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc sine of X.  */
extern double asinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asinh (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc tangent of X.  */
extern double atanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atanh (double __x) __attribute__ ((__nothrow__ , __leaf__));



/* Exponential and logarithmic functions.  */


/* Exponential function of X.  */
extern double exp (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Break VALUE into a normalized fraction and an integral power of 2.  */
extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));

/* X times (two to the EXP power).  */
extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));

/* Natural logarithm of X.  */
extern double log (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Base-ten logarithm of X.  */
extern double log10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log10 (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Break VALUE into integral and fractional parts.  */
extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__nonnull__ (2)));



/* A function missing in all standards: compute exponent to base ten.  */
extern double exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Another name occasionally used.  */
extern double pow10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow10 (double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return exp(X) - 1.  */
extern double expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return log(1 + X).  */
extern double log1p (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log1p (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return the base 2 signed integral exponent of X.  */
extern double logb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __logb (double __x) __attribute__ ((__nothrow__ , __leaf__));





/* Compute base-2 exponential of X.  */
extern double exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Compute base-2 logarithm of X.  */
extern double log2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log2 (double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Power functions.  */


/* Return X to the Y power.  */
extern double pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return the square root of X.  */
extern double sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return `sqrt(X*X + Y*Y)'.  */
extern double hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));





/* Return the cube root of X.  */
extern double cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Nearest integer, absolute value, and remainder functions.  */


/* Smallest integral value not less than X.  */
extern double ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Absolute value of X.  */
extern double fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Largest integer not greater than X.  */
extern double floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Floating-point modulo remainder of X/Y.  */
extern double fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int __isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int __finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return the remainder of X/Y.  */
extern double drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return the fractional part of X after dividing out `ilogb (X)'.  */
extern double significand (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __significand (double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return X with its signed changed to Y's.  */
extern double copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





/* Return representation of NaN for double type.  */
extern double nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




/* Return nonzero if VALUE is not a number.  */
extern int __isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Return nonzero if VALUE is not a number.  */
extern int isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Bessel functions.  */
extern double j0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double j1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double jn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __jn (int, double) __attribute__ ((__nothrow__ , __leaf__));
extern double y0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double y1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double yn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __yn (int, double) __attribute__ ((__nothrow__ , __leaf__));





/* Error and gamma functions.  */
extern double erf (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erf (double) __attribute__ ((__nothrow__ , __leaf__));
extern double erfc (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erfc (double) __attribute__ ((__nothrow__ , __leaf__));
extern double lgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma (double) __attribute__ ((__nothrow__ , __leaf__));





/* True gamma function.  */
extern double tgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __tgamma (double) __attribute__ ((__nothrow__ , __leaf__));




/* Obsolete alias for `lgamma'.  */
extern double gamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __gamma (double) __attribute__ ((__nothrow__ , __leaf__));



/* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  */
extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));





/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
extern double rint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __rint (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Return the remainder of integer divison X / Y with infinite precision.  */
extern double remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return X times (2 to the Nth power).  */
extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));


/* Return the binary exponent of X, which must be nonzero.  */
extern int ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__));



/* Return X times (2 to the Nth power).  */
extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  */
extern double nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern double round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
extern double trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));


/* Conversion functions.  */

/* Round X to nearest integral value according to current rounding
   direction.  */
extern long int lrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrint (double __x) __attribute__ ((__nothrow__ , __leaf__));
extern long long int llrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrint (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern long int lround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lround (double __x) __attribute__ ((__nothrow__ , __leaf__));
extern long long int llround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llround (double __x) __attribute__ ((__nothrow__ , __leaf__));


/* Return positive difference between X and Y.  */
extern double fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return maximum numeric value from X and Y.  */
extern double fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return minimum numeric value from X and Y.  */
extern double fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Classify given number.  */
extern int __fpclassify (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));

/* Test for negative number.  */
extern int __signbit (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


/* Multiply-add function computed as a ternary operation.  */
extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__));







/* Return X times (2 to the Nth power).  */
extern double scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__));
# 71 "/usr/include/math.h" 2 3 4
# 79 "/usr/include/math.h" 3 4
/* Include the file of declarations again, this time using `float'
   instead of `double' and appending f to each function name.  */
# 89 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
/* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2003, 2006, 2011, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  */






/* Trigonometric functions.  */


/* Arc cosine of X.  */
extern float acosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acosf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc sine of X.  */
extern float asinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of X.  */
extern float atanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of Y/X.  */
extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Cosine of X.  */
extern float cosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cosf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Sine of X.  */
extern float sinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Tangent of X.  */
extern float tanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanf (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
extern float coshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __coshf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic sine of X.  */
extern float sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic tangent of X.  */
extern float tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));



/* Cosine and sine of X.  */
extern void sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                           ;




/* Hyperbolic arc cosine of X.  */
extern float acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc sine of X.  */
extern float asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc tangent of X.  */
extern float atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));



/* Exponential and logarithmic functions.  */


/* Exponential function of X.  */
extern float expf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expf (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Break VALUE into a normalized fraction and an integral power of 2.  */
extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));

/* X times (two to the EXP power).  */
extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));

/* Natural logarithm of X.  */
extern float logf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logf (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Base-ten logarithm of X.  */
extern float log10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log10f (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Break VALUE into integral and fractional parts.  */
extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__nonnull__ (2)));



/* A function missing in all standards: compute exponent to base ten.  */
extern float exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Another name occasionally used.  */
extern float pow10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __pow10f (float __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return exp(X) - 1.  */
extern float expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return log(1 + X).  */
extern float log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return the base 2 signed integral exponent of X.  */
extern float logbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logbf (float __x) __attribute__ ((__nothrow__ , __leaf__));





/* Compute base-2 exponential of X.  */
extern float exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Compute base-2 logarithm of X.  */
extern float log2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log2f (float __x) __attribute__ ((__nothrow__ , __leaf__));




/* Power functions.  */


/* Return X to the Y power.  */
extern float powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return the square root of X.  */
extern float sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return `sqrt(X*X + Y*Y)'.  */
extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));





/* Return the cube root of X.  */
extern float cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));




/* Nearest integer, absolute value, and remainder functions.  */


/* Smallest integral value not less than X.  */
extern float ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Absolute value of X.  */
extern float fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Largest integer not greater than X.  */
extern float floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Floating-point modulo remainder of X/Y.  */
extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int __isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int __finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return the remainder of X/Y.  */
extern float dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return the fractional part of X after dividing out `ilogb (X)'.  */
extern float significandf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __significandf (float __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return X with its signed changed to Y's.  */
extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





/* Return representation of NaN for double type.  */
extern float nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




/* Return nonzero if VALUE is not a number.  */
extern int __isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Return nonzero if VALUE is not a number.  */
extern int isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Bessel functions.  */
extern float j0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float j1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float jnf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __jnf (int, float) __attribute__ ((__nothrow__ , __leaf__));
extern float y0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float y1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float ynf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __ynf (int, float) __attribute__ ((__nothrow__ , __leaf__));





/* Error and gamma functions.  */
extern float erff (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erff (float) __attribute__ ((__nothrow__ , __leaf__));
extern float erfcf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erfcf (float) __attribute__ ((__nothrow__ , __leaf__));
extern float lgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf (float) __attribute__ ((__nothrow__ , __leaf__));





/* True gamma function.  */
extern float tgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __tgammaf (float) __attribute__ ((__nothrow__ , __leaf__));




/* Obsolete alias for `lgamma'.  */
extern float gammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __gammaf (float) __attribute__ ((__nothrow__ , __leaf__));



/* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  */
extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));





/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
extern float rintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __rintf (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Return the remainder of integer divison X / Y with infinite precision.  */
extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return X times (2 to the Nth power).  */
extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__));


/* Return the binary exponent of X, which must be nonzero.  */
extern int ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__));



/* Return X times (2 to the Nth power).  */
extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  */
extern float nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern float roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
extern float truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));


/* Conversion functions.  */

/* Round X to nearest integral value according to current rounding
   direction.  */
extern long int lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));
extern long long int llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern long int lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));
extern long long int llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));


/* Return positive difference between X and Y.  */
extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return maximum numeric value from X and Y.  */
extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return minimum numeric value from X and Y.  */
extern float fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Classify given number.  */
extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));

/* Test for negative number.  */
extern int __signbitf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


/* Multiply-add function computed as a ternary operation.  */
extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__));







/* Return X times (2 to the Nth power).  */
extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__));
# 90 "/usr/include/math.h" 2 3 4
# 122 "/usr/include/math.h" 3 4
/* Include the file of declarations again, this time using `long double'
   instead of `double' and appending l to each function name.  */
# 133 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
/* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2003, 2006, 2011, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  */






/* Trigonometric functions.  */


/* Arc cosine of X.  */
extern long double acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc sine of X.  */
extern long double asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of X.  */
extern long double atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of Y/X.  */
extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Cosine of X.  */
extern long double cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Sine of X.  */
extern long double sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Tangent of X.  */
extern long double tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
extern long double coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic sine of X.  */
extern long double sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic tangent of X.  */
extern long double tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



/* Cosine and sine of X.  */
extern void sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                           ;




/* Hyperbolic arc cosine of X.  */
extern long double acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc sine of X.  */
extern long double asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc tangent of X.  */
extern long double atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



/* Exponential and logarithmic functions.  */


/* Exponential function of X.  */
extern long double expl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Break VALUE into a normalized fraction and an integral power of 2.  */
extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));

/* X times (two to the EXP power).  */
extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));

/* Natural logarithm of X.  */
extern long double logl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Base-ten logarithm of X.  */
extern long double log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Break VALUE into integral and fractional parts.  */
extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__nonnull__ (2)));



/* A function missing in all standards: compute exponent to base ten.  */
extern long double exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Another name occasionally used.  */
extern long double pow10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __pow10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return exp(X) - 1.  */
extern long double expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return log(1 + X).  */
extern long double log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return the base 2 signed integral exponent of X.  */
extern long double logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





/* Compute base-2 exponential of X.  */
extern long double exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Compute base-2 logarithm of X.  */
extern long double log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Power functions.  */


/* Return X to the Y power.  */
extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return the square root of X.  */
extern long double sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return `sqrt(X*X + Y*Y)'.  */
extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));





/* Return the cube root of X.  */
extern long double cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Nearest integer, absolute value, and remainder functions.  */


/* Smallest integral value not less than X.  */
extern long double ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Absolute value of X.  */
extern long double fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Largest integer not greater than X.  */
extern long double floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Floating-point modulo remainder of X/Y.  */
extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int __isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int __finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return the remainder of X/Y.  */
extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return the fractional part of X after dividing out `ilogb (X)'.  */
extern long double significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return X with its signed changed to Y's.  */
extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





/* Return representation of NaN for double type.  */
extern long double nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




/* Return nonzero if VALUE is not a number.  */
extern int __isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Return nonzero if VALUE is not a number.  */
extern int isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Bessel functions.  */
extern long double j0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double j1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__));





/* Error and gamma functions.  */
extern long double erfl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double erfcl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfcl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double lgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal (long double) __attribute__ ((__nothrow__ , __leaf__));





/* True gamma function.  */
extern long double tgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tgammal (long double) __attribute__ ((__nothrow__ , __leaf__));




/* Obsolete alias for `lgamma'.  */
extern long double gammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __gammal (long double) __attribute__ ((__nothrow__ , __leaf__));



/* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  */
extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));





/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
extern long double rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Return the remainder of integer divison X / Y with infinite precision.  */
extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return X times (2 to the Nth power).  */
extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));


/* Return the binary exponent of X, which must be nonzero.  */
extern int ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



/* Return X times (2 to the Nth power).  */
extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  */
extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern long double roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
extern long double truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));


/* Conversion functions.  */

/* Round X to nearest integral value according to current rounding
   direction.  */
extern long int lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern long int lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


/* Return positive difference between X and Y.  */
extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return maximum numeric value from X and Y.  */
extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return minimum numeric value from X and Y.  */
extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Classify given number.  */
extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));

/* Test for negative number.  */
extern int __signbitl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


/* Multiply-add function computed as a ternary operation.  */
extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__));







/* Return X times (2 to the Nth power).  */
extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__));
# 134 "/usr/include/math.h" 2 3 4
# 148 "/usr/include/math.h" 3 4
/* This variable is used by `gamma' and `lgamma'.  */
extern int signgam;



/* ISO C99 defines some generic macros which work on any data type.  */


/* Get the architecture specific values describing the floating-point
   evaluation.  The following symbols will get defined:

    float_t	floating-point type at least as wide as `float' used
		to evaluate `float' expressions
    double_t	floating-point type at least as wide as `double' used
		to evaluate `double' expressions

    FLT_EVAL_METHOD
		Defined to
		  0	if `float_t' is `float' and `double_t' is `double'
		  1	if `float_t' and `double_t' are `double'
		  2	if `float_t' and `double_t' are `long double'
		  else	`float_t' and `double_t' are unspecified

    INFINITY	representation of the infinity value of type `float'

    FP_FAST_FMA
    FP_FAST_FMAF
    FP_FAST_FMAL
		If defined it indicates that the `fma' function
		generally executes about as fast as a multiply and an add.
		This macro is defined only iff the `fma' function is
		implemented directly with a hardware multiply-add instructions.

    FP_ILOGB0	Expands to a value returned by `ilogb (0.0)'.
    FP_ILOGBNAN	Expands to a value returned by `ilogb (NAN)'.

    DECIMAL_DIG	Number of decimal digits supported by conversion between
		decimal and all internal floating-point formats.

*/

/* All floating-point numbers can be put in one of these categories.  */
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };

/* Return number of classification appropriate for X.  */
# 221 "/usr/include/math.h" 3 4
/* Return nonzero value if sign of X is negative.  */
# 233 "/usr/include/math.h" 3 4
/* Return nonzero value if X is not +-Inf or NaN.  */
# 245 "/usr/include/math.h" 3 4
/* Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.  */


/* Return nonzero value if X is a NaN.  We could use `fpclassify' but
   we already have this functions `__isnan' and it is faster.  */
# 261 "/usr/include/math.h" 3 4
/* Return nonzero value if X is positive or negative infinity.  */
# 273 "/usr/include/math.h" 3 4
/* Bitmasks for the math_errhandling macro.  */



/* By default all functions support both errno and exception handling.
   In gcc's fast math mode and if inline functions are defined this
   might not be true.  */







/* Support for various different standard error handling behaviors.  */
typedef enum
{
  _IEEE_ = -1, /* According to IEEE 754/IEEE 854.  */
  _SVID_, /* According to System V, release 4.  */
  _XOPEN_, /* Nowadays also Unix98.  */
  _POSIX_,
  _ISOC_ /* Actually this is ISO C99.  */
} _LIB_VERSION_TYPE;

/* This variable can be changed at run-time to any of the values above to
   affect floating point error handling behavior (it may also be necessary
   to change the hardware FPU exception settings).  */
extern _LIB_VERSION_TYPE _LIB_VERSION;




/* In SVID error handling, `matherr' is called with this description
   of the exceptional condition.

   We have a problem when using C++ since `exception' is a reserved
   name in C++.  */



struct exception

  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };




extern int matherr (struct exception *__exc);




/* Types of exceptions in the `type' field.  */







/* SVID mode specifies returning this large value instead of infinity.  */
# 352 "/usr/include/math.h" 3 4
/* Some useful constants.  */
# 369 "/usr/include/math.h" 3 4
/* The above constants are not adequate for computation using `long double's.
   Therefore we provide as an extension constants with similar names as a
   GNU extension.  Provide enough digits for the 128-bit IEEE quad.  */
# 389 "/usr/include/math.h" 3 4
/* When compiling in strict ISO C compatible mode we must not use the
   inline functions since they, among other things, do not set the
   `errno' variable correctly.  */





/* ISO C99 defines some macros to compare number while taking care for
   unordered numbers.  Many FPUs provide special instructions to support
   these operations.  Generic support in GCC for these as builtins went
   in before 3.0.0, but not all cpus added their patterns.  We define
   versions that use the builtins here, and <bits/mathinline.h> will
   undef/redefine as appropriate for the specific GCC version in use.  */
# 411 "/usr/include/math.h" 3 4
/* Get machine-dependent inline versions (if there are any).  */




/* Define special entry points to use when the compiler got told to
   only expect finite results.  */





/* If we've still got undefined comparison macros, provide defaults.  */

/* Return nonzero value if X is greater than Y.  */







/* Return nonzero value if X is greater than or equal to Y.  */







/* Return nonzero value if X is less than Y.  */







/* Return nonzero value if X is less than or equal to Y.  */







/* Return nonzero value if either X is less than Y or Y is less than X.  */







/* Return nonzero value if arguments are unordered.  */
# 475 "/usr/include/math.h" 3 4

# 68 "src/exim.h" 2
# 1 "/usr/include/signal.h" 1 3 4
/* Copyright (C) 1991-2004,2007,2009,2010,2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.14 Signal handling <signal.h>
 */







# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 29 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/bits/sigset.h" 1 3 4
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991, 1992, 1994, 1996, 1997, 2007, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




typedef int __sig_atomic_t;

/* A `sigset_t' has a bit for each signal.  */


typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;




/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */
# 49 "/usr/include/bits/sigset.h" 3 4
/* Return a mask that includes the bit for SIG only.  */



/* Return the word index for SIG.  */
# 69 "/usr/include/bits/sigset.h" 3 4
/* The POSIX does not specify for handling the whole signal set in one
   command.  This is often wanted and so we define three more functions
   here.  */
# 100 "/usr/include/bits/sigset.h" 3 4
/* These functions needn't check for a bogus signal number -- error
   checking is done in the non __ versions.  */

extern int __sigismember (const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 33 "/usr/include/signal.h" 2 3 4

/* An integral type that can be modified atomically, without the
   possibility of a signal arriving in the middle of the operation.  */




typedef __sig_atomic_t sig_atomic_t;








typedef __sigset_t sigset_t;






# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 57 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/bits/signum.h" 1 3 4
/* Signal number definitions.  Linux version.
   Copyright (C) 1995,1996,1997,1998,1999,2003 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */



/* Fake signal functions.  */
# 31 "/usr/include/bits/signum.h" 3 4
/* Signals.  */
# 74 "/usr/include/bits/signum.h" 3 4
/* These are the hard limits of the kernel.  These values should not be
   used directly at user level.  */
# 58 "/usr/include/signal.h" 2 3 4



typedef __pid_t pid_t;





typedef __uid_t uid_t;





/* We need `struct timespec' later on.  */

# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 116 "/usr/include/time.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 117 "/usr/include/time.h" 2 3 4

/* POSIX.1b structure for a time value.  This is like a `struct timeval' but
   has nanoseconds instead of microseconds.  */
struct timespec
  {
    __time_t tv_sec; /* Seconds.  */
    __syscall_slong_t tv_nsec; /* Nanoseconds.  */
  };
# 76 "/usr/include/signal.h" 2 3 4



/* Get the `siginfo_t' type plus the needed symbols.  */
# 1 "/usr/include/bits/siginfo.h" 1 3 4
/* siginfo_t, sigevent and constants.  Linux x86-64 version.
   Copyright (C) 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 25 "/usr/include/bits/siginfo.h" 2 3 4






/* Type for data associated with a signal.  */
typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 58 "/usr/include/bits/siginfo.h" 3 4
typedef __clock_t __sigchld_clock_t;



typedef struct
  {
    int si_signo; /* Signal number.  */
    int si_errno; /* If non-zero, an errno value associated with
				   this signal, as defined in <errno.h>.  */
    int si_code; /* Signal code.  */

    union
      {
 int _pad[((128 / sizeof (int)) - 4)];

  /* kill().  */
 struct
   {
     __pid_t si_pid; /* Sending process ID.  */
     __uid_t si_uid; /* Real user ID of sending process.  */
   } _kill;

 /* POSIX.1b timers.  */
 struct
   {
     int si_tid; /* Timer ID.  */
     int si_overrun; /* Overrun count.  */
     sigval_t si_sigval; /* Signal value.  */
   } _timer;

 /* POSIX.1b signals.  */
 struct
   {
     __pid_t si_pid; /* Sending process ID.  */
     __uid_t si_uid; /* Real user ID of sending process.  */
     sigval_t si_sigval; /* Signal value.  */
   } _rt;

 /* SIGCHLD.  */
 struct
   {
     __pid_t si_pid; /* Which child.  */
     __uid_t si_uid; /* Real user ID of sending process.  */
     int si_status; /* Exit value or signal.  */
     __sigchld_clock_t si_utime;
     __sigchld_clock_t si_stime;
   } _sigchld;

 /* SIGILL, SIGFPE, SIGSEGV, SIGBUS.  */
 struct
   {
     void *si_addr; /* Faulting insn/memory ref.  */
   } _sigfault;

 /* SIGPOLL.  */
 struct
   {
     long int si_band; /* Band event for SIGPOLL.  */
     int si_fd;
   } _sigpoll;

 /* SIGSYS.  */
 struct
   {
     void *_call_addr; /* Calling user insn.  */
     int _syscall; /* Triggering system call number.  */
     unsigned int _arch; /* AUDIT_ARCH_* of syscall.  */
   } _sigsys;
      } _sifields;
  } siginfo_t ;


/* X/Open requires some more fields with fixed names.  */
# 149 "/usr/include/bits/siginfo.h" 3 4
/* Values for `si_code'.  Positive values are reserved for kernel-generated
   signals.  */
enum
{
  SI_ASYNCNL = -60, /* Sent by asynch name lookup completion.  */

  SI_TKILL = -6, /* Sent by tkill.  */

  SI_SIGIO, /* Sent by queued SIGIO. */

  SI_ASYNCIO, /* Sent by AIO completion.  */

  SI_MESGQ, /* Sent by real time mesq state change.  */

  SI_TIMER, /* Sent by timer expiration.  */

  SI_QUEUE, /* Sent by sigqueue.  */

  SI_USER, /* Sent by kill, sigsend.  */

  SI_KERNEL = 0x80 /* Send by kernel.  */

};


/* `si_code' values for SIGILL signal.  */
enum
{
  ILL_ILLOPC = 1, /* Illegal opcode.  */

  ILL_ILLOPN, /* Illegal operand.  */

  ILL_ILLADR, /* Illegal addressing mode.  */

  ILL_ILLTRP, /* Illegal trap. */

  ILL_PRVOPC, /* Privileged opcode.  */

  ILL_PRVREG, /* Privileged register.  */

  ILL_COPROC, /* Coprocessor error.  */

  ILL_BADSTK /* Internal stack error.  */

};

/* `si_code' values for SIGFPE signal.  */
enum
{
  FPE_INTDIV = 1, /* Integer divide by zero.  */

  FPE_INTOVF, /* Integer overflow.  */

  FPE_FLTDIV, /* Floating point divide by zero.  */

  FPE_FLTOVF, /* Floating point overflow.  */

  FPE_FLTUND, /* Floating point underflow.  */

  FPE_FLTRES, /* Floating point inexact result.  */

  FPE_FLTINV, /* Floating point invalid operation.  */

  FPE_FLTSUB /* Subscript out of range.  */

};

/* `si_code' values for SIGSEGV signal.  */
enum
{
  SEGV_MAPERR = 1, /* Address not mapped to object.  */

  SEGV_ACCERR /* Invalid permissions for mapped object.  */

};

/* `si_code' values for SIGBUS signal.  */
enum
{
  BUS_ADRALN = 1, /* Invalid address alignment.  */

  BUS_ADRERR, /* Non-existant physical address.  */

  BUS_OBJERR /* Object specific hardware error.  */

};

/* `si_code' values for SIGTRAP signal.  */
enum
{
  TRAP_BRKPT = 1, /* Process breakpoint.  */

  TRAP_TRACE /* Process trace trap.  */

};

/* `si_code' values for SIGCHLD signal.  */
enum
{
  CLD_EXITED = 1, /* Child has exited.  */

  CLD_KILLED, /* Child was killed.  */

  CLD_DUMPED, /* Child terminated abnormally.  */

  CLD_TRAPPED, /* Traced child has trapped.  */

  CLD_STOPPED, /* Child has stopped.  */

  CLD_CONTINUED /* Stopped child has continued.  */

};

/* `si_code' values for SIGPOLL signal.  */
enum
{
  POLL_IN = 1, /* Data input available.  */

  POLL_OUT, /* Output buffers available.  */

  POLL_MSG, /* Input message available.   */

  POLL_ERR, /* I/O error.  */

  POLL_PRI, /* High priority input available.  */

  POLL_HUP /* Device disconnected.  */

};
# 287 "/usr/include/bits/siginfo.h" 3 4
/* Structure to transport application-defined values with signals.  */







/* Forward declaration.  */

typedef union pthread_attr_t pthread_attr_t;



typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];

 /* When SIGEV_SIGNAL and SIGEV_THREAD_ID set, LWP ID of the
	   thread to receive the signal.  */
 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t); /* Function to start.  */
     pthread_attr_t *_attribute; /* Thread attributes.  */
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;

/* POSIX names to access some of the members.  */



/* `sigev_notify' values.  */
enum
{
  SIGEV_SIGNAL = 0, /* Notify via signal.  */

  SIGEV_NONE, /* Other notification: meaningless.  */

  SIGEV_THREAD, /* Deliver via thread creation.  */


  SIGEV_THREAD_ID = 4 /* Send signal to specific thread.  */

};
# 81 "/usr/include/signal.h" 2 3 4



/* Type of a signal handler.  */
typedef void (*__sighandler_t) (int);

/* The X/Open definition of `signal' specifies the SVID semantic.  Use
   the additional function `sysv_signal' when X/Open compatibility is
   requested.  */
extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));


/* Set the handler for the signal SIG to HANDLER, returning the old
   handler, or SIG_ERR on error.
   By default `signal' has the BSD semantic.  */


extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 114 "/usr/include/signal.h" 3 4



/* The X/Open definition of `signal' conflicts with the BSD version.
   So they defined another function `bsd_signal'.  */
extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));


/* Send signal SIG to process number PID.  If PID is zero,
   send SIG to all processes in the current process's process group.
   If PID is < -1, send SIG to all processes in process group - PID.  */

extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ , __leaf__));



/* Send SIG to all processes in process group PGRP.
   If PGRP is zero, send SIG to all processes in
   the current process's process group.  */
extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ , __leaf__));



/* Raise signal SIG, i.e., send SIG to yourself.  */
extern int raise (int __sig) __attribute__ ((__nothrow__ , __leaf__));



/* SVID names for the same things.  */
extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));



/* Print a message describing the meaning of the given signal number.  */
extern void psignal (int __sig, const char *__s);



/* Print a message describing the meaning of the given signal information.  */
extern void psiginfo (const siginfo_t *__pinfo, const char *__s);




/* The `sigpause' function has two different interfaces.  The original
   BSD definition defines the argument as a mask of the signal, while
   the more modern interface in X/Open defines it as the signal
   number.  We go with the BSD version unless the user explicitly
   selects the X/Open version.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int __sigpause (int __sig_or_mask, int __is_sig);
# 178 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 188 "/usr/include/signal.h" 3 4
/* None of the following functions should be used anymore.  They are here
   only for compatibility.  A single word (`int') is not guaranteed to be
   enough to hold a complete signal mask and therefore these functions
   simply do not work in many situations.  Use `sigprocmask' instead.  */

/* Compute mask for signal SIG.  */


/* Block signals in MASK, returning the old mask.  */
extern int sigblock (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));

/* Set the mask of blocked signals to MASK, returning the old mask.  */
extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));

/* Return currently selected signal mask.  */
extern int siggetmask (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
# 212 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;


/* 4.4 BSD uses the name `sig_t' for this.  */

typedef __sighandler_t sig_t;




/* Clear all signals from SET.  */
extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Set all signals in SET.  */
extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Add SIGNO to SET.  */
extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Remove SIGNO from SET.  */
extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return 1 if SIGNO is in SET, 0 if not.  */
extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return non-empty value is SET is not empty.  */
extern int sigisemptyset (const sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Build new signal set by combining the two inputs set using logical AND.  */
extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));

/* Build new signal set by combining the two inputs set using logical OR.  */
extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));


/* Get the system-specific definitions of `struct sigaction'
   and the `SA_*' and `SIG_*'. constants.  */
# 1 "/usr/include/bits/sigaction.h" 1 3 4
/* The proper definitions for Linux's sigaction.
   Copyright (C) 1993-1999, 2000, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Structure describing the action to be taken when a signal arrives.  */
struct sigaction
  {
    /* Signal handler.  */

    union
      {
 /* Used if SA_SIGINFO is not set.  */
 __sighandler_t sa_handler;
 /* Used if SA_SIGINFO is set.  */
 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;






    /* Additional set of signals to be blocked.  */
    __sigset_t sa_mask;

    /* Special flags.  */
    int sa_flags;

    /* Restore handler.  */
    void (*sa_restorer) (void);
  };

/* Bits in `sa_flags'.  */
# 69 "/usr/include/bits/sigaction.h" 3 4
/* Some aliases for the SA_ constants.  */





/* Values for the HOW argument to `sigprocmask'.  */
# 254 "/usr/include/signal.h" 2 3 4

/* Get and/or change the set of blocked signals.  */
extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ , __leaf__));

/* Change the set of blocked signals to SET,
   wait until a signal arrives, and restore the set of blocked signals.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));

/* Get and/or set the action for signal SIG.  */
extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ , __leaf__));

/* Put in SET all signals that are blocked and waiting to be delivered.  */
extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Select any of pending signals from SET or wait for any to arrive.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));


/* Select any of pending signals from SET and place information in INFO.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));

/* Select any of pending signals from SET and place information in INFO.
   Wait the time specified by TIMEOUT if no signal is pending.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));

/* Send signal SIG to the process PID.  Associate data in VAL with the
   signal.  */
extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ , __leaf__));






/* Names of the signals.  This variable exists only for compatibility.
   Use `strsignal' instead (see <string.h>).  */
extern const char *const _sys_siglist[65];
extern const char *const sys_siglist[65];

/* Structure passed to `sigvec'.  */
struct sigvec
  {
    __sighandler_t sv_handler; /* Signal handler.  */
    int sv_mask; /* Mask of signals to be blocked.  */

    int sv_flags; /* Flags (see below).  */

  };

/* Bits in `sv_flags'.  */





/* If VEC is non-NULL, set the handler for SIG to the `sv_handler' member
   of VEC.  The signals in `sv_mask' will be blocked while the handler runs.
   If the SV_RESETHAND bit is set in `sv_flags', the handler for SIG will be
   reset to SIG_DFL before `sv_handler' is entered.  If OVEC is non-NULL,
   it is filled in with the old information for SIG.  */
extern int sigvec (int __sig, const struct sigvec *__vec,
     struct sigvec *__ovec) __attribute__ ((__nothrow__ , __leaf__));


/* Get machine-dependent `struct sigcontext' and signal subcodes.  */
# 1 "/usr/include/bits/sigcontext.h" 1 3 4
/* Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 29 "/usr/include/bits/sigcontext.h" 3 4
struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t padding[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short padding[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 121 "/usr/include/bits/sigcontext.h" 3 4
struct _fpstate
{
  /* FPU environment matching the 64-bit FXSAVE layout.  */
  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t padding[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t reserved1[2];
  __uint64_t reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
# 341 "/usr/include/signal.h" 2 3 4

/* Restore the state saved in SCP.  */
extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 162 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 212 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 351 "/usr/include/signal.h" 2 3 4

/* If INTERRUPT is nonzero, make signal SIG interrupt system calls
   (causing them to fail with EINTR); if INTERRUPT is zero, make system
   calls be restarted after signal SIG.  */
extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ , __leaf__));

# 1 "/usr/include/bits/sigstack.h" 1 3 4
/* sigstack, sigaltstack definitions.
   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Structure describing a signal stack (obsolete).  */
struct sigstack
  {
    void *ss_sp; /* Signal stack pointer.  */
    int ss_onstack; /* Nonzero if executing on this stack.  */
  };


/* Possible values for `ss_flags.'.  */
enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};

/* Minimum stack size for a signal handler.  */


/* System default stack size.  */



/* Alternate, preferred interface.  */
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 358 "/usr/include/signal.h" 2 3 4

/* This will define `ucontext_t' and `mcontext_t'.  */
# 1 "/usr/include/sys/ucontext.h" 1 3 4
/* Copyright (C) 2001-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/sys/ucontext.h" 2 3 4
# 1 "/usr/include/signal.h" 1 3 4
/* Copyright (C) 1991-2004,2007,2009,2010,2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.14 Signal handling <signal.h>
 */
# 23 "/usr/include/sys/ucontext.h" 2 3 4

/* We need the signal context definitions even if they are not used
   included in <signal.h>.  */
# 1 "/usr/include/bits/sigcontext.h" 1 3 4
/* Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/sys/ucontext.h" 2 3 4



/* Type for general register.  */
__extension__ typedef long long int greg_t;

/* Number of general registers.  */


/* Container for all general registers.  */
typedef greg_t gregset_t[23];


/* Number of each register in the `gregset_t' array.  */
enum
{
  REG_R8 = 0,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

  REG_RDI,

  REG_RSI,

  REG_RBP,

  REG_RBX,

  REG_RDX,

  REG_RAX,

  REG_RCX,

  REG_RSP,

  REG_RIP,

  REG_EFL,

  REG_CSGSFS, /* Actually short cs, gs, fs, __pad0.  */

  REG_ERR,

  REG_TRAPNO,

  REG_OLDMASK,

  REG_CR2

};


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int padding[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{
  /* 64-bit FXSAVE format.  */
  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t padding[24];
};

/* Structure to describe FPU registers.  */
typedef struct _libc_fpstate *fpregset_t;

/* Context to describe whole processor state.  */
typedef struct
  {
    gregset_t gregs;
    /* Note that fpregs is a pointer.  */
    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;

/* Userlevel context.  */
typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 361 "/usr/include/signal.h" 2 3 4


/* Run signals handlers on the stack specified by SS (if not NULL).
   If OSS is not NULL, it is filled in with the old signal stack status.
   This interface is obsolete and on many platform not implemented.  */
extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));

/* Alternate signal handler stack interface.
   This interface should always be preferred over `sigstack'.  */
extern int sigaltstack (const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) __attribute__ ((__nothrow__ , __leaf__));




/* Simplified interface for signal management.  */

/* Add SIG to the calling process' signal mask.  */
extern int sighold (int __sig) __attribute__ ((__nothrow__ , __leaf__));

/* Remove SIG from the calling process' signal mask.  */
extern int sigrelse (int __sig) __attribute__ ((__nothrow__ , __leaf__));

/* Set the disposition of SIG to SIG_IGN.  */
extern int sigignore (int __sig) __attribute__ ((__nothrow__ , __leaf__));

/* Set the disposition of SIG.  */
extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__ , __leaf__));



/* Some of the functions for handling signals in threaded programs must
   be defined here.  */
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
/* Copyright (C) 2002-2007, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 22 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 58 "/usr/include/bits/pthreadtypes.h" 3 4
/* Thread identifiers.  The structure of the attribute type is not
   exposed on purpose.  */
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};







typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 88 "/usr/include/bits/pthreadtypes.h" 3 4
/* Data structures for mutex handling.  The structure of the attribute
   type is not exposed on purpose.  */
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;

    /* KIND must stay at this position in the structure to maintain
       binary compatibility.  */
    int __kind;

    int __spins;
    __pthread_list_t __list;
# 115 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;


/* Data structure for conditional variable handling.  The structure of
   the attribute type is not exposed on purpose.  */
typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;


/* Keys for thread-specific data */
typedef unsigned int pthread_key_t;


/* Once-only execution */
typedef int pthread_once_t;



/* Data structure for read-write lock variable handling.  The
   structure of the attribute type is not exposed on purpose.  */
typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;
    /* FLAGS must stay at this position in the structure to maintain
       binary compatibility.  */
    unsigned int __flags;

  } __data;
# 202 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;




/* POSIX spinlock data type.  */
typedef volatile int pthread_spinlock_t;


/* POSIX barriers data type.  The structure of the type is
   deliberately not exposed.  */
typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 396 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/bits/sigthread.h" 1 3 4
/* Signal handling function for threaded programs.
   Copyright (C) 1998-2000, 2002, 2009, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If
   not, see <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/bits/sigthread.h" 3 4
/* Functions for handling signals. */

/* Modify the signal mask for the calling thread.  The arguments have
   the same meaning as for sigprocmask(2). */
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ , __leaf__));

/* Send signal SIGNO to the given thread. */
extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ , __leaf__));


/* Queue signal and data to a thread.  */
extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) __attribute__ ((__nothrow__ , __leaf__));
# 397 "/usr/include/signal.h" 2 3 4


/* The following functions are used internally in the C library and in
   other code which need deep insights.  */

/* Return number of available real-time signal with highest priority.  */
extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ , __leaf__));
/* Return number of available real-time signal with lowest priority.  */
extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ , __leaf__));




# 69 "src/exim.h" 2
# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdarg.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
# 36 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdarg.h" 3 4
/* Define __gnuc_va_list.  */



typedef __builtin_va_list __gnuc_va_list;


/* Define the standard macros for the user,
   if this invocation was from the user program.  */
# 55 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdarg.h" 3 4
/* Define va_list, if desired, from __gnuc_va_list. */
/* We deliberately do not define va_list when called from
   stdio.h, because ANSI C says that stdio.h is not supposed to define
   va_list.  stdio.h needs to have access to that data type, 
   but must not use that name.  It should use the name __gnuc_va_list,
   which is safe because it is reserved for the implementation.  */
# 85 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdarg.h" 3 4
/* The macro _VA_LIST_ is the same thing used by this file in Ultrix.
   But on BSD NET2 we must not test or define or undef it.
   (Note that the comments in NET 2's ansi.h
   are incorrect for _VA_LIST_--see stdio.h!)  */

/* The macro _VA_LIST_DEFINED is used in Windows NT 3.5  */

/* The macro _VA_LIST is used in SCO Unix 3.2.  */

/* The macro _VA_LIST_T_H is used in the Bull dpx2  */

/* The macro __va_list__ is used by BeOS.  */

typedef __gnuc_va_list va_list;
# 70 "src/exim.h" 2
# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */





/* snaroff@next.com says the NeXT needs this.  */




/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 147 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 279 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since 
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." */
# 306 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... */
# 324 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
typedef int wchar_t;
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 71 "src/exim.h" 2
# 1 "/usr/include/stdio.h" 1 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991, 1994-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */





# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 34 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 36 "/usr/include/stdio.h" 2 3 4







/* Define outside of namespace so the C++ is happy.  */
struct _IO_FILE;


/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE FILE;





# 63 "/usr/include/stdio.h" 3 4
/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
/* Copyright (C) 1991-1995,1997-2007,2009,2011,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Written by Per Bothner <bothner@cygnus.com>.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.

   As a special exception, if you link the code in this file with
   files compiled with a GNU compiler to produce an executable,
   that does not cause the resulting executable to be covered by
   the GNU Lesser General Public License.  This exception does not
   however invalidate any other reasons why the executable file
   might be covered by the GNU Lesser General Public License.
   This exception applies to code released by its copyright holders
   in files containing the exception.  */




# 1 "/usr/include/_G_config.h" 1 3 4
/* This file is needed by libio to define various configuration parameters.
   These are always the same in the GNU C library.  */




/* Define types for libio in terms of the standard internal type names.  */

# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 10 "/usr/include/_G_config.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
/* Copyright (C) 1995-2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */
# 81 "/usr/include/wchar.h" 3 4
/* Conversion state information.  */
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value; /* Value so far.  */
} __mbstate_t;




/* The rest of the file is only used if used if __need_mbstate_t is not
   defined.  */
# 897 "/usr/include/wchar.h" 3 4
/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 45 "/usr/include/_G_config.h" 3 4
/* These library features are always available in the GNU C library.  */







/* This is defined by <bits/stat.h> if `st_blksize' exists.  */
# 33 "/usr/include/libio.h" 2 3 4
/* ALL of these should be defined in _G_config.h */
# 48 "/usr/include/libio.h" 3 4
/* This define avoids name pollution if we're using GNU stdarg.h */

# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdarg.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
# 51 "/usr/include/libio.h" 2 3 4
# 87 "/usr/include/libio.h" 3 4
/* Magic numbers and bits for the _flags field.
   The magic numbers use the high-order bits of _flags;
   the remaining bits are available for variable flags.
   Note: The magic numbers must all be negative if stdio
   emulation is desired. */
# 125 "/usr/include/libio.h" 3 4
/* These are "formatting flags" matching the iostream fmtflags enum values. */
# 145 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;

/* Handle lock.  */







typedef void _IO_lock_t;



/* A streammarker remembers a position in a buffer. */

struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;
  /* If _pos >= 0
 it points to _buf->Gbase()+_pos. FIXME comment */
  /* if _pos < 0, it points to _buf->eBptr()+_pos. FIXME comment */
  int _pos;
# 178 "/usr/include/libio.h" 3 4
};

/* This is the structure from the libstdc++ codecvt class.  */
enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 246 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags; /* High-order word is _IO_MAGIC; rest is flags. */


  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr; /* Current read pointer */
  char* _IO_read_end; /* End of get area. */
  char* _IO_read_base; /* Start of putback+get area. */
  char* _IO_write_base; /* Start of put area. */
  char* _IO_write_ptr; /* Current put pointer. */
  char* _IO_write_end; /* End of put area. */
  char* _IO_buf_base; /* Start of reserve area. */
  char* _IO_buf_end; /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base; /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset; /* This used to be _offset but it's too small.  */


  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;
# 294 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 303 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;
  /* Make sure we don't get into trouble again.  */
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 335 "/usr/include/libio.h" 3 4
/* Functions to do I/O and file management for a stream.  */

/* Read NBYTES bytes from COOKIE into a buffer pointed to by BUF.
   Return number of bytes read.  */
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);

/* Write N bytes pointed to by BUF to COOKIE.  Write all N bytes
   unless there is an error.  Return number of bytes written.  If
   there is an error, return 0 and do not write anything.  If the file
   has been opened for append (__mode.__append set), then set the file
   pointer to the end of the file and then do the write; if not, just
   write at the current file pointer.  */
typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);

/* Move COOKIE's file position to *POS bytes from the
   beginning of the file (if W is SEEK_SET),
   the current position (if W is SEEK_CUR),
   or the end of the file (if W is SEEK_END).
   Set *POS to the new file position.
   Returns zero if successful, nonzero if not.  */
typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);

/* Close COOKIE.  */
typedef int __io_close_fn (void *__cookie);



/* User-visible names for the above.  */
typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;

/* The structure with the cookie function pointers.  */
typedef struct
{
  __io_read_fn *read; /* Read bytes.  */
  __io_write_fn *write; /* Write bytes.  */
  __io_seek_fn *seek; /* Seek/tell file position.  */
  __io_close_fn *close; /* Close file.  */
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;

/* Initialize one of those.  */
extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 435 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);

/* This one is for Emacs. */



extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 465 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "/usr/include/stdio.h" 2 3 4
# 90 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __ssize_t ssize_t;




/* The type of the second argument to `fgetpos' and `fsetpos'.  */


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;


/* The possibilities for the third argument to `setvbuf'.  */





/* Default buffer size.  */





/* End of file character.
   Some things throughout the library rely on this being -1.  */





/* The possibilities for the third argument to `fseek'.
   These values should not be changed.  */
# 150 "/usr/include/stdio.h" 3 4
/* Default path prefix for `tempnam' and `tmpnam'.  */




/* Get the values:
   L_tmpnam	How long an array of chars must be to be passed to `tmpnam'.
   TMP_MAX	The minimum number of unique filenames generated by tmpnam
		(and tempnam when it uses tmpnam's name space),
		or tempnam (the two are separate).
   L_ctermid	How long an array to pass to `ctermid'.
   L_cuserid	How long an array to pass to `cuserid'.
   FOPEN_MAX	Minimum number of files that can be open at once.
   FILENAME_MAX	Maximum length of a filename.  */
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
/* Copyright (C) 1994, 1997, 1998, 1999, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 165 "/usr/include/stdio.h" 2 3 4


/* Standard streams.  */
extern struct _IO_FILE *stdin; /* Standard input stream.  */
extern struct _IO_FILE *stdout; /* Standard output stream.  */
extern struct _IO_FILE *stderr; /* Standard error output stream.  */
/* C89/C99 say they're macros.  Make them happy.  */





/* Remove file FILENAME.  */
extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));
/* Rename file OLD to NEW.  */
extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



/* Rename file OLD relative to OLDFD to NEW relative to NEWFD.  */
extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));



/* Create a temporary file and open it read/write.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern FILE *tmpfile (void) ;
# 205 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;


/* Generate a temporary filename.  */
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;



/* This is the reentrant variant of `tmpnam'.  The only difference is
   that it does not allow S to be NULL.  */
extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;




/* Generate a unique temporary filename using up to five characters of PFX
   if it is not NULL.  The directory to put this file in is searched for
   as follows: First the environment variable "TMPDIR" is checked.
   If it contains the name of a writable directory, that directory is used.
   If not and if DIR is not NULL, that value is checked.  If that fails,
   P_tmpdir is tried and finally "/tmp".  The storage for the filename
   is allocated by `malloc'.  */
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




/* Close STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fclose (FILE *__stream);
/* Flush STREAM, or all streams if STREAM is NULL.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fflush (FILE *__stream);



/* Faster versions when locking is not required.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fflush_unlocked (FILE *__stream);



/* Close all streams.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fcloseall (void);





/* Open a file and create a new stream for it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;
/* Open a file, replacing an existing stream with it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;



/* Create a new stream that refers to an existing system file descriptor.  */
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Create a new stream that refers to the given magic cookie,
   and uses the given functions for input and output.  */
extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Create a new stream that refers to a memory buffer.  */
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;

/* Open a stream that writes into a malloc'd buffer that is expanded as
   necessary.  *BUFLOC and *SIZELOC are updated with the buffer's location
   and the number of characters written on fflush or fclose.  */
extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;




/* If BUF is NULL, make STREAM unbuffered.
   Else make it use buffer BUF, of size BUFSIZ.  */
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));
/* Make STREAM use buffering mode MODE.
   If BUF is not NULL, use N bytes of it for buffering;
   else allocate an internal buffer N bytes long.  */
extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));



/* If BUF is NULL, make STREAM unbuffered.
   Else make it use SIZE bytes of BUF for buffering.  */
extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));

/* Make STREAM line-buffered.  */
extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));




/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int printf (const char *__restrict __format, ...);
/* Write formatted output to S.  */
extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));

/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);
/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);
/* Write formatted output to S from argument list ARG.  */
extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));




/* Maximum chars of output to write in MAXLEN.  */
extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));




/* Write formatted output to a string dynamically allocated with `malloc'.
   Store the address of the string in *PTR.  */
extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;



/* Write formatted output to a file descriptor.  */
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));




/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;
/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int scanf (const char *__restrict __format, ...) ;
/* Read formatted input from S.  */
extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 463 "/usr/include/stdio.h" 3 4




/* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;

/* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;

/* Read formatted input from S into argument list ARG.  */
extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4





/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getchar (void);


/* The C standard explicitly says this is a macro, so we always do the
   optimization for it.  */



/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);



/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fgetc_unlocked (FILE *__stream);




/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.

   These functions is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);

/* Write a character to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int putchar (int __c);


/* The C standard explicitly says this can be a macro,
   so we always do the optimization for it.  */



/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputc_unlocked (int __c, FILE *__stream);



/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);





/* Get a word (int) from STREAM.  */
extern int getw (FILE *__stream);

/* Write a word (int) to STREAM.  */
extern int putw (int __w, FILE *__stream);




/* Get a newline-terminated string of finite length from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 640 "/usr/include/stdio.h" 3 4



/* This function does the same as `fgets' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;




/* Read up to (and including) a DELIMITER from STREAM into *LINEPTR
   (and null-terminate it). *LINEPTR is a pointer returned from malloc (or
   NULL), pointing to *N characters of space.  It is realloc'd as
   necessary.  Returns the number of characters read (not including the
   null terminator), or -1 on error or EOF.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;

/* Like `getdelim', but reads up to a newline.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;




/* Write a string to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);

/* Write a string, followed by a newline, to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int puts (const char *__s);


/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int ungetc (int __c, FILE *__stream);


/* Read chunks of generic data from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;
/* Write chunks of generic data to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);



/* This function does the same as `fputs' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);



/* Faster versions when locking is not necessary.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);




/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fseek (FILE *__stream, long int __off, int __whence);
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern long int ftell (FILE *__stream) ;
/* Rewind to the beginning of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void rewind (FILE *__stream);


/* The Single Unix Specification, Version 2, specifies an alternative,
   more adequate interface for the two functions above which deal with
   file offset.  `long int' is not the right type.  These definitions
   are originally defined in the Large File Support API.  */



/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fseeko (FILE *__stream, __off_t __off, int __whence);
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4


/* Get STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
/* Set STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



/* Clear the error and EOF indicators for STREAM.  */
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
/* Return the EOF indicator for STREAM.  */
extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
/* Return the error indicator for STREAM.  */
extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Faster versions when locking is not required.  */
extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




/* Print a message describing the meaning of the value of errno.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void perror (const char *__s);


/* Provide the declarations for `sys_errlist' and `sys_nerr' if they
   are available on this system.  Even if available, these variables
   should not be used directly.  The `strerror' function provides
   all the necessary functionality.  */
# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
/* Declare sys_errlist and sys_nerr, or don't.  Compatibility (do) version.
   Copyright (C) 2002, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* sys_errlist and sys_nerr are deprecated.  Use strerror instead.  */


extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4



/* Return the system file descriptor for STREAM.  */
extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Faster version when locking is not required.  */
extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;





/* Create a new stream connected to a pipe running the given command.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *popen (const char *__command, const char *__modes) ;

/* Close a stream opened by popen and return the status of its child.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int pclose (FILE *__stream);




/* Return the name of the controlling terminal.  */
extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));




/* Return the name of the current user.  */
extern char *cuserid (char *__s);




struct obstack; /* See <obstack.h>.  */

/* Write formatted output to an obstack.  */
extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));




/* These are defined in POSIX.1:1996.  */

/* Acquire ownership of STREAM.  */
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

/* Try to acquire ownership of STREAM but do not block if it is not
   possible.  */
extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

/* Relinquish the ownership granted for STREAM.  */
extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 931 "/usr/include/stdio.h" 3 4
/* If we are compiling with optimizing read this file.  It contains
   several optimizing inline functions and macros.  */
# 943 "/usr/include/stdio.h" 3 4

# 72 "src/exim.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
/* Copyright (C) 1991-2007, 2009-2011, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.20 General utilities	<stdlib.h>
 */



# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 25 "/usr/include/stdlib.h" 2 3 4

/* Get size_t, wchar_t and NULL from <stddef.h>.  */





# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 33 "/usr/include/stdlib.h" 2 3 4







/* XPG requires a few symbols from <sys/wait.h> being defined.  */
# 1 "/usr/include/bits/waitflags.h" 1 3 4
/* Definitions of flag bits for `waitpid' et al.
   Copyright (C) 1992,1996,1997,2000,2004,2005 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Bits in the third argument to `waitpid'.  */



/* Bits in the fourth argument to `waitid'.  */
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
/* Definitions of status bits for `wait' et al.
   Copyright (C) 1992,1994,1996,1997,2000,2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Everything extant so far uses these same bits.  */


/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */


/* If WIFSIGNALED(STATUS), the terminating signal.  */


/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */


/* Nonzero if STATUS indicates normal termination.  */


/* Nonzero if STATUS indicates termination by a signal.  */



/* Nonzero if STATUS indicates the child is stopped.  */


/* Nonzero if STATUS indicates the child continued after a stop.  We only
   define this if <bits/waitflags.h> provides the WCONTINUED flag bit.  */




/* Nonzero if STATUS indicates the child dumped core.  */


/* Macros for constructing status values.  */
# 64 "/usr/include/bits/waitstatus.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 65 "/usr/include/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7; /* Terminating signal.  */
 unsigned int __w_coredump:1; /* Set if dumped core.  */
 unsigned int __w_retcode:8; /* Return code if exited normally.  */
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8; /* W_STOPPED if stopped.  */
 unsigned int __w_stopsig:8; /* Stopping signal.  */
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4



/* Lots of hair to allow traditional BSD use of `union wait'
   as well as POSIX.1 use of `int' for the status word.  */
# 57 "/usr/include/stdlib.h" 3 4
/* This is the type of the argument to `wait'.  The funky union
   causes redeclarations with either `int *' or `union wait *' to be
   allowed without complaint.  __WAIT_STATUS_DEFN is the type used in
   the actual function definitions.  */





/* This works in GCC 2.6.1 and later.  */
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 83 "/usr/include/stdlib.h" 3 4
/* Define the macros <sys/wait.h> also would define this way.  */
# 95 "/usr/include/stdlib.h" 3 4

/* Returned by `div'.  */
typedef struct
  {
    int quot; /* Quotient.  */
    int rem; /* Remainder.  */
  } div_t;

/* Returned by `ldiv'.  */

typedef struct
  {
    long int quot; /* Quotient.  */
    long int rem; /* Remainder.  */
  } ldiv_t;






/* Returned by `lldiv'.  */
__extension__ typedef struct
  {
    long long int quot; /* Quotient.  */
    long long int rem; /* Remainder.  */
  } lldiv_t;





/* The largest number rand will return (same as INT_MAX).  */



/* We define these the same for all machines.
   Changes from this to the outside world should be done in `_exit'.  */




/* Maximum length of a multibyte character in the current locale.  */

extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Convert a string to a floating-point number.  */
extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
/* Convert a string to an integer.  */
extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
/* Convert a string to a long integer.  */
extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




/* Convert a string to a long long integer.  */
__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




/* Convert a string to a floating-point number.  */
extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Convert a string to a long integer.  */
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
/* Convert a string to an unsigned long integer.  */
extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Convert a string to a quadword integer.  */
__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
/* Convert a string to an unsigned quadword integer.  */
__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Convert a string to a quadword integer.  */
__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
/* Convert a string to an unsigned quadword integer.  */
__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another problem is
   the implementation of the internationalization handling in the
   ISO C++ standard library.  To support this another set of
   the functions using locale data exist which take an additional
   argument.

   Attention: even though several *_l interfaces are part of POSIX:2008,
   these are not.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */
# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997,2000,2002,2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 236 "/usr/include/stdlib.h" 2 3 4

/* Special versions of the functions above which take the locale to
   use as an additional parameter.  */
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 302 "/usr/include/stdlib.h" 3 4
/* Convert N to base 64 using the digits "./0-9A-Za-z", least-significant
   digit first.  Returns a pointer to static storage overwritten by the
   next call.  */
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;

/* Read a number from a string S in base 64 as above.  */
extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/sys/types.h" 2 3 4



# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 30 "/usr/include/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 104 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;
# 115 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 132 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 55 "/usr/include/time.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 56 "/usr/include/time.h" 2 3 4


/* Returned by `clock'.  */
typedef __clock_t clock_t;



# 71 "/usr/include/time.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 72 "/usr/include/time.h" 2 3 4


/* Returned by `time'.  */
typedef __time_t time_t;



# 88 "/usr/include/time.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 89 "/usr/include/time.h" 2 3 4

/* Clock ID used in clock and timer functions.  */
typedef __clockid_t clockid_t;
# 100 "/usr/include/time.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 101 "/usr/include/time.h" 2 3 4

/* Timer ID returned by `timer_create'.  */
typedef __timer_t timer_t;
# 133 "/usr/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 147 "/usr/include/sys/types.h" 2 3 4


/* Old compatibility names for C types.  */
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;


/* These size-specific names are used by some of the inet code.  */
# 186 "/usr/include/sys/types.h" 3 4
/* For GCC 2.7 and later, we can use specific type-size attributes.  */







typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));


/* Some code from BIND tests this macro to see if the types above are
   defined.  */





/* In BSD <sys/types.h> is expected to define BYTE_ORDER.  */
# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 217 "/usr/include/sys/types.h" 2 3 4

/* It also defines `fd_set' and the FD_* macros for `select'.  */
# 1 "/usr/include/sys/select.h" 1 3 4
/* `fd_set' type and related macros, and `select'/`pselect' declarations.
   Copyright (C) 1996-2003, 2009, 2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 25 "/usr/include/sys/select.h" 2 3 4

/* Get definition of needed basic types.  */
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 28 "/usr/include/sys/select.h" 2 3 4

/* Get __FD_* definitions.  */
# 1 "/usr/include/bits/select.h" 1 3 4
/* Copyright (C) 1997-1999,2001,2008,2009,2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 23 "/usr/include/bits/select.h" 2 3 4
# 31 "/usr/include/sys/select.h" 2 3 4

/* Get __sigset_t.  */
# 1 "/usr/include/bits/sigset.h" 1 3 4
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991, 1992, 1994, 1996, 1997, 2007, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 36 "/usr/include/bits/sigset.h" 3 4
/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */
# 34 "/usr/include/sys/select.h" 2 3 4






/* Get definition of timer specification structures.  */


# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 44 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
/* System-dependent timing definitions.  Linux version.
   Copyright (C) 1996,1997,1999-2003,2010,2011,2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <time.h> instead.
 */




# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 27 "/usr/include/bits/time.h" 2 3 4

/* A time value that is accurate to the nearest
   microsecond but also has a range of years.  */
struct timeval
  {
    __time_t tv_sec; /* Seconds.  */
    __suseconds_t tv_usec; /* Microseconds.  */
  };
# 46 "/usr/include/sys/select.h" 2 3 4







/* The fd_set member is required to be an array of longs.  */
typedef long int __fd_mask;

/* Some versions of <linux/posix_types.h> define this macros.  */

/* It's easier to assume 8-bit bytes than to get CHAR_BIT.  */




/* fd_set for select and pselect.  */
typedef struct
  {
    /* XPG4.2 requires this member name.  Otherwise avoid the name
       from the global namespace.  */

    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;

/* Maximum number of file descriptors in `fd_set'.  */



/* Sometimes the fd_set member is assumed to have this type.  */
typedef __fd_mask fd_mask;

/* Number of bits per word of `fd_set' (some code assumes this is 32).  */




/* Access macros for `fd_set'.  */








/* Check the first NFDS descriptors each in READFDS (if not NULL) for read
   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
   after waiting the interval specified therein.  Returns the number of ready
   descriptors, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);


/* Same as above only that the TIMEOUT value is given with higher
   resolution and a sigmask which is been set temporarily.  This version
   should be used.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);



/* Define some inlines helping to catch common problems.  */





# 220 "/usr/include/sys/types.h" 2 3 4

/* BSD defines these symbols, so we follow.  */
# 1 "/usr/include/sys/sysmacros.h" 1 3 4
/* Definitions of macros to access `dev_t' values.
   Copyright (C) 1996, 1997, 1999, 2003, 2004, 2007, 2011
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 24 "/usr/include/sys/sysmacros.h" 2 3 4

/* If the compiler does not know long long it is out of luck.  We are
   not going to hack weird hacks to support the dev_t representation
   they need.  */



__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 63 "/usr/include/sys/sysmacros.h" 3 4


/* Access the functions with their traditional names.  */
# 223 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;



/* Types from the Large File Support interface.  */


typedef __blkcnt_t blkcnt_t; /* Type to count number of disk blocks.  */



typedef __fsblkcnt_t fsblkcnt_t; /* Type to count file system blocks.  */



typedef __fsfilcnt_t fsfilcnt_t; /* Type to count file system inodes.  */
# 262 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t; /* Type to count number of disk blocks. */
typedef __fsblkcnt64_t fsblkcnt64_t; /* Type to count file system blocks.  */
typedef __fsfilcnt64_t fsfilcnt64_t; /* Type to count file system inodes.  */



/* Now add the thread types.  */

# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
/* Copyright (C) 2002-2007, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 271 "/usr/include/sys/types.h" 2 3 4



# 315 "/usr/include/stdlib.h" 2 3 4

/* These are the functions that actually do things.  The `random', `srandom',
   `initstate' and `setstate' functions are those from BSD Unices.
   The `rand' and `srand' functions are required by the ANSI standard.
   We provide both interfaces to the same random number generator.  */
/* Return a random long integer between 0 and RAND_MAX inclusive.  */
extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));

/* Seed the random number generator with the given number.  */
extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));

/* Initialize the random number generator to use state buffer STATEBUF,
   of length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,
   32, 64, 128 and 256, the bigger the better; values less than 8 will
   cause an error and values greater than 256 will be rounded down.  */
extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

/* Switch the random number generator to state buffer STATEBUF,
   which should have been previously initialized by `initstate'.  */
extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Reentrant versions of the `random' family of functions.
   These functions all use the following data structure to contain
   state, rather than global state variables.  */

struct random_data
  {
    int32_t *fptr; /* Front pointer.  */
    int32_t *rptr; /* Rear pointer.  */
    int32_t *state; /* Array of state values.  */
    int rand_type; /* Type of random number generator.  */
    int rand_deg; /* Degree of random number generator.  */
    int rand_sep; /* Distance between front and rear.  */
    int32_t *end_ptr; /* Pointer behind state table.  */
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





/* Return a random integer between 0 and RAND_MAX inclusive.  */
extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));
/* Seed the random number generator with the given number.  */
extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



/* Reentrant interface according to POSIX.1.  */
extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));




/* System V style 48-bit random number generator functions.  */

/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return non-negative, long integer in [0,2^31).  */
extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return signed, long integers in [-2^31,2^31).  */
extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Seed random number generator.  */
extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Data structure for communication with thread safe versions.  This
   type is to be regarded as opaque.  It's only exported because users
   have to allocate objects of this type.  */
struct drand48_data
  {
    unsigned short int __x[3]; /* Current state.  */
    unsigned short int __old_x[3]; /* Old state.  */
    unsigned short int __c; /* Additive const. in congruential formula.  */
    unsigned short int __init; /* Flag for initializing.  */
    unsigned long long int __a; /* Factor in congruential formula.  */
  };

/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Return non-negative, long integer in [0,2^31).  */
extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Return signed, long integers in [-2^31,2^31).  */
extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Seed random number generator.  */
extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));








/* Allocate SIZE bytes of memory.  */
extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;
/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;





/* Re-allocate the previously allocated block
   in PTR, making the new block SIZE bytes long.  */
/* __attribute_malloc__ is not used, because if realloc returns
   the same pointer that was passed to it, aliasing needs to be allowed
   between objects pointed by the old and new pointers.  */
extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
/* Free a block allocated by `malloc', `realloc' or `calloc'.  */
extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



/* Free a block.  An alias for `free'.	(Sun Unices).  */
extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/alloca.h" 1 3 4
/* Copyright (C) 1992, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/alloca.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 25 "/usr/include/alloca.h" 2 3 4



/* Remove any previous definitions.  */


/* Allocate a block that will be freed when the calling function exits.  */
extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 492 "/usr/include/stdlib.h" 2 3 4




/* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  */
extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;



/* Allocate memory of SIZE bytes with an alignment of ALIGNMENT.  */
extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



/* ISO C variant of aligned allocation.  */
extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__, __alloc_size__ (2)));



/* Abort execution and generate a core-dump.  */
extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


/* Register a function to be called when `exit' is called.  */
extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Register a function to be called when `quick_exit' is called.  */




extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





/* Register a function to be called with the status
   given to `exit' and the given argument.  */
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Call all functions registered with `atexit' and `on_exit',
   in the reverse of the order in which they were registered,
   perform stdio cleanup, and terminate program execution with STATUS.  */
extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


/* Call all functions registered with `at_quick_exit' in the reverse
   of the order in which they were registered and terminate program
   execution with STATUS.  */
extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





/* Terminate the program with STATUS without calling any of the
   functions registered with `atexit' or `on_exit'.  */
extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





/* Return the value of envariable NAME, or NULL if it doesn't exist.  */
extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



/* This function is similar to the above but returns NULL if the
   programs is running with SUID or SGID enabled.  */
extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



/* The SVID says this is in <stdio.h>, but this seems a better place.	*/
/* Put STRING, which is of the form "NAME=VALUE", in the environment.
   If there is no `=', remove NAME from the environment.  */
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Set NAME to VALUE in the environment.
   If REPLACE is nonzero, overwrite an existing value.  */
extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

/* Remove the variable NAME from the environment.  */
extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* The `clearenv' was planned to be added to POSIX.1 but probably
   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings
   for Fortran 77) requires this function.  */
extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));





/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the file name unique.
   Always returns TEMPLATE, it's either a temporary file name or a null
   string if it cannot get a unique file name.  */
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the filename unique.
   Returns a file descriptor open on the file for reading and writing,
   or -1 if it cannot create a uniquely-named file.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 629 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;




/* Similar to mkstemp, but the template can have a suffix after the
   XXXXXX.  The length of the suffix is specified in the second
   parameter.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 651 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;




/* Create a unique temporary directory from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the directory name unique.
   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
   The directory is created mode 700.  */
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



/* Generate a unique temporary file name from TEMPLATE similar to
   mkstemp.  But allow the caller to pass additional flags which are
   used in the open call to create the file..

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 683 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;


/* Similar to mkostemp, but the template can have a suffix after the
   XXXXXX.  The length of the suffix is specified in the second
   parameter.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 705 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;





/* Execute the given line as a shell command.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int system (const char *__command) ;




/* Return a malloc'd string containing the canonical absolute name of the
   existing named file.  */
extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



/* Return the canonical absolute name of file NAME.  If RESOLVED is
   null, the result is malloc'd; otherwise, if the canonical name is
   PATH_MAX chars or more, returns null with `errno' set to
   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
   returns the name in RESOLVED.  */
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Shorthand for type of comparison functions.  */


typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);



/* Do a binary search for KEY in BASE, which consists of NMEMB elements
   of SIZE bytes each, using COMPAR to perform the comparisons.  */
extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;

/* Sort NMEMB elements of BASE, of SIZE bytes each,
   using COMPAR to perform the comparisons.  */
extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));



/* Return the absolute value of X.  */
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




/* Return the `div_t', `ldiv_t' or `lldiv_t' representation
   of the value of NUMER over DENOM. */
/* GCC may have built-ins for these someday.  */
extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






/* Convert floating point numbers to strings.  The returned values are
   valid only until another call to the same function.  */

/* Convert VALUE to a string with NDIGIT digits and return a pointer to
   this.  Set *DECPT with the position of the decimal character and *SIGN
   with the sign of the number.  */
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;

/* Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT
   with the position of the decimal character and *SIGN with the sign of
   the number.  */
extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;

/* If possible convert VALUE to a string with NDIGIT significant digits.
   Otherwise use exponential representation.  The resulting string will
   be written to BUF.  */
extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;



/* Long double versions of above functions.  */
extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;


/* Reentrant version of the functions above which provide their own
   buffers.  */
extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





/* Return the length of the multibyte character
   in S, which is no longer than N.  */
extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) ;
/* Return the length of the given multibyte character,
   putting its `wchar_t' representation in *PWC.  */
extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) ;
/* Put the multibyte character represented
   by WCHAR in S, returning its length.  */
extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Convert a multibyte string to a wide char string.  */
extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));
/* Convert a wide char string to multibyte string.  */
extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));




/* Determine whether the string value of RESPONSE matches the affirmation
   or negative response expression as specified by the LC_MESSAGES category
   in the program's current locale.  Returns 1 if affirmative, 0 if
   negative, and -1 if not matching.  */
extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




/* Parse comma separated suboption from *OPTIONP and match against
   strings in TOKENS.  If found return index and set *VALUEP to
   optional value introduced by an equal sign.  If the suboption is
   not part of TOKENS return in *VALUEP beginning of unknown
   suboption.  On exit *OPTIONP is set to the beginning of the next
   token or at the terminating NUL character.  */
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;




/* Setup DES tables according KEY.  */
extern void setkey (const char *__key) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* X/Open pseudo terminal handling.  */


/* Return a master pseudo-terminal handle.  */
extern int posix_openpt (int __oflag) ;



/* The next four functions all take a master pseudo-tty fd and
   perform an operation on the associated slave:  */

/* Chown the slave to the calling user.  */
extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));

/* Release an internal lock so the slave can be opened.
   Call after grantpt().  */
extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));

/* Return the pathname of the pseudo terminal slave assoicated with
   the master FD is open on, or NULL on errors.
   The returned storage is good until the next call to this function.  */
extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Store at most BUFLEN characters of the pathname of the slave pseudo
   terminal associated with the master FD is open on in BUF.
   Return 0 on success, otherwise an error number.  */
extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

/* Open a master pseudo terminal and return its file descriptor.  */
extern int getpt (void);



/* Put the 1 minute, 5 minute and 15 minute load averages into the first
   NELEM elements of LOADAVG.  Return the number written (never more than
   three, but may be less than NELEM), or -1 if an error occurred.  */
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/bits/stdlib-float.h" 1 3 4
/* Floating-point inline functions for stdlib.h.
   Copyright (C) 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 952 "/usr/include/stdlib.h" 2 3 4

/* Define some macros helping to catch buffer overflows.  */
# 964 "/usr/include/stdlib.h" 3 4

# 73 "src/exim.h" 2
# 1 "/usr/include/string.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.21 String handling	<string.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/string.h" 2 3 4



/* Get size_t and NULL from <stddef.h>.  */


# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 33 "/usr/include/string.h" 2 3 4

/* Tell the caller that we provide correct C++ prototypes.  */






/* Copy N bytes of SRC to DEST.  */
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
/* Copy N bytes of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  */
extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


/* Copy no more than N bytes of SRC to DEST, stopping when C is found.
   Return the position in DEST one byte past where C was copied,
   or NULL if C was not found in the first N bytes of SRC.  */

extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




/* Set N bytes of S to C.  */
extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Compare N bytes of S1 and S2.  */
extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

/* Search N bytes of S for C.  */
# 92 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




/* Search in S for C.  This is similar to `memchr' but there is no
   length limit.  */






extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


/* Search N bytes of S for the final occurrence of C.  */






extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





/* Copy SRC to DEST.  */
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
/* Copy no more than N characters of SRC to DEST.  */
extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Append SRC onto DEST.  */
extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
/* Append no more than N characters from SRC onto DEST.  */
extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Compare S1 and S2.  */
extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
/* Compare N characters of S1 and S2.  */
extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

/* Compare the collated forms of S1 and S2.  */
extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
/* Put a transformation of SRC into no more than N bytes of DEST.  */
extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* The following functions are equivalent to the both above but they
   take the locale they use for the collation as an extra argument.
   This is not standardsized but something like will come.  */
# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997,2000,2002,2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 160 "/usr/include/string.h" 2 3 4

/* Compare the collated forms of S1 and S2 using rules from L.  */
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));
/* Put a transformation of SRC into no more than N bytes of DEST.  */
extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));




/* Duplicate S, returning an identical malloc'd string.  */
extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));


/* Return a malloc'd copy of at most N bytes of STRING.  The
   resultant string is terminated even if no null terminator
   appears before STRING[N].  */

extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));



/* Duplicate S, returning an identical alloca'd string.  */
# 195 "/usr/include/string.h" 3 4
/* Return an alloca'd copy of at most N bytes of string.  */
# 207 "/usr/include/string.h" 3 4

/* Find the first occurrence of C in S.  */
# 232 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

/* Find the last occurrence of C in S.  */
# 259 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




/* This function is similar to `strchr'.  But it returns a pointer to
   the closing NUL byte in case C is not found in S.  */






extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




/* Return the length of the initial segment of S which
   consists entirely of characters not in REJECT.  */
extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
/* Return the length of the initial segment of S which
   consists entirely of characters in ACCEPT.  */
extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
/* Find the first occurrence in S of any character in ACCEPT.  */
# 311 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

/* Find the first occurrence of NEEDLE in HAYSTACK.  */
# 338 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



/* Divide S into tokens separated by characters in DELIM.  */
extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


/* Divide S into tokens separated by characters in DELIM.  Information
   passed between calls are stored in SAVE_PTR.  */
extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));



/* Similar to `strstr' but this function ignores the case of both strings.  */







extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




/* Find the first occurrence of NEEDLE in HAYSTACK.
   NEEDLE is NEEDLELEN bytes long;
   HAYSTACK is HAYSTACKLEN bytes long.  */
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));

/* Copy N bytes of SRC to DEST, return pointer to bytes after the
   last written byte.  */
extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




/* Return the length of S.  */
extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));



/* Find the length of STRING, but scan at most MAXLEN characters.
   If no '\0' terminator is found in that many characters, return MAXLEN.  */
extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




/* Return a string describing the meaning of the `errno' code in ERRNUM.  */
extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));


/* Reentrant version of `strerror'.
   There are 2 flavors of `strerror_r', GNU which returns the string
   and may or may not use the supplied temporary buffer and POSIX one
   which fills the string into the buffer.
   To use the POSIX version, -D_XOPEN_SOURCE=600 or -D_POSIX_C_SOURCE=200112L
   without -D_GNU_SOURCE is needed, otherwise the GNU version is
   preferred.  */
# 432 "/usr/include/string.h" 3 4
/* If a temporary buffer is required, at most BUFLEN bytes of BUF will be
   used.  */
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;




/* Translate error number to string according to the locale L.  */
extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



/* We define this function always since `bzero' is sometimes needed when
   the namespace rules does not allow this.  */
extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Copy N bytes of SRC to DEST (like memmove, but args reversed).  */
extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set N bytes of S to 0.  */
extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Compare N bytes of S1 and S2 (same as memcmp).  */
extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

/* Find the first occurrence of C in S (same as strchr).  */
# 485 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


/* Find the last occurrence of C in S (same as strrchr).  */
# 513 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


/* Return the position of the first bit set in I, or 0 if none are set.
   The least-significant bit is position 1, the most-significant 32.  */
extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* The following two functions are non-standard but necessary for non-32 bit
   platforms.  */

extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



/* Compare S1 and S2, ignoring case.  */
extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

/* Compare no more than N chars of S1 and S2, ignoring case.  */
extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



/* Again versions of a few functions which use the given locale instead
   of the global one.  */
extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



/* Return the next DELIM-delimited token from *STRINGP,
   terminating it with a '\0', and update *STRINGP to point past it.  */
extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



/* Return a string describing the meaning of the signal number in SIG.  */
extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));

/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */
extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  */
extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



/* Compare S1 and S2 as strings holding name & indices/version numbers.  */
extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

/* Sautee STRING briskly.  */
extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Frobnicate N bytes of S.  */
extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return the file name within directory of FILENAME.  We don't
   declare the function if the `basename' macro is available (defined
   in <libgen.h>) which makes the XPG version of this function
   available.  */






extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 642 "/usr/include/string.h" 3 4

# 74 "src/exim.h" 2
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */






# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 28 "/usr/include/time.h" 2 3 4






/* Get size_t and NULL from <stddef.h>.  */


# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 38 "/usr/include/time.h" 2 3 4

/* This defines CLOCKS_PER_SEC, which is the number of processor clock
   ticks per second.  */
# 1 "/usr/include/bits/time.h" 1 3 4
/* System-dependent timing definitions.  Linux version.
   Copyright (C) 1996,1997,1999-2003,2010,2011,2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <time.h> instead.
 */
# 42 "/usr/include/bits/time.h" 3 4
/* ISO/IEC 9899:1990 7.12.1: <time.h>
   The macro `CLOCKS_PER_SEC' is the number per second of the value
   returned by the `clock' function. */
/* CAE XSH, Issue 4, Version 2: <time.h>
   The value of CLOCKS_PER_SEC is required to be 1 million on all
   XSI-conformant systems. */
# 60 "/usr/include/bits/time.h" 3 4
/* Identifier for system-wide realtime clock.  */

/* Monotonic system-wide clock.  */

/* High-resolution timer from the CPU.  */

/* Thread-specific CPU-time clock.  */

/* Monotonic system-wide clock, not adjusted for frequency scaling.  */

/* Identifier for system-wide realtime clock, updated only on ticks.  */

/* Monotonic system-wide clock, updated only on ticks.  */

/* Monotonic system-wide clock that includes time spent in suspension.  */

/* Like CLOCK_REALTIME but also wakes suspended system.  */

/* Like CLOCK_BOOTTIME but also wakes suspended system.  */


/* Flag to indicate time is absolute.  */




# 1 "/usr/include/bits/timex.h" 1 3 4
/* Copyright (C) 1995-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 22 "/usr/include/bits/timex.h" 2 3 4

/* These definitions from linux/timex.h as of 2.6.30.  */

struct timex
{
  unsigned int modes; /* mode selector */
  __syscall_slong_t offset; /* time offset (usec) */
  __syscall_slong_t freq; /* frequency offset (scaled ppm) */
  __syscall_slong_t maxerror; /* maximum error (usec) */
  __syscall_slong_t esterror; /* estimated error (usec) */
  int status; /* clock command/status */
  __syscall_slong_t constant; /* pll time constant */
  __syscall_slong_t precision; /* clock precision (usec) (ro) */
  __syscall_slong_t tolerance; /* clock frequency tolerance (ppm) (ro) */
  struct timeval time; /* (read only) */
  __syscall_slong_t tick; /* (modified) usecs between clock ticks */
  __syscall_slong_t ppsfreq; /* pps frequency (scaled ppm) (ro) */
  __syscall_slong_t jitter; /* pps jitter (us) (ro) */
  int shift; /* interval duration (s) (shift) (ro) */
  __syscall_slong_t stabil; /* pps stability (scaled ppm) (ro) */
  __syscall_slong_t jitcnt; /* jitter limit exceeded (ro) */
  __syscall_slong_t calcnt; /* calibration intervals (ro) */
  __syscall_slong_t errcnt; /* calibration errors (ro) */
  __syscall_slong_t stbcnt; /* stability limit exceeded (ro) */

  int tai; /* TAI offset (ro) */

  /* ??? */
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};

/* Mode codes (timex.mode) */
# 69 "/usr/include/bits/timex.h" 3 4
/* xntp 3.4 compatibility names */
# 83 "/usr/include/bits/timex.h" 3 4
/* Status codes (timex.status) */
# 104 "/usr/include/bits/timex.h" 3 4
/* Read-only bits */
# 87 "/usr/include/bits/time.h" 2 3 4



/* Tune a POSIX clock.  */
extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));


# 42 "/usr/include/time.h" 2 3 4

/* This is the obsolete POSIX.1-1988 name for the same constant.  */
# 131 "/usr/include/time.h" 3 4

/* Used by other time functions.  */
struct tm
{
  int tm_sec; /* Seconds.	[0-60] (1 leap second) */
  int tm_min; /* Minutes.	[0-59] */
  int tm_hour; /* Hours.	[0-23] */
  int tm_mday; /* Day.		[1-31] */
  int tm_mon; /* Month.	[0-11] */
  int tm_year; /* Year	- 1900.  */
  int tm_wday; /* Day of week.	[0-6] */
  int tm_yday; /* Days in year.[0-365]	*/
  int tm_isdst; /* DST.		[-1/0/1]*/


  long int tm_gmtoff; /* Seconds east of UTC.  */
  const char *tm_zone; /* Timezone abbreviation.  */




};







/* POSIX.1b structure for timer start values and intervals.  */
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };

/* We can use a simple forward declaration.  */
struct sigevent;
# 181 "/usr/include/time.h" 3 4
/* Time base values for timespec_get.  */





/* Time used by the program so far (user time + system time).
   The result / CLOCKS_PER_SECOND is program time in seconds.  */
extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));

/* Return the current time and put it in *TIMER if TIMER is not NULL.  */
extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));

/* Return the difference between TIME1 and TIME0.  */
extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return the `time_t' representation of TP and normalize TP.  */
extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE characters and return the number
   of characters written, or 0 if it would exceed MAXSIZE.  */
extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



/* Parse S according to FORMAT and store binary time information in TP.
   The return value is a pointer to the first unparsed character in S.  */
extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));



/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */
# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997,2000,2002,2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 222 "/usr/include/time.h" 2 3 4

extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));




/* Return the `struct tm' representation of *TIMER
   in Universal Coordinated Time (aka Greenwich Mean Time).  */
extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));

/* Return the `struct tm' representation
   of *TIMER in the local timezone.  */
extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



/* Return the `struct tm' representation of *TIMER in UTC,
   using *TP to store the result.  */
extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));

/* Return the `struct tm' representation of *TIMER in local time,
   using *TP to store the result.  */
extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



/* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));

/* Equivalent to `asctime (localtime (timer))'.  */
extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



/* Reentrant versions of the above functions.  */

/* Return in BUF a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));

/* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  */
extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



/* Defined in localtime.c.  */
extern char *__tzname[2]; /* Current timezone names.  */
extern int __daylight; /* If daylight-saving time is ever in use.  */
extern long int __timezone; /* Seconds west of UTC.  */



/* Same as above.  */
extern char *tzname[2];

/* Set time conversion information from the TZ environment variable.
   If TZ is not defined, a locale-dependent default is used.  */
extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;



/* Set the system time to *WHEN.
   This call is restricted to the superuser.  */
extern int stime (const time_t *__when) __attribute__ ((__nothrow__ , __leaf__));



/* Nonzero if YEAR is a leap year (every 4 years,
   except every 100th isn't, and every 400th is).  */





/* Miscellaneous functions many Unices inherited from the public domain
   localtime package.  These are included only for compatibility.  */

/* Like `mktime', but for TP represents Universal Time, not local time.  */
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));

/* Another name for `mktime'.  */
extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));

/* Return the number of days in YEAR.  */
extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




/* Pause execution for a number of nanoseconds.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);


/* Get resolution of clock CLOCK_ID.  */
extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));

/* Get current value of clock CLOCK_ID and store it in TP.  */
extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));

/* Set clock CLOCK_ID to value TP.  */
extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));


/* High-resolution sleep with the specified clock.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);

/* Return clock ID for CPU-time clock.  */
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));



/* Create new per-process timer using CLOCK_ID.  */
extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));

/* Delete timer TIMERID.  */
extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));

/* Set timer TIMERID to VALUE, returning old value in OVALUE.  */
extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));

/* Get current value of timer TIMERID and store it in VALUE.  */
extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));

/* Get expiration overrun for timer TIMERID.  */
extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));




/* Set TS to calendar time based in time base BASE.  */
extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Set to one of the following values to indicate an error.
     1  the DATEMSK environment variable is null or undefined,
     2  the template file cannot be opened for reading,
     3  failed to get file status information,
     4  the template file is not a regular file,
     5  an error is encountered while reading the template file,
     6  memory allication failed (not enough memory available),
     7  there is no line in the template that matches the input,
     8  invalid input specification Example: February 31 or a time is
	specified that can not be represented in a time_t (representing
	the time in seconds since 00:00:00 UTC, January 1, 1970) */
extern int getdate_err;

/* Parse the given string as a date specification and return a value
   representing the value.  The templates from the file identified by
   the environment variable DATEMSK are used.  In case of an error
   `getdate_err' is set.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct tm *getdate (const char *__string);



/* Since `getdate' is not reentrant because of the use of `getdate_err'
   and the static buffer to return the result in, we provide a thread-safe
   variant.  The functionality is the same.  The result is returned in
   the buffer pointed to by RESBUFP and in case of an error the return
   value is != 0 with the same values as given above for `getdate_err'.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 75 "src/exim.h" 2

/* Unix includes */

# 1 "/usr/include/errno.h" 1 3 4
/* Copyright (C) 1991,92,93,94,95,96,97,2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.5 Errors	<errno.h>
 */



/* The includer defined __need_Emath if he wants only the definitions
   of EDOM and ERANGE, and not everything else.  */


# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 29 "/usr/include/errno.h" 2 3 4




/* Get the error number constants from the system-specific file.
   This file will test __need_Emath and _ERRNO_H.  */
# 1 "/usr/include/bits/errno.h" 1 3 4
/* Error constants.  Linux specific version.
   Copyright (C) 1996-1999, 2005, 2009, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 105 "/usr/include/asm-generic/errno.h" 3 4
/* for robust mutexes */
# 1 "/usr/include/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/bits/errno.h" 2 3 4

/* Linux has no ENOTSUP error code.  */


/* Older Linux versions also had no ECANCELED error code.  */




/* Support for error codes to support robust mutexes was added later, too.  */
# 49 "/usr/include/bits/errno.h" 3 4
/* Function to get address of global `errno' variable.  */
extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* When using threads, errno is a per-thread value.  */
# 36 "/usr/include/errno.h" 2 3 4




/* Declare the `errno' variable, unless it's defined as a macro by
   bits/errno.h.  This is the case in GNU, where it is a per-thread
   variable.  This redeclaration using the macro still works, but it
   will be a function declaration without a prototype and may trigger
   a -Wstrict-prototypes warning.  */






/* The full and simple forms of the name with which the program was
   invoked.  These variables are set up automatically at startup based on
   the value of ARGV[0] (this works only if you use GNU ld).  */
extern char *program_invocation_name, *program_invocation_short_name;







/* The Hurd <bits/errno.h> defines `error_t' as an enumerated type so
   that printing `error_t' values in the debugger shows the names.  We
   might need this definition sometimes even if this file was included
   before.  */


typedef int error_t;
# 79 "src/exim.h" 2





# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include-fixed/limits.h" 1 3 4
/* Copyright (C) 1992-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */




/* Use "..." so that we find syslimits.h only in this same directory.  */
# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include-fixed/syslimits.h" 1 3 4
/* syslimits.h stands for the system's own limits.h file.
   If we can use it ok unmodified, then we install this text.
   If fixincludes fixes it, then the fixed version is installed
   instead of this text.  */


# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include-fixed/limits.h" 1 3 4
/* Copyright (C) 1992-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
# 168 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
/* Copyright (C) 1991, 1992, 1996, 1997, 1998, 1999, 2000, 2005
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/limits.h" 2 3 4


/* Maximum length of any multibyte character in any locale.
   We define this value here since the gcc header does not define
   the correct value.  */



/* If we are not using GNU CC we have to define all the symbols ourself.
   Otherwise use gcc's definitions (see below).  */
# 117 "/usr/include/limits.h" 3 4
 /* Get the compiler's limits.h, which defines almost all the ISO constants.

    We put this #include_next outside the double inclusion check because
    it should be possible to include this file more than once and still get
    the definitions from gcc's header.  */





/* The <limits.h> files in some gcc versions don't define LLONG_MIN,
   LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
   ages are available.  */
# 143 "/usr/include/limits.h" 3 4
/* POSIX adds things to <limits.h>.  */
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
 *
 *	Never include this file directly; use <limits.h> instead.
 */





/* These are the standard-mandated minimum values.  */

/* Minimum number of operations in one list I/O call.  */


/* Minimal number of outstanding asynchronous I/O operations.  */


/* Maximum length of arguments to `execve', including environment.  */


/* Maximum simultaneous processes per real user ID.  */






/* Minimal number of timer expiration overruns.  */


/* Maximum length of a host name (not including the terminating null)
   as returned from the GETHOSTNAME function.  */


/* Maximum link count of a file.  */


/* Maximum length of login name.  */


/* Number of bytes in a terminal canonical input queue.  */


/* Number of bytes for which space will be
   available in a terminal input queue.  */


/* Maximum number of message queues open for a process.  */


/* Maximum number of supported message priorities.  */


/* Number of bytes in a filename.  */


/* Number of simultaneous supplementary group IDs per process.  */






/* Number of files one process can have open at once.  */







/* Number of descriptors that a process may examine with `pselect' or
   `select'.  */



/* Number of bytes in a pathname.  */


/* Number of bytes than can be written atomically to a pipe.  */


/* The number of repeated occurrences of a BRE permitted by the
   REGEXEC and REGCOMP functions when using the interval notation.  */


/* Minimal number of realtime signals reserved for the application.  */


/* Number of semaphores a process can have.  */


/* Maximal value of a semaphore.  */


/* Number of pending realtime signals.  */


/* Largest value of a `ssize_t'.  */


/* Number of streams a process can have open at once.  */


/* The number of bytes in a symbolic link.  */


/* The number of symbolic links that can be traversed in the
   resolution of a pathname in the absence of a loop.  */


/* Number of timer for a process.  */


/* Maximum number of characters in a tty name.  */


/* Maximum length of a timezone name (element of `tzname').  */







/* Maximum number of connections that can be queued on a socket.  */


/* Maximum number of bytes that can be buffered on a socket for send
   or receive.  */


/* Maximum number of elements in an `iovec' array.  */



/* Maximum clock resolution in nanoseconds.  */



/* Get the implementation-specific values for the above.  */
# 1 "/usr/include/bits/local_lim.h" 1 3 4
/* Minimum guaranteed maximum values for system limits.  Linux version.
   Copyright (C) 1993-1998,2000,2002-2004,2008 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If
   not, see <http://www.gnu.org/licenses/>.  */

/* The kernel header pollutes the namespace with the NR_OPEN symbol
   and defines LINK_MAX although filesystems have different maxima.  A
   similar thing is true for OPEN_MAX: the limit can be changed at
   runtime and therefore the macro must not be defined.  Remove this
   after including the header if necessary.  */
# 37 "/usr/include/bits/local_lim.h" 3 4
/* The kernel sources contain a file with all the needed information.  */
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 2 3 4

/* Have to remove NR_OPEN?  */




/* Have to remove LINK_MAX?  */




/* Have to remove OPEN_MAX?  */




/* Have to remove ARG_MAX?  */





/* The number of data keys per process.  */

/* This is the value this implementation supports.  */


/* Controlling the iterations of destructors for thread-specific data.  */

/* Number of iterations this implementation does.  */


/* The number of threads per process.  */

/* We have no predefined limit on the number of threads.  */


/* Maximum amount by which a process can descrease its asynchronous I/O
   priority level.  */


/* Minimum size for a thread.  We are free to choose a reasonable value.  */


/* Maximum number of timer expiration overruns.  */


/* Maximum tty name length.  */


/* Maximum login name length.  This is arbitrary.  */


/* Maximum host name length.  */


/* Maximum message queue priority level.  */


/* Maximum value the semaphore can have.  */
# 161 "/usr/include/bits/posix1_lim.h" 2 3 4







/* This value is a guaranteed minimum maximum.
   The current maximum can be got from `sysconf'.  */
# 145 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
/* Copyright (C) 1991, 1996, 1999, 2000, 2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; include <limits.h> instead.
 */





/* The maximum `ibase' and `obase' values allowed by the `bc' utility.  */


/* The maximum number of elements allowed in an array by the `bc' utility.  */


/* The maximum `scale' value allowed by the `bc' utility.  */


/* The maximum length of a string constant accepted by the `bc' utility.  */


/* The maximum number of weights that can be assigned to an entry of
   the LC_COLLATE `order' keyword in the locale definition file.  */


/* The maximum number of expressions that can be nested
   within parentheses by the `expr' utility.  */


/* The maximum length, in bytes, of an input line.  */


/* The maximum number of repeated occurrences of a regular expression
   permitted when using the interval notation `\{M,N\}'.  */


/* The maximum number of bytes in a character class name.  We have no
   fixed limit, 2048 is a high number.  */



/* These values are implementation-specific,
   and may vary within the implementation.
   Their precise values can be obtained from sysconf.  */
# 87 "/usr/include/bits/posix2_lim.h" 3 4
/* This value is defined like this in regex.h.  */
# 149 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <limits.h> instead.
 */

/* Additional definitions from X/Open Portability Guide, Issue 4, Version 2
   System Interfaces and Headers, 4.16 <limits.h>

   Please note only the values which are not greater than the minimum
   stated in the standard document are listed.  The `sysconf' functions
   should be used to obtain the actual value.  */





# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
/* Copyright (C) 1994, 1997, 1998, 1999, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 34 "/usr/include/bits/xopen_lim.h" 2 3 4

/* We do not provide fixed values for

   ARG_MAX	Maximum length of argument to the `exec' function
		including environment data.

   ATEXIT_MAX	Maximum number of functions that may be registered
		with `atexit'.

   CHILD_MAX	Maximum number of simultaneous processes per real
		user ID.

   OPEN_MAX	Maximum number of files that one process can have open
		at anyone time.

   PAGESIZE
   PAGE_SIZE	Size of bytes of a page.

   PASS_MAX	Maximum number of significant bytes in a password.

   We only provide a fixed limit for

   IOV_MAX	Maximum number of `iovec' structures that one process has
		available for use with `readv' or writev'.

   if this is indeed fixed by the underlying system.
*/


/* Maximum number of `iovec' structures that one process has available
   for use with `readv' or writev'.  */



/* Maximum value of `digit' in calls to the `printf' and `scanf'
   functions.  We have no limit, so return a reasonable value.  */


/* Maximum number of bytes in a `LANG' name.  We have no limit.  */


/* Maximum message number.  We have no limit.  */


/* Maximum number of bytes in N-to-1 collation mapping.  We have no
   limit.  */


/* Maximum set number.  We have no limit.  */


/* Maximum number of bytes in a message.  We have no limit.  */


/* Default process priority.  */



/* Number of bits in a word of type `int'.  */
# 119 "/usr/include/bits/xopen_lim.h" 3 4
/* Number of bits in a word of type `long int'.  */
# 131 "/usr/include/bits/xopen_lim.h" 3 4
/* Safe assumption.  */
# 153 "/usr/include/limits.h" 2 3 4
# 169 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include-fixed/limits.h" 2 3 4

/* Copyright (C) 1991-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */




/* Number of bits in a `char'.  */



/* Maximum length of a multibyte character.  */




/* Minimum and maximum values a `signed char' can hold.  */





/* Maximum value an `unsigned char' can hold.  (Minimum is 0).  */







/* Minimum and maximum values a `char' can hold.  */
# 102 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include-fixed/limits.h" 3 4
/* Minimum and maximum values a `signed short int' can hold.  */





/* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  */







/* Minimum and maximum values a `signed int' can hold.  */





/* Maximum value an `unsigned int' can hold.  (Minimum is 0).  */



/* Minimum and maximum values a `signed long int' can hold.
   (Same as `int').  */





/* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  */
# 150 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include-fixed/limits.h" 3 4
/* Minimum and maximum values a `signed long long int' can hold.  */





/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */





/* This administrivia gets added to the end of limits.h
   if the system has its own version of limits.h.  */
# 85 "src/exim.h" 2


/* C99 integer types, figure out how to undo this if needed for older systems */

# 1 "/usr/include/inttypes.h" 1 3 4
/* Copyright (C) 1997-2001, 2004, 2007, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99: 7.8 Format conversion of integer types	<inttypes.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/inttypes.h" 2 3 4
/* Get the type definitions.  */
# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
/* Copyright (C) 1997,1998,1999,2000,2001,2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99: 7.18 Integer types <stdint.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wchar.h" 1 3 4
/* wchar_t type related definitions.  i386/x86-64 version.
   Copyright (C) 2000-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 23 "/usr/include/bits/wchar.h" 2 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 28 "/usr/include/stdint.h" 2 3 4

/* Exact integral types.  */

/* Signed.  */

/* There is some amount of overlap with <sys/types.h> as known by inet code */
# 47 "/usr/include/stdint.h" 3 4
/* Unsigned.  */
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;






/* Small types.  */

/* Signed.  */
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;





/* Unsigned.  */
typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;






/* Fast types.  */

/* Signed.  */
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;







/* Unsigned.  */
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 116 "/usr/include/stdint.h" 3 4
/* Types for `void *' pointers.  */


typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 132 "/usr/include/stdint.h" 3 4
/* Largest integral types.  */

typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 144 "/usr/include/stdint.h" 3 4
/* The ISO C99 standard specifies that in C++ implementations these
   macros should only be defined if explicitly requested.  */
# 156 "/usr/include/stdint.h" 3 4
/* Limits of integral types.  */

/* Minimum of signed integral types.  */




/* Maximum of signed integral types.  */





/* Maximum of unsigned integral types.  */






/* Minimum of signed integral types having a minimum size.  */




/* Maximum of signed integral types having a minimum size.  */





/* Maximum of unsigned integral types having a minimum size.  */






/* Minimum of fast signed integral types having a minimum size.  */
# 204 "/usr/include/stdint.h" 3 4
/* Maximum of fast signed integral types having a minimum size.  */
# 215 "/usr/include/stdint.h" 3 4
/* Maximum of fast unsigned integral types having a minimum size.  */
# 227 "/usr/include/stdint.h" 3 4
/* Values to test for integral types holding `void *' pointer.  */
# 239 "/usr/include/stdint.h" 3 4
/* Minimum for largest signed integral type.  */

/* Maximum for largest signed integral type.  */


/* Maximum for largest unsigned integral type.  */



/* Limits of other integer types.  */

/* Limits of `ptrdiff_t' type.  */
# 259 "/usr/include/stdint.h" 3 4
/* Limits of `sig_atomic_t'.  */



/* Limit of `size_t' type.  */






/* Limits of `wchar_t'.  */

/* These constants might also be defined in <wchar.h>.  */




/* Limits of `wint_t'.  */






/* The ISO C99 standard specifies that in C++ implementations these
   should only be defined if explicitly requested.  */


/* Signed.  */
# 298 "/usr/include/stdint.h" 3 4
/* Unsigned.  */
# 308 "/usr/include/stdint.h" 3 4
/* Maximal type.  */
# 10 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdint.h" 2 3 4
# 28 "/usr/include/inttypes.h" 2 3 4

/* Get a definition for wchar_t.  But we must not define wchar_t itself.  */




typedef int __gwchar_t;
# 44 "/usr/include/inttypes.h" 3 4
/* The ISO C99 standard specifies that these macros must only be
   defined if explicitly requested.  */
# 56 "/usr/include/inttypes.h" 3 4
/* Macros for printing format specifiers.  */

/* Decimal notation.  */
# 90 "/usr/include/inttypes.h" 3 4
/* Octal notation.  */
# 106 "/usr/include/inttypes.h" 3 4
/* Unsigned integers.  */
# 122 "/usr/include/inttypes.h" 3 4
/* lowercase hexadecimal notation.  */
# 138 "/usr/include/inttypes.h" 3 4
/* UPPERCASE hexadecimal notation.  */
# 155 "/usr/include/inttypes.h" 3 4
/* Macros for printing `intmax_t' and `uintmax_t'.  */
# 164 "/usr/include/inttypes.h" 3 4
/* Macros for printing `intptr_t' and `uintptr_t'.  */
# 173 "/usr/include/inttypes.h" 3 4
/* Macros for scanning format specifiers.  */

/* Signed decimal notation.  */
# 191 "/usr/include/inttypes.h" 3 4
/* Signed decimal notation.  */
# 207 "/usr/include/inttypes.h" 3 4
/* Unsigned decimal notation.  */
# 223 "/usr/include/inttypes.h" 3 4
/* Octal notation.  */
# 239 "/usr/include/inttypes.h" 3 4
/* Hexadecimal notation.  */
# 256 "/usr/include/inttypes.h" 3 4
/* Macros for scanning `intmax_t' and `uintmax_t'.  */






/* Macros for scaning `intptr_t' and `uintptr_t'.  */
# 273 "/usr/include/inttypes.h" 3 4




/* We have to define the `uintmax_t' type using `ldiv_t'.  */
typedef struct
  {
    long int quot; /* Quotient.  */
    long int rem; /* Remainder.  */
  } imaxdiv_t;
# 296 "/usr/include/inttypes.h" 3 4
/* Compute absolute value of N.  */
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return the `imaxdiv_t' representation of the value of NUMER over DENOM. */
extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Like `strtol' but convert to `intmax_t'.  */
extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));

/* Like `strtoul' but convert to `uintmax_t'.  */
extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));

/* Like `wcstol' but convert to `intmax_t'.  */
extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));

/* Like `wcstoul' but convert to `uintmax_t'.  */
extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));
# 439 "/usr/include/inttypes.h" 3 4

# 90 "src/exim.h" 2

/* Just in case some aged system doesn't define them... */
# 109 "src/exim.h"
/* Some systems have PATH_MAX and some have MAX_PATH_LEN. */
# 119 "src/exim.h"
# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 120 "src/exim.h" 2
# 1 "/usr/include/sys/file.h" 1 3 4
/* Copyright (C) 1991, 92, 96, 97, 98, 99 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/sys/file.h" 2 3 4


# 1 "/usr/include/fcntl.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 6.5 File Control Operations	<fcntl.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/fcntl.h" 2 3 4

/* This must be early so <bits/fcntl.h> can define types winningly.  */


/* Get __mode_t, __dev_t and __off_t  .*/
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 32 "/usr/include/fcntl.h" 2 3 4

/* Get the definitions of O_*, F_*, FD_*: all the
   numbers and flag bits for `open', `fcntl', et al.  */
# 1 "/usr/include/bits/fcntl.h" 1 3 4
/* O_*, F_*, FD_* bit values for Linux/x86.
   Copyright (C) 2001-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 28 "/usr/include/bits/fcntl.h" 3 4
/* Not necessary, we always have 64-bit offsets.  */






struct flock
  {
    short int l_type; /* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
    short int l_whence; /* Where `l_start' is relative to (like `lseek').  */

    __off_t l_start; /* Offset where the lock begins.  */
    __off_t l_len; /* Size of the locked area; zero means until EOF.  */




    __pid_t l_pid; /* Process holding the lock.  */
  };


struct flock64
  {
    short int l_type; /* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
    short int l_whence; /* Where `l_start' is relative to (like `lseek').  */
    __off64_t l_start; /* Offset where the lock begins.  */
    __off64_t l_len; /* Size of the locked area; zero means until EOF.  */
    __pid_t l_pid; /* Process holding the lock.  */
  };


/* Include generic Linux declarations.  */
# 1 "/usr/include/bits/fcntl-linux.h" 1 3 4
/* O_*, F_*, FD_* bit values for Linux.
   Copyright (C) 2001-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* This file contains shared definitions between Linux architectures
   and is included by <bits/fcntl.h> to declare them.  The various
   #ifndef cases allow the architecture specific file to define those
   values with different values.

   A minimal <bits/fcntl.h> contains just:

   struct flock {...}
   #ifdef __USE_LARGEFILE64
   struct flock64 {...}
   #endif
   #include <bits/fcntl-linux.h>
*/


# 1 "/usr/include/bits/uio.h" 1 3 4
/* Copyright (C) 1996, 1997, 2006, 2011, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 25 "/usr/include/bits/uio.h" 3 4
# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 26 "/usr/include/bits/uio.h" 2 3 4


/* We should normally use the Linux kernel header file to define this
   type and macros but this calls for trouble because of the header
   includes other kernel headers.  */

/* Size of object which can be written atomically.

   This macro has different values in different kernel versions.  The
   latest versions of the kernel use 1024 and this is good choice.  Since
   the C library implementation of readv/writev is able to emulate the
   functionality even if the currently running kernel does not support
   this large value the readv/writev call will not fail because of this.  */



/* Structure for scatter/gather I/O.  */
struct iovec
  {
    void *iov_base; /* Pointer to data.  */
    size_t iov_len; /* Length of data.  */
  };
# 39 "/usr/include/bits/fcntl-linux.h" 2 3 4


/* open/fcntl.  */
# 133 "/usr/include/bits/fcntl-linux.h" 3 4
/* For now, Linux has no separate synchronicitiy options for read
   operations.  We define O_RSYNC therefore as the same as O_SYNC
   since this is a superset.  */
# 145 "/usr/include/bits/fcntl-linux.h" 3 4
/* Values for the second argument to `fcntl'.  */
# 190 "/usr/include/bits/fcntl-linux.h" 3 4
/* For F_[GET|SET]FD.  */



/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */






/* For old implementation of BSD flock.  */






/* Operations for BSD flock, also used by the kernel implementation.  */
# 224 "/usr/include/bits/fcntl-linux.h" 3 4
/* Types of directory notifications that may be requested with F_NOTIFY.  */
# 236 "/usr/include/bits/fcntl-linux.h" 3 4
/* Owner types.  */
enum __pid_type
  {
    F_OWNER_TID = 0, /* Kernel thread.  */
    F_OWNER_PID, /* Process.  */
    F_OWNER_PGRP, /* Process group.  */
    F_OWNER_GID = F_OWNER_PGRP /* Alternative, obsolete name.  */
  };

/* Structure to use with F_GETOWN_EX and F_SETOWN_EX.  */
struct f_owner_ex
  {
    enum __pid_type type; /* Owner type of ID.  */
    __pid_t pid; /* ID of owner.  */
  };


/* Define some more compatibility macros to be backward compatible with
   BSD systems which did not managed to hide these kernel macros.  */
# 267 "/usr/include/bits/fcntl-linux.h" 3 4
/* Advise to `posix_fadvise'.  */
# 279 "/usr/include/bits/fcntl-linux.h" 3 4
/* Flags for SYNC_FILE_RANGE.  */
# 290 "/usr/include/bits/fcntl-linux.h" 3 4
/* Flags for SPLICE and VMSPLICE.  */
# 299 "/usr/include/bits/fcntl-linux.h" 3 4
/* File handle structure.  */
struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;
  /* File identifier.  */
  unsigned char f_handle[0];
};

/* Maximum handle size (for now).  */







/* Provide kernel hint to read ahead.  */
extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ , __leaf__));


/* Selective file content synch'ing.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);


/* Splice address range into a pipe.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
    size_t __count, unsigned int __flags);

/* Splice two files together.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
         __off64_t *__offout, size_t __len,
         unsigned int __flags);

/* In-kernel implementation of tee for pipe buffers.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern ssize_t tee (int __fdin, int __fdout, size_t __len,
      unsigned int __flags);

/* Reserve storage for the data of the file associated with FD.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 367 "/usr/include/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);



/* Map file name to file handle.  */
extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ , __leaf__));

/* Open file using the file handle.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);




# 61 "/usr/include/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4

/* POSIX.1-2001 specifies that these types are defined by <fcntl.h>.
   Earlier POSIX standards permitted any type ending in `_t' to be defined
   by any POSIX header, so we don't conditionalize the definitions here.  */
# 64 "/usr/include/fcntl.h" 3 4
/* For XPG all symbols from <sys/stat.h> should also be available.  */


# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 68 "/usr/include/fcntl.h" 2 3 4
# 1 "/usr/include/bits/stat.h" 1 3 4
/* Copyright (C) 1999-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 25 "/usr/include/bits/stat.h" 3 4
/* Versions of the `struct stat' data structure.  */
# 40 "/usr/include/bits/stat.h" 3 4
/* x86-64 versions of the `xmknod' interface.  */





struct stat
  {
    __dev_t st_dev; /* Device.  */




    __ino_t st_ino; /* File serial number.	*/







    __nlink_t st_nlink; /* Link count.  */
    __mode_t st_mode; /* File mode.  */

    __uid_t st_uid; /* User ID of the file's owner.	*/
    __gid_t st_gid; /* Group ID of the file's group.*/

    int __pad0;

    __dev_t st_rdev; /* Device number, if device.  */




    __off_t st_size; /* Size of file, in bytes.  */



    __blksize_t st_blksize; /* Optimal block size for I/O.  */

    __blkcnt_t st_blocks; /* Number 512-byte blocks allocated. */




    /* Nanosecond resolution timestamps are stored in a format
       equivalent to 'struct timespec'.  This is the type used
       whenever possible but the Unix namespace rules do not allow the
       identifier 'timespec' to appear in the <sys/stat.h> header.
       Therefore we have to handle the use of this header in strictly
       standard-compliant sources special.  */
    struct timespec st_atim; /* Time of last access.  */
    struct timespec st_mtim; /* Time of last modification.  */
    struct timespec st_ctim; /* Time of last status change.  */
# 106 "/usr/include/bits/stat.h" 3 4
    __syscall_slong_t __unused[3];
# 115 "/usr/include/bits/stat.h" 3 4
  };


/* Note stat64 has the same shape as stat for x86-64.  */
struct stat64
  {
    __dev_t st_dev; /* Device.  */

    __ino64_t st_ino; /* File serial number.  */
    __nlink_t st_nlink; /* Link count.  */
    __mode_t st_mode; /* File mode.  */






    __uid_t st_uid; /* User ID of the file's owner.	*/
    __gid_t st_gid; /* Group ID of the file's group.*/

    int __pad0;
    __dev_t st_rdev; /* Device number, if device.  */
    __off_t st_size; /* Size of file, in bytes.  */





    __blksize_t st_blksize; /* Optimal block size for I/O.  */
    __blkcnt64_t st_blocks; /* Nr. 512-byte blocks allocated.  */

    /* Nanosecond resolution timestamps are stored in a format
       equivalent to 'struct timespec'.  This is the type used
       whenever possible but the Unix namespace rules do not allow the
       identifier 'timespec' to appear in the <sys/stat.h> header.
       Therefore we have to handle the use of this header in strictly
       standard-compliant sources special.  */
    struct timespec st_atim; /* Time of last access.  */
    struct timespec st_mtim; /* Time of last modification.  */
    struct timespec st_ctim; /* Time of last status change.  */
# 164 "/usr/include/bits/stat.h" 3 4
    __syscall_slong_t __unused[3];



  };


/* Tell code we have these members.  */


/* Nanosecond resolution time values are supported.  */


/* Encoding of the file mode.  */



/* File types.  */
# 190 "/usr/include/bits/stat.h" 3 4
/* POSIX.1b objects.  Note that these macros always evaluate to zero.  But
   they do it by enforcing the correct use of the macros.  */




/* Protection bits.  */
# 69 "/usr/include/fcntl.h" 2 3 4
# 85 "/usr/include/fcntl.h" 3 4
/* Protection bits.  */





/* Save swapped text after use (sticky bit).  This is pretty well obsolete.  */






/* Read, write, and execute by owner.  */





/* Read, write, and execute by group.  */





/* Read, write, and execute by others.  */





/* Values for the second argument to access.
   These may be OR'd together.  */







/* XPG wants the following symbols.   <stdio.h> has the same definitions.  */
# 149 "/usr/include/fcntl.h" 3 4
/* Do the file control operation described by CMD on FD.
   The remaining arguments are interpreted depending on CMD.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int fcntl (int __fd, int __cmd, ...);

/* Open FILE and return a new file descriptor for it, or -1 on error.
   OFLAG determines the type of access used.  If O_CREAT is on OFLAG,
   the third argument is taken as a `mode_t', the mode of the created file.

   This function is a cancellation point and therefore not marked with
   __THROW.  */

extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 173 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));



/* Similar to `open' but a relative path name is interpreted relative to
   the directory for which FD is a descriptor.

   NOTE: some other `openat' implementation support additional functionality
   through this interface, especially using the O_XATTR flag.  This is not
   yet supported here.

   This function is a cancellation point and therefore not marked with
   __THROW.  */

extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 198 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));



/* Create and open FILE, with mode MODE.  This takes an `int' MODE
   argument because that is what `mode_t' will be widened to.

   This function is a cancellation point and therefore not marked with
   __THROW.  */

extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 219 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));




/* NOTE: These declarations also appear in <unistd.h>; be sure to keep both
   files consistent.  Some systems have them there and some here, and some
   software depends on the macros being defined without including both.  */

/* `lockf' is a simpler interface to the locking facilities of `fcntl'.
   LEN is always relative to the current file position.
   The CMD argument is one of the following.  */







extern int lockf (int __fd, int __cmd, off_t __len);
# 247 "/usr/include/fcntl.h" 3 4
extern int lockf64 (int __fd, int __cmd, off64_t __len);




/* Advice the system about the expected behaviour of the application with
   respect to the file associated with FD.  */

extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 267 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ , __leaf__));



/* Reserve storage for the data of the file associated with FD.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 288 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);




/* Define some inlines helping to catch common problems.  */






# 25 "/usr/include/sys/file.h" 2 3 4





/* Alternate names for values for the WHENCE argument to `lseek'.
   These are the same as SEEK_SET, SEEK_CUR, and SEEK_END, respectively.  */







/* Operations for the `flock' call.  */




/* Can be OR'd in to one of the above.  */



/* Apply or remove an advisory lock, according to OPERATION,
   on the file FD refers to.  */
extern int flock (int __fd, int __operation) __attribute__ ((__nothrow__ , __leaf__));



# 121 "src/exim.h" 2
# 1 "/usr/include/dirent.h" 1 3 4
/* Copyright (C) 1991-2000,2003-2005,2009,2010,2011,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 5.1.2 Directory Operations	<dirent.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/dirent.h" 2 3 4



# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 31 "/usr/include/dirent.h" 2 3 4
# 47 "/usr/include/dirent.h" 3 4
/* This file defines `struct dirent'.

   It defines the macro `_DIRENT_HAVE_D_NAMLEN' iff there is a `d_namlen'
   member that gives the length of `d_name'.

   It defines the macro `_DIRENT_HAVE_D_RECLEN' iff there is a `d_reclen'
   member that gives the size of the entire directory entry.

   It defines the macro `_DIRENT_HAVE_D_OFF' iff there is a `d_off'
   member that gives the file offset of the next directory entry.

   It defines the macro `_DIRENT_HAVE_D_TYPE' iff there is a `d_type'
   member that gives the type of the file.
 */

# 1 "/usr/include/bits/dirent.h" 1 3 4
/* Copyright (C) 1996-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





struct dirent
  {

    __ino_t d_ino;
    __off_t d_off;




    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256]; /* We must not include limits.h! */
  };


struct dirent64
  {
    __ino64_t d_ino;
    __off64_t d_off;
    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256]; /* We must not include limits.h! */
  };
# 55 "/usr/include/bits/dirent.h" 3 4
/* Inform libc code that these two types are effectively identical.  */
# 63 "/usr/include/dirent.h" 2 3 4





/* These macros extract size information from a `struct dirent *'.
   They may evaluate their argument multiple times, so it must not
   have side effects.  Each of these may involve a relatively costly
   call to `strlen' on some systems, so these values should be cached.

   _D_EXACT_NAMLEN (DP)	returns the length of DP->d_name, not including
   its terminating null character.

   _D_ALLOC_NAMLEN (DP)	returns a size at least (_D_EXACT_NAMLEN (DP) + 1);
   that is, the allocation size needed to hold the DP->d_name string.
   Use this macro when you don't need the exact length, just an upper bound.
   This macro is less likely to require calling `strlen' than _D_EXACT_NAMLEN.
   */
# 97 "/usr/include/dirent.h" 3 4
/* File types for `d_type'.  */
enum
  {
    DT_UNKNOWN = 0,

    DT_FIFO = 1,

    DT_CHR = 2,

    DT_DIR = 4,

    DT_BLK = 6,

    DT_REG = 8,

    DT_LNK = 10,

    DT_SOCK = 12,

    DT_WHT = 14

  };

/* Convert between stat structure types and directory types.  */





/* This is the data type of directory stream objects.
   The actual structure is opaque to users.  */
typedef struct __dirstream DIR;

/* Open a directory stream on NAME.
   Return a DIR stream on the directory, or NULL if it could not be opened.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern DIR *opendir (const char *__name) __attribute__ ((__nonnull__ (1)));


/* Same as opendir, but open the stream on the file descriptor FD.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern DIR *fdopendir (int __fd);


/* Close the directory stream DIRP.
   Return 0 if successful, -1 if not.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int closedir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));

/* Read a directory entry from DIRP.  Return a pointer to a `struct
   dirent' describing the entry, or NULL for EOF or error.  The
   storage returned may be overwritten by a later readdir call on the
   same DIR stream.

   If the Large File Support API is selected we have to use the
   appropriate interface.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern struct dirent *readdir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 174 "/usr/include/dirent.h" 3 4
extern struct dirent64 *readdir64 (DIR *__dirp) __attribute__ ((__nonnull__ (1)));



/* Reentrant version of `readdir'.  Return in RESULT a pointer to the
   next entry.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int readdir_r (DIR *__restrict __dirp,
        struct dirent *__restrict __entry,
        struct dirent **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 201 "/usr/include/dirent.h" 3 4
extern int readdir64_r (DIR *__restrict __dirp,
   struct dirent64 *__restrict __entry,
   struct dirent64 **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3)));



/* Rewind DIRP to the beginning of the directory.  */
extern void rewinddir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 213 "/usr/include/dirent.h" 2 3 4

/* Seek to position POS on DIRP.  */
extern void seekdir (DIR *__dirp, long int __pos) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return the current position of DIRP.  */
extern long int telldir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Return the file descriptor used by DIRP.  */
extern int dirfd (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







/* Get the definitions of the POSIX.1 limits.  */
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
 *
 *	Never include this file directly; use <limits.h> instead.
 */
# 234 "/usr/include/dirent.h" 2 3 4

/* `MAXNAMLEN' is the BSD name for what POSIX calls `NAME_MAX'.  */
# 245 "/usr/include/dirent.h" 3 4
# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 246 "/usr/include/dirent.h" 2 3 4

/* Scan the directory DIR, calling SELECTOR on each directory entry.
   Entries for which SELECT returns nonzero are individually malloc'd,
   sorted using qsort with CMP, and collected in a malloc'd array in
   *NAMELIST.  Returns the number of entries selected, or -1 on error.

   This function is a cancellation point and therefore not marked with
   __THROW.  */

extern int scandir (const char *__restrict __dir,
      struct dirent ***__restrict __namelist,
      int (*__selector) (const struct dirent *),
      int (*__cmp) (const struct dirent **,
      const struct dirent **))
     __attribute__ ((__nonnull__ (1, 2)));
# 276 "/usr/include/dirent.h" 3 4
/* This function is like `scandir' but it uses the 64bit dirent structure.
   Please note that the CMP function must now work with struct dirent64 **.  */
extern int scandir64 (const char *__restrict __dir,
        struct dirent64 ***__restrict __namelist,
        int (*__selector) (const struct dirent64 *),
        int (*__cmp) (const struct dirent64 **,
        const struct dirent64 **))
     __attribute__ ((__nonnull__ (1, 2)));



/* Similar to `scandir' but a relative DIR name is interpreted relative
   to the directory for which DFD is a descriptor.

   This function is a cancellation point and therefore not marked with
   __THROW.  */

extern int scandirat (int __dfd, const char *__restrict __dir,
        struct dirent ***__restrict __namelist,
        int (*__selector) (const struct dirent *),
        int (*__cmp) (const struct dirent **,
        const struct dirent **))
     __attribute__ ((__nonnull__ (2, 3)));
# 313 "/usr/include/dirent.h" 3 4
/* This function is like `scandir' but it uses the 64bit dirent structure.
   Please note that the CMP function must now work with struct dirent64 **.  */
extern int scandirat64 (int __dfd, const char *__restrict __dir,
   struct dirent64 ***__restrict __namelist,
   int (*__selector) (const struct dirent64 *),
   int (*__cmp) (const struct dirent64 **,
          const struct dirent64 **))
     __attribute__ ((__nonnull__ (2, 3)));


/* Function to compare two `struct dirent's alphabetically.  */

extern int alphasort (const struct dirent **__e1,
        const struct dirent **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 340 "/usr/include/dirent.h" 3 4
extern int alphasort64 (const struct dirent64 **__e1,
   const struct dirent64 **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





/* Read directory entries from FD into BUF, reading at most NBYTES.
   Reading starts at offset *BASEP, and *BASEP is updated with the new
   position after reading.  Returns the number of bytes read; zero when at
   end of directory; or -1 for errors.  */

extern __ssize_t getdirentries (int __fd, char *__restrict __buf,
    size_t __nbytes,
    __off_t *__restrict __basep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));
# 370 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries64 (int __fd, char *__restrict __buf,
      size_t __nbytes,
      __off64_t *__restrict __basep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));




/* Function to compare two `struct dirent's by name & version.  */

extern int versionsort (const struct dirent **__e1,
   const struct dirent **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 396 "/usr/include/dirent.h" 3 4
extern int versionsort64 (const struct dirent64 **__e1,
     const struct dirent64 **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




# 122 "src/exim.h" 2
# 1 "/usr/include/netdb.h" 1 3 4
  /* Copyright (C) 1996-2004, 2009-2011, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* All data returned by the network data base library are supplied in
   host order and returned in network order (suitable for use in
   system calls).  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/netdb.h" 2 3 4

# 1 "/usr/include/netinet/in.h" 1 3 4
/* Copyright (C) 1991-2001, 2003, 2004, 2006, 2007, 2008, 2011, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/netinet/in.h" 2 3 4

# 1 "/usr/include/sys/socket.h" 1 3 4
/* Declarations of socket constants, types, and functions.
   Copyright (C) 1991,92,1994-2001,2003,2005,2007,2008,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 24 "/usr/include/sys/socket.h" 2 3 4



# 1 "/usr/include/sys/uio.h" 1 3 4
/* Copyright (C) 1991,1992,1996-1999,2003,2009,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/sys/uio.h" 2 3 4

# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 25 "/usr/include/sys/uio.h" 2 3 4



/* This file defines `struct iovec'.  */
# 1 "/usr/include/bits/uio.h" 1 3 4
/* Copyright (C) 1996, 1997, 2006, 2011, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 56 "/usr/include/bits/uio.h" 3 4


/* Read from another process' address space.  */
extern ssize_t process_vm_readv (pid_t __pid, const struct iovec *__lvec,
     unsigned long int __liovcnt,
     const struct iovec *__rvec,
     unsigned long int __riovcnt,
     unsigned long int __flags)
  __attribute__ ((__nothrow__ , __leaf__));

/* Write to another process' address space.  */
extern ssize_t process_vm_writev (pid_t __pid, const struct iovec *__lvec,
      unsigned long int __liovcnt,
      const struct iovec *__rvec,
      unsigned long int __riovcnt,
      unsigned long int __flags)
  __attribute__ ((__nothrow__ , __leaf__));


# 30 "/usr/include/sys/uio.h" 2 3 4


/* Read data from file descriptor FD, and put the result in the
   buffers described by IOVEC, which is a vector of COUNT 'struct iovec's.
   The buffers are filled in the order specified.
   Operates just like 'read' (see <unistd.h>) except that data are
   put in IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t readv (int __fd, const struct iovec *__iovec, int __count)
  ;

/* Write data pointed by the buffers described by IOVEC, which
   is a vector of COUNT 'struct iovec's, to file descriptor FD.
   The data is written in the order specified.
   Operates just like 'write' (see <unistd.h>) except that the data
   are taken from IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t writev (int __fd, const struct iovec *__iovec, int __count)
  ;




/* Read data from file descriptor FD at the given position OFFSET
   without change the file pointer, and put the result in the buffers
   described by IOVEC, which is a vector of COUNT 'struct iovec's.
   The buffers are filled in the order specified.  Operates just like
   'pread' (see <unistd.h>) except that data are put in IOVEC instead
   of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t preadv (int __fd, const struct iovec *__iovec, int __count,
         __off_t __offset) ;

/* Write data pointed by the buffers described by IOVEC, which is a
   vector of COUNT 'struct iovec's, to file descriptor FD at the given
   position OFFSET without change the file pointer.  The data is
   written in the order specified.  Operates just like 'pwrite' (see
   <unistd.h>) except that the data are taken from IOVEC instead of a
   contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pwritev (int __fd, const struct iovec *__iovec, int __count,
   __off_t __offset) ;
# 95 "/usr/include/sys/uio.h" 3 4
/* Read data from file descriptor FD at the given position OFFSET
   without change the file pointer, and put the result in the buffers
   described by IOVEC, which is a vector of COUNT 'struct iovec's.
   The buffers are filled in the order specified.  Operates just like
   'pread' (see <unistd.h>) except that data are put in IOVEC instead
   of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t preadv64 (int __fd, const struct iovec *__iovec, int __count,
    __off64_t __offset) ;

/* Write data pointed by the buffers described by IOVEC, which is a
   vector of COUNT 'struct iovec's, to file descriptor FD at the given
   position OFFSET without change the file pointer.  The data is
   written in the order specified.  Operates just like 'pwrite' (see
   <unistd.h>) except that the data are taken from IOVEC instead of a
   contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pwritev64 (int __fd, const struct iovec *__iovec, int __count,
     __off64_t __offset) ;




# 28 "/usr/include/sys/socket.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 30 "/usr/include/sys/socket.h" 2 3 4

/* Get the __sigset_t definition.  */
# 1 "/usr/include/bits/sigset.h" 1 3 4
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991, 1992, 1994, 1996, 1997, 2007, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 36 "/usr/include/bits/sigset.h" 3 4
/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */
# 33 "/usr/include/sys/socket.h" 2 3 4



/* This operating system-specific header file defines the SOCK_*, PF_*,
   AF_*, MSG_*, SOL_*, and SO_* constants, and the `struct sockaddr',
   `struct msghdr', and `struct linger' types.  */
# 1 "/usr/include/bits/socket.h" 1 3 4
/* System-specific socket constants and types.  Linux version.
   Copyright (C) 1991-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 28 "/usr/include/bits/socket.h" 2 3 4

# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 30 "/usr/include/bits/socket.h" 2 3 4

/* Type for length arguments in socket calls.  */

typedef __socklen_t socklen_t;



/* Get the architecture-dependent definition of enum __socket_type.  */
# 1 "/usr/include/bits/socket_type.h" 1 3 4
/* Define enum __socket_type for generic Linux.
   Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Types of sockets.  */
enum __socket_type
{
  SOCK_STREAM = 1, /* Sequenced, reliable, connection-based
				   byte streams.  */

  SOCK_DGRAM = 2, /* Connectionless, unreliable datagrams
				   of fixed maximum length.  */

  SOCK_RAW = 3, /* Raw protocol interface.  */

  SOCK_RDM = 4, /* Reliably-delivered messages.  */

  SOCK_SEQPACKET = 5, /* Sequenced, reliable, connection-based,
				   datagrams of fixed maximum length.  */

  SOCK_DCCP = 6, /* Datagram Congestion Control Protocol.  */

  SOCK_PACKET = 10, /* Linux specific way of getting packets
				   at the dev level.  For writing rarp and
				   other similar things on the user level. */


  /* Flags to be ORed into the type parameter of socket and socketpair and
     used for the flags parameter of paccept.  */

  SOCK_CLOEXEC = 02000000, /* Atomically set close-on-exec flag for the
				   new descriptor(s).  */

  SOCK_NONBLOCK = 00004000 /* Atomically mark descriptor(s) as
				   non-blocking.  */

};
# 39 "/usr/include/bits/socket.h" 2 3 4

/* Protocol families.  */
# 84 "/usr/include/bits/socket.h" 3 4
/* Address families.  */
# 128 "/usr/include/bits/socket.h" 3 4
/* Socket level values.  Others are defined in the appropriate headers.

   XXX These definitions also should go into the appropriate headers as
   far as they are available.  */
# 140 "/usr/include/bits/socket.h" 3 4
/* Maximum queue length specifiable by listen.  */


/* Get the definition of the macro to define the common sockaddr members.  */
# 1 "/usr/include/bits/sockaddr.h" 1 3 4
/* Definition of `struct sockaddr_*' common members.  Generic/4.2 BSD version.
   Copyright (C) 1995,1996,1997,1998,2000,2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/socket.h> instead.
 */





/* POSIX.1g specifies this type name for the `sa_family' member.  */
typedef unsigned short int sa_family_t;

/* This macro is used to declare the initial common members
   of the data types used for socket addresses, `struct sockaddr',
   `struct sockaddr_in', `struct sockaddr_un', etc.  */
# 145 "/usr/include/bits/socket.h" 2 3 4

/* Structure describing a generic socket address.  */
struct sockaddr
  {
    sa_family_t sa_family; /* Common data: address family and length.  */
    char sa_data[14]; /* Address data.  */
  };


/* Structure large enough to hold any socket address (with the historical
   exception of AF_UNIX).  We reserve 128 bytes.  */




struct sockaddr_storage
  {
    sa_family_t ss_family; /* Address family, etc.  */
    unsigned long int __ss_align; /* Force desired alignment.  */
    char __ss_padding[(128 - (2 * sizeof (unsigned long int)))];
  };


/* Bits in the FLAGS argument to `send', `recv', et al.  */
enum
  {
    MSG_OOB = 0x01, /* Process out-of-band data.  */

    MSG_PEEK = 0x02, /* Peek at incoming messages.  */

    MSG_DONTROUTE = 0x04, /* Don't use local routing.  */


    /* DECnet uses a different name.  */
    MSG_TRYHARD = MSG_DONTROUTE,


    MSG_CTRUNC = 0x08, /* Control data lost before delivery.  */

    MSG_PROXY = 0x10, /* Supply or ask second address.  */

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40, /* Nonblocking IO.  */

    MSG_EOR = 0x80, /* End of record.  */

    MSG_WAITALL = 0x100, /* Wait for a full request.  */

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800, /* Confirm path validity.  */

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000, /* Fetch message from error queue.  */

    MSG_NOSIGNAL = 0x4000, /* Do not generate SIGPIPE.  */

    MSG_MORE = 0x8000, /* Sender will send more.  */

    MSG_WAITFORONE = 0x10000, /* Wait for at least one packet to return.*/

    MSG_FASTOPEN = 0x20000000, /* Send data in TCP SYN.  */


    MSG_CMSG_CLOEXEC = 0x40000000 /* Set close_on_exit for file
					   descriptor received through
					   SCM_RIGHTS.  */

  };


/* Structure describing messages sent by
   `sendmsg' and received by `recvmsg'.  */
struct msghdr
  {
    void *msg_name; /* Address to send to/receive from.  */
    socklen_t msg_namelen; /* Length of address data.  */

    struct iovec *msg_iov; /* Vector of data to send/receive into.  */
    size_t msg_iovlen; /* Number of elements in the vector.  */

    void *msg_control; /* Ancillary data (eg BSD filedesc passing). */
    size_t msg_controllen; /* Ancillary data buffer length.
				   !! The type should be socklen_t but the
				   definition of the kernel is incompatible
				   with this.  */

    int msg_flags; /* Flags on received message.  */
  };

/* Structure used for storage of ancillary data object information.  */
struct cmsghdr
  {
    size_t cmsg_len; /* Length of data in cmsg_data plus length
				   of cmsghdr structure.
				   !! The type should be socklen_t but the
				   definition of the kernel is incompatible
				   with this.  */
    int cmsg_level; /* Originating protocol.  */
    int cmsg_type; /* Protocol specific type.  */



  };

/* Ancillary data object manipulation macros.  */
# 270 "/usr/include/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) __attribute__ ((__nothrow__ , __leaf__));
# 295 "/usr/include/bits/socket.h" 3 4
/* Socket level message types.  This must match the definitions in
   <linux/socket.h>.  */
enum
  {
    SCM_RIGHTS = 0x01 /* Transfer file descriptors.  */


    , SCM_CREDENTIALS = 0x02 /* Credentials passing.  */


  };


/* User visible structure for SCM_CREDENTIALS message */
struct ucred
{
  pid_t pid; /* PID of sending process.  */
  uid_t uid; /* UID of sending process.  */
  gid_t gid; /* GID of sending process.  */
};


/* Ugly workaround for unclean kernel headers.  */
# 342 "/usr/include/bits/socket.h" 3 4
/* Get socket manipulation related informations from kernel headers.  */
# 1 "/usr/include/asm/socket.h" 1 3 4
# 1 "/usr/include/asm-generic/socket.h" 1 3 4



# 1 "/usr/include/asm/sockios.h" 1 3 4
# 1 "/usr/include/asm-generic/sockios.h" 1 3 4



/* Socket-level I/O control calls. */
# 1 "/usr/include/asm/sockios.h" 2 3 4
# 5 "/usr/include/asm-generic/socket.h" 2 3 4

/* For setsockopt(2) */
# 25 "/usr/include/asm-generic/socket.h" 3 4
/* To add :#define SO_REUSEPORT 15 */
# 36 "/usr/include/asm-generic/socket.h" 3 4
/* Security levels - as per NRL IPv6 - don't actually do anything */






/* Socket filtering */
# 73 "/usr/include/asm-generic/socket.h" 3 4
/* Instruct lower device to use last 4-bytes of skb data as FCS */
# 1 "/usr/include/asm/socket.h" 2 3 4
# 344 "/usr/include/bits/socket.h" 2 3 4
# 376 "/usr/include/bits/socket.h" 3 4
/* Structure used to manipulate the SO_LINGER option.  */
struct linger
  {
    int l_onoff; /* Nonzero to linger on close.  */
    int l_linger; /* Time to linger.  */
  };
# 40 "/usr/include/sys/socket.h" 2 3 4


/* This is the 4.3 BSD `struct sockaddr' format, which is used as wire
   format in the grotty old 4.3 `talk' protocol.  */
struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };


/* The following constants should be used for the second parameter of
   `shutdown'.  */
enum
{
  SHUT_RD = 0, /* No more receptions.  */

  SHUT_WR, /* No more transmissions.  */

  SHUT_RDWR /* No more receptions or transmissions.  */

};

/* This is the type we use for generic socket address arguments.

   With GCC 2.7 and later, the funky union causes redeclarations or
   uses with any of the listed types to be allowed without complaint.
   G++ 2.7 does not support transparent unions so there we want the
   old-style declaration, too.  */




/* Add more `struct sockaddr_AF' types here as necessary.
   These are all the ones I found on NetBSD and Linux.  */
# 91 "/usr/include/sys/socket.h" 3 4
typedef union { struct sockaddr *__restrict __sockaddr__; struct sockaddr_at *__restrict __sockaddr_at__; struct sockaddr_ax25 *__restrict __sockaddr_ax25__; struct sockaddr_dl *__restrict __sockaddr_dl__; struct sockaddr_eon *__restrict __sockaddr_eon__; struct sockaddr_in *__restrict __sockaddr_in__; struct sockaddr_in6 *__restrict __sockaddr_in6__; struct sockaddr_inarp *__restrict __sockaddr_inarp__; struct sockaddr_ipx *__restrict __sockaddr_ipx__; struct sockaddr_iso *__restrict __sockaddr_iso__; struct sockaddr_ns *__restrict __sockaddr_ns__; struct sockaddr_un *__restrict __sockaddr_un__; struct sockaddr_x25 *__restrict __sockaddr_x25__;
       } __SOCKADDR_ARG __attribute__ ((__transparent_union__));


typedef union { const struct sockaddr *__restrict __sockaddr__; const struct sockaddr_at *__restrict __sockaddr_at__; const struct sockaddr_ax25 *__restrict __sockaddr_ax25__; const struct sockaddr_dl *__restrict __sockaddr_dl__; const struct sockaddr_eon *__restrict __sockaddr_eon__; const struct sockaddr_in *__restrict __sockaddr_in__; const struct sockaddr_in6 *__restrict __sockaddr_in6__; const struct sockaddr_inarp *__restrict __sockaddr_inarp__; const struct sockaddr_ipx *__restrict __sockaddr_ipx__; const struct sockaddr_iso *__restrict __sockaddr_iso__; const struct sockaddr_ns *__restrict __sockaddr_ns__; const struct sockaddr_un *__restrict __sockaddr_un__; const struct sockaddr_x25 *__restrict __sockaddr_x25__;
       } __CONST_SOCKADDR_ARG __attribute__ ((__transparent_union__));




/* For `recvmmsg' and `sendmmsg'.  */
struct mmsghdr
  {
    struct msghdr msg_hdr; /* Actual message header.  */
    unsigned int msg_len; /* Number of received or sent bytes for the
				   entry.  */
  };



/* Create a new socket of type TYPE in domain DOMAIN, using
   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.
   Returns a file descriptor for the new socket, or -1 for errors.  */
extern int socket (int __domain, int __type, int __protocol) __attribute__ ((__nothrow__ , __leaf__));

/* Create two new sockets, of type TYPE in domain DOMAIN and using
   protocol PROTOCOL, which are connected to each other, and put file
   descriptors for them in FDS[0] and FDS[1].  If PROTOCOL is zero,
   one will be chosen automatically.  Returns 0 on success, -1 for errors.  */
extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) __attribute__ ((__nothrow__ , __leaf__));

/* Give the socket FD the local address ADDR (which is LEN bytes long).  */
extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));

/* Put the local address of FD into *ADDR and its length in *LEN.  */
extern int getsockname (int __fd, __SOCKADDR_ARG __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));

/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
   For connectionless socket types, just set the default address to send to
   and the only address from which to accept transmissions.
   Return 0 on success, -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int connect (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len);

/* Put the address of the peer connected to socket FD into *ADDR
   (which is *LEN bytes long), and its actual length into *LEN.  */
extern int getpeername (int __fd, __SOCKADDR_ARG __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));


/* Send N bytes of BUF to socket FD.  Returns the number sent or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);

/* Read N bytes into BUF from socket FD.
   Returns the number read or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);

/* Send N bytes of BUF on socket FD to peer at address ADDR (which is
   ADDR_LEN bytes long).  Returns the number sent, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
         int __flags, __CONST_SOCKADDR_ARG __addr,
         socklen_t __addr_len);

/* Read N bytes into BUF through socket FD.
   If ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of
   the sender, and store the actual size of the address in *ADDR_LEN.
   Returns the number of bytes read or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, __SOCKADDR_ARG __addr,
    socklen_t *__restrict __addr_len);


/* Send a message described MESSAGE on socket FD.
   Returns the number of bytes sent, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
   int __flags);


/* Send a VLEN messages as described by VMESSAGES to socket FD.
   Returns the number of datagrams successfully written or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sendmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags);


/* Receive a message as described by MESSAGE from socket FD.
   Returns the number of bytes read or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);


/* Receive up to VLEN messages as described by VMESSAGES from socket FD.
   Returns the number of bytes read or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int recvmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags,
       const struct timespec *__tmo);



/* Put the current value for socket FD's option OPTNAME at protocol level LEVEL
   into OPTVAL (which is *OPTLEN bytes long), and set *OPTLEN to the value's
   actual length.  Returns 0 on success, -1 for errors.  */
extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) __attribute__ ((__nothrow__ , __leaf__));

/* Set socket FD's option OPTNAME at protocol level LEVEL
   to *OPTVAL (which is OPTLEN bytes long).
   Returns 0 on success, -1 for errors.  */
extern int setsockopt (int __fd, int __level, int __optname,
         const void *__optval, socklen_t __optlen) __attribute__ ((__nothrow__ , __leaf__));


/* Prepare to accept connections on socket FD.
   N connection requests will be queued before further requests are refused.
   Returns 0 on success, -1 for errors.  */
extern int listen (int __fd, int __n) __attribute__ ((__nothrow__ , __leaf__));

/* Await a connection on socket FD.
   When a connection arrives, open a new socket to communicate with it,
   set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting
   peer and *ADDR_LEN to the address's actual length, and return the
   new socket's descriptor, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int accept (int __fd, __SOCKADDR_ARG __addr,
     socklen_t *__restrict __addr_len);


/* Similar to 'accept' but takes an additional parameter to specify flags.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int accept4 (int __fd, __SOCKADDR_ARG __addr,
      socklen_t *__restrict __addr_len, int __flags);


/* Shut down all or part of the connection open on socket FD.
   HOW determines what to shut down:
     SHUT_RD   = No more receptions;
     SHUT_WR   = No more transmissions;
     SHUT_RDWR = No more receptions or transmissions.
   Returns 0 on success, -1 for errors.  */
extern int shutdown (int __fd, int __how) __attribute__ ((__nothrow__ , __leaf__));



/* Determine wheter socket is at a out-of-band mark.  */
extern int sockatmark (int __fd) __attribute__ ((__nothrow__ , __leaf__));




/* FDTYPE is S_IFSOCK or another S_IF* macro defined in <sys/stat.h>;
   returns 1 if FD is open on an object of the indicated type, 0 if not,
   or -1 for errors (setting errno).  */
extern int isfdtype (int __fd, int __fdtype) __attribute__ ((__nothrow__ , __leaf__));



/* Define some macros helping to catch buffer overflows.  */





# 25 "/usr/include/netinet/in.h" 2 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 26 "/usr/include/netinet/in.h" 2 3 4




/* Standard well-defined IP protocols.  */
enum
  {
    IPPROTO_IP = 0, /* Dummy protocol for TCP.  */

    IPPROTO_HOPOPTS = 0, /* IPv6 Hop-by-Hop options.  */

    IPPROTO_ICMP = 1, /* Internet Control Message Protocol.  */

    IPPROTO_IGMP = 2, /* Internet Group Management Protocol. */

    IPPROTO_IPIP = 4, /* IPIP tunnels (older KA9Q tunnels use 94).  */

    IPPROTO_TCP = 6, /* Transmission Control Protocol.  */

    IPPROTO_EGP = 8, /* Exterior Gateway Protocol.  */

    IPPROTO_PUP = 12, /* PUP protocol.  */

    IPPROTO_UDP = 17, /* User Datagram Protocol.  */

    IPPROTO_IDP = 22, /* XNS IDP protocol.  */

    IPPROTO_TP = 29, /* SO Transport Protocol Class 4.  */

    IPPROTO_DCCP = 33, /* Datagram Congestion Control Protocol.  */

    IPPROTO_IPV6 = 41, /* IPv6 header.  */

    IPPROTO_ROUTING = 43, /* IPv6 routing header.  */

    IPPROTO_FRAGMENT = 44, /* IPv6 fragmentation header.  */

    IPPROTO_RSVP = 46, /* Reservation Protocol.  */

    IPPROTO_GRE = 47, /* General Routing Encapsulation.  */

    IPPROTO_ESP = 50, /* encapsulating security payload.  */

    IPPROTO_AH = 51, /* authentication header.  */

    IPPROTO_ICMPV6 = 58, /* ICMPv6.  */

    IPPROTO_NONE = 59, /* IPv6 no next header.  */

    IPPROTO_DSTOPTS = 60, /* IPv6 destination options.  */

    IPPROTO_MTP = 92, /* Multicast Transport Protocol.  */

    IPPROTO_ENCAP = 98, /* Encapsulation Header.  */

    IPPROTO_PIM = 103, /* Protocol Independent Multicast.  */

    IPPROTO_COMP = 108, /* Compression Header Protocol.  */

    IPPROTO_SCTP = 132, /* Stream Control Transmission Protocol.  */

    IPPROTO_UDPLITE = 136, /* UDP-Lite protocol.  */

    IPPROTO_RAW = 255, /* Raw IP packets.  */

    IPPROTO_MAX
  };


/* Type to represent a port.  */
typedef uint16_t in_port_t;

/* Standard well-known ports.  */
enum
  {
    IPPORT_ECHO = 7, /* Echo service.  */
    IPPORT_DISCARD = 9, /* Discard transmissions service.  */
    IPPORT_SYSTAT = 11, /* System status service.  */
    IPPORT_DAYTIME = 13, /* Time of day service.  */
    IPPORT_NETSTAT = 15, /* Network status service.  */
    IPPORT_FTP = 21, /* File Transfer Protocol.  */
    IPPORT_TELNET = 23, /* Telnet protocol.  */
    IPPORT_SMTP = 25, /* Simple Mail Transfer Protocol.  */
    IPPORT_TIMESERVER = 37, /* Timeserver service.  */
    IPPORT_NAMESERVER = 42, /* Domain Name Service.  */
    IPPORT_WHOIS = 43, /* Internet Whois service.  */
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69, /* Trivial File Transfer Protocol.  */
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79, /* Finger service.  */
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95, /* SUPDUP protocol.  */


    IPPORT_EXECSERVER = 512, /* execd service.  */
    IPPORT_LOGINSERVER = 513, /* rlogind service.  */
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,

    /* UDP ports.  */
    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,

    /* Ports less than this value are reserved for privileged processes.  */
    IPPORT_RESERVED = 1024,

    /* Ports greater this value are reserved for (non-privileged) servers.  */
    IPPORT_USERRESERVED = 5000
  };


/* Internet address.  */
typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };


/* Definitions of the bits in an Internet address integer.

   On subnets, host and network parts are found according to
   the subnet mask, not these masks.  */
# 175 "/usr/include/netinet/in.h" 3 4
/* Address to accept any incoming messages.  */

/* Address to send to all hosts.  */

/* Address indicating an error return.  */


/* Network number for local host loopback.  */

/* Address to loopback in software to local host.  */




/* Defines for Multicast INADDR.  */






/* IPv6 address */
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];

 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];

      } __in6_u;





  };

extern const struct in6_addr in6addr_any; /* :: */
extern const struct in6_addr in6addr_loopback; /* ::1 */







/* Structure describing an Internet socket address.  */
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port; /* Port number.  */
    struct in_addr sin_addr; /* Internet address.  */

    /* Pad to size of `struct sockaddr'.  */
    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };

/* Ditto, for IPv6.  */
struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port; /* Transport layer port # */
    uint32_t sin6_flowinfo; /* IPv6 flow information */
    struct in6_addr sin6_addr; /* IPv6 address */
    uint32_t sin6_scope_id; /* IPv6 scope-id */
  };



/* IPv4 multicast request.  */
struct ip_mreq
  {
    /* IP multicast address of group.  */
    struct in_addr imr_multiaddr;

    /* Local IP address of interface.  */
    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {
    /* IP multicast address of group.  */
    struct in_addr imr_multiaddr;

    /* IP address of source.  */
    struct in_addr imr_interface;

    /* IP address of interface.  */
    struct in_addr imr_sourceaddr;
  };



/* Likewise, for IPv6.  */
struct ipv6_mreq
  {
    /* IPv6 multicast address of group */
    struct in6_addr ipv6mr_multiaddr;

    /* local interface */
    unsigned int ipv6mr_interface;
  };



/* Multicast group request.  */
struct group_req
  {
    /* Interface index.  */
    uint32_t gr_interface;

    /* Group address.  */
    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {
    /* Interface index.  */
    uint32_t gsr_interface;

    /* Group address.  */
    struct sockaddr_storage gsr_group;

    /* Source address.  */
    struct sockaddr_storage gsr_source;
  };


/* Full-state filter operations.  */
struct ip_msfilter
  {
    /* IP multicast address of group.  */
    struct in_addr imsf_multiaddr;

    /* Local IP address of interface.  */
    struct in_addr imsf_interface;

    /* Filter mode.  */
    uint32_t imsf_fmode;

    /* Number of source addresses.  */
    uint32_t imsf_numsrc;
    /* Source addresses.  */
    struct in_addr imsf_slist[1];
  };





struct group_filter
  {
    /* Interface index.  */
    uint32_t gf_interface;

    /* Group address.  */
    struct sockaddr_storage gf_group;

    /* Filter mode.  */
    uint32_t gf_fmode;

    /* Number of source addresses.  */
    uint32_t gf_numsrc;
    /* Source addresses.  */
    struct sockaddr_storage gf_slist[1];
};
# 354 "/usr/include/netinet/in.h" 3 4
/* Get system-specific definitions.  */
# 1 "/usr/include/bits/in.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* Linux version.  */





/* Options for use with `getsockopt' and `setsockopt' at the IP level.
   The first word in the comment at the right is the data type used;
   "bool" means a boolean value stored in an `int'.  */





/* For BSD compatibility.  */
# 76 "/usr/include/bits/in.h" 3 4
/* TProxy original addresses */






/* IP_MTU_DISCOVER arguments.  */





/* To select the IP level.  */







/* Structure used to describe IP options for IP_OPTIONS and IP_RETOPTS.
   The `ip_dst' field is used for the first-hop gateway when using a
   source route (this gets put into the header proper).  */
struct ip_opts
  {
    struct in_addr ip_dst; /* First hop; zero without source route.  */
    char ip_opts[40]; /* Actually variable in size.  */
  };

/* Like `struct ip_mreq' but including interface specification by index.  */
struct ip_mreqn
  {
    struct in_addr imr_multiaddr; /* IP multicast address of group */
    struct in_addr imr_address; /* local IP address of interface */
    int imr_ifindex; /* Interface index */
  };

/* Structure used for IP_PKTINFO.  */
struct in_pktinfo
  {
    int ipi_ifindex; /* Interface index  */
    struct in_addr ipi_spec_dst; /* Routing destination address  */
    struct in_addr ipi_addr; /* Header destination address  */
  };


/* Options for use with `getsockopt' and `setsockopt' at the IPv6 level.
   The first word in the comment at the right is the data type used;
   "bool" means a boolean value stored in an `int'.  */
# 170 "/usr/include/bits/in.h" 3 4
/* Obsolete synonyms for the above.  */





/* IPV6_MTU_DISCOVER values.  */





/* Socket level values for IPv6.  */



/* Routing header options for IPv6.  */
# 356 "/usr/include/netinet/in.h" 2 3 4

/* Functions to convert between host and network byte order.

   Please note that these functions normally take `unsigned long int' or
   `unsigned short int' values as arguments and also return them.  But
   this was a short-sighted decision since on different systems the types
   may have different representations but the values are always the same.  */

extern uint32_t ntohl (uint32_t __netlong) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 373 "/usr/include/netinet/in.h" 2 3 4

/* Get machine dependent optimized versions of byte swapping functions.  */
# 1 "/usr/include/bits/byteswap.h" 1 3 4
/* Macros to swap the order of bytes in integer values.
   Copyright (C) 1997-2012   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 376 "/usr/include/netinet/in.h" 2 3 4
# 490 "/usr/include/netinet/in.h" 3 4
/* Bind socket to a privileged IP port.  */
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __attribute__ ((__nothrow__ , __leaf__));

/* The IPv6 version of this function.  */
extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     __attribute__ ((__nothrow__ , __leaf__));
# 521 "/usr/include/netinet/in.h" 3 4
struct cmsghdr; /* Forward declaration.  */

/* IPv6 packet information.  */
struct in6_pktinfo
  {
    struct in6_addr ipi6_addr; /* src/dst IPv6 address */
    unsigned int ipi6_ifindex; /* send/recv interface index */
  };

/* IPv6 MTU information.  */
struct ip6_mtuinfo
  {
    struct sockaddr_in6 ip6m_addr; /* dst address including zone ID */
    uint32_t ip6m_mtu; /* path MTU in host byte order */
  };


/* Obsolete hop-by-hop and Destination Options Processing (RFC 2292).  */
extern int inet6_option_space (int __nbytes)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_init (void *__bp, struct cmsghdr **__cmsgp,
         int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_append (struct cmsghdr *__cmsg,
    const uint8_t *__typep, int __multx,
    int __plusy) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern uint8_t *inet6_option_alloc (struct cmsghdr *__cmsg, int __datalen,
        int __multx, int __plusy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_next (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_find (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


/* Hop-by-Hop and Destination Options Processing (RFC 3542).  */
extern int inet6_opt_init (void *__extbuf, socklen_t __extlen) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_append (void *__extbuf, socklen_t __extlen, int __offset,
        uint8_t __type, socklen_t __len, uint8_t __align,
        void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_finish (void *__extbuf, socklen_t __extlen, int __offset)
     __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_set_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_next (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t *__typep, socklen_t *__lenp,
      void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_find (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t __type, socklen_t *__lenp,
      void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_get_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) __attribute__ ((__nothrow__ , __leaf__));


/* Routing Header Option (RFC 3542).  */
extern socklen_t inet6_rth_space (int __type, int __segments) __attribute__ ((__nothrow__ , __leaf__));
extern void *inet6_rth_init (void *__bp, socklen_t __bp_len, int __type,
        int __segments) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_add (void *__bp, const struct in6_addr *__addr) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_reverse (const void *__in, void *__out) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_segments (const void *__bp) __attribute__ ((__nothrow__ , __leaf__));
extern struct in6_addr *inet6_rth_getaddr (const void *__bp, int __index)
     __attribute__ ((__nothrow__ , __leaf__));


/* Multicast source filter support.  */

/* Get IPv4 source filter.  */
extern int getipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t *__fmode,
    uint32_t *__numsrc, struct in_addr *__slist)
     __attribute__ ((__nothrow__ , __leaf__));

/* Set IPv4 source filter.  */
extern int setipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t __fmode,
    uint32_t __numsrc,
    const struct in_addr *__slist)
     __attribute__ ((__nothrow__ , __leaf__));


/* Get source filter.  */
extern int getsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t *__fmode,
       uint32_t *__numsrc,
       struct sockaddr_storage *__slist) __attribute__ ((__nothrow__ , __leaf__));

/* Set source filter.  */
extern int setsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t __fmode,
       uint32_t __numsrc,
       const struct sockaddr_storage *__slist) __attribute__ ((__nothrow__ , __leaf__));



# 28 "/usr/include/netdb.h" 2 3 4


/* This is necessary to make this include file properly replace the
   Sun version.  */
# 1 "/usr/include/rpc/netdb.h" 1 3 4
/* @(#)netdb.h	2.1 88/07/29 3.9 RPCSRC */
/*
 * Copyright (c) 2010, Oracle America, Inc.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* Cleaned up for GNU C library roland@gnu.ai.mit.edu:
   added multiple inclusion protection and use of <sys/cdefs.h>.
   In GNU this file is #include'd by <netdb.h>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 40 "/usr/include/rpc/netdb.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 43 "/usr/include/rpc/netdb.h" 2 3 4



struct rpcent
{
  char *r_name; /* Name of server for this rpc program.  */
  char **r_aliases; /* Alias list.  */
  int r_number; /* RPC program number.  */
};

extern void setrpcent (int __stayopen) __attribute__ ((__nothrow__ , __leaf__));
extern void endrpcent (void) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcbyname (const char *__name) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcbynumber (int __number) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcent (void) __attribute__ ((__nothrow__ , __leaf__));


extern int getrpcbyname_r (const char *__name, struct rpcent *__result_buf,
      char *__buffer, size_t __buflen,
      struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
        char *__buffer, size_t __buflen,
        struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
   size_t __buflen, struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));



# 33 "/usr/include/netdb.h" 2 3 4




# 1 "/usr/include/bits/siginfo.h" 1 3 4
/* siginfo_t, sigevent and constants.  Linux x86-64 version.
   Copyright (C) 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 25 "/usr/include/bits/siginfo.h" 2 3 4
# 38 "/usr/include/netdb.h" 2 3 4

# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 40 "/usr/include/netdb.h" 2 3 4


# 1 "/usr/include/bits/netdb.h" 1 3 4
/* Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Description of data base entry for a single network.  NOTE: here a
   poor assumption is made.  The network number is expected to fit
   into an unsigned long int variable.  */
struct netent
{
  char *n_name; /* Official name of network.  */
  char **n_aliases; /* Alias list.  */
  int n_addrtype; /* Net address type.  */
  uint32_t n_net; /* Network number.  */
};
# 43 "/usr/include/netdb.h" 2 3 4

/* Absolute file name for network data base files.  */
# 53 "/usr/include/netdb.h" 3 4



/* Error status for non-reentrant lookup functions.
   We use a macro to access always the thread-specific `h_errno' variable.  */


/* Function to get address of global `h_errno' variable.  */
extern int *__h_errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Possible values left in `h_errno'.  */
# 80 "/usr/include/netdb.h" 3 4
/* Highest reserved Internet port number.  */




/* Scope delimiter for getaddrinfo(), getnameinfo().  */




/* Print error indicated by `h_errno' variable on standard error.  STR
   if non-null is printed before the error string.  */
extern void herror (const char *__str) __attribute__ ((__nothrow__ , __leaf__));

/* Return string associated with error ERR_NUM.  */
extern const char *hstrerror (int __err_num) __attribute__ ((__nothrow__ , __leaf__));



/* Description of data base entry for a single host.  */
struct hostent
{
  char *h_name; /* Official name of host.  */
  char **h_aliases; /* Alias list.  */
  int h_addrtype; /* Host address type.  */
  int h_length; /* Length of address.  */
  char **h_addr_list; /* List of addresses from name server.  */



};

/* Open host data base files and mark them as staying open even after
   a later search if STAY_OPEN is non-zero.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void sethostent (int __stay_open);

/* Close host data base files and clear `stay open' flag.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endhostent (void);

/* Get next entry from host data base file.  Open data base if
   necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct hostent *gethostent (void);

/* Return entry from host data base which address match ADDR with
   length LEN and type TYPE.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct hostent *gethostbyaddr (const void *__addr, __socklen_t __len,
          int __type);

/* Return entry from host data base for host with NAME.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct hostent *gethostbyname (const char *__name);


/* Return entry from host data base for host with NAME.  AF must be
   set to the address type which is `AF_INET' for IPv4 or `AF_INET6'
   for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern struct hostent *gethostbyname2 (const char *__name, int __af);

/* Reentrant versions of the functions above.  The additional
   arguments specify a buffer of BUFLEN starting at BUF.  The last
   argument is a pointer to a variable which gets the value which
   would be stored in the global variable `herrno' by the
   non-reentrant functions.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int gethostent_r (struct hostent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct hostent **__restrict __result,
    int *__restrict __h_errnop);

extern int gethostbyaddr_r (const void *__restrict __addr, __socklen_t __len,
       int __type,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname_r (const char *__restrict __name,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname2_r (const char *__restrict __name, int __af,
        struct hostent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct hostent **__restrict __result,
        int *__restrict __h_errnop);



/* Open network data base files and mark them as staying open even
   after a later search if STAY_OPEN is non-zero.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void setnetent (int __stay_open);

/* Close network data base files and clear `stay open' flag.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endnetent (void);

/* Get next entry from network data base file.  Open data base if
   necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct netent *getnetent (void);

/* Return entry from network data base which address match NET and
   type TYPE.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct netent *getnetbyaddr (uint32_t __net, int __type);

/* Return entry from network data base for network with NAME.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct netent *getnetbyname (const char *__name);


/* Reentrant versions of the functions above.  The additional
   arguments specify a buffer of BUFLEN starting at BUF.  The last
   argument is a pointer to a variable which gets the value which
   would be stored in the global variable `herrno' by the
   non-reentrant functions.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int getnetent_r (struct netent *__restrict __result_buf,
   char *__restrict __buf, size_t __buflen,
   struct netent **__restrict __result,
   int *__restrict __h_errnop);

extern int getnetbyaddr_r (uint32_t __net, int __type,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);

extern int getnetbyname_r (const char *__restrict __name,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);



/* Description of data base entry for a single service.  */
struct servent
{
  char *s_name; /* Official service name.  */
  char **s_aliases; /* Alias list.  */
  int s_port; /* Port number.  */
  char *s_proto; /* Protocol to use.  */
};

/* Open service data base files and mark them as staying open even
   after a later search if STAY_OPEN is non-zero.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void setservent (int __stay_open);

/* Close service data base files and clear `stay open' flag.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endservent (void);

/* Get next entry from service data base file.  Open data base if
   necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct servent *getservent (void);

/* Return entry from network data base for network with NAME and
   protocol PROTO.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct servent *getservbyname (const char *__name, const char *__proto);

/* Return entry from service data base which matches port PORT and
   protocol PROTO.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct servent *getservbyport (int __port, const char *__proto);



/* Reentrant versions of the functions above.  The additional
   arguments specify a buffer of BUFLEN starting at BUF.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int getservent_r (struct servent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct servent **__restrict __result);

extern int getservbyname_r (const char *__restrict __name,
       const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);

extern int getservbyport_r (int __port, const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);



/* Description of data base entry for a single service.  */
struct protoent
{
  char *p_name; /* Official protocol name.  */
  char **p_aliases; /* Alias list.  */
  int p_proto; /* Protocol number.  */
};

/* Open protocol data base files and mark them as staying open even
   after a later search if STAY_OPEN is non-zero.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void setprotoent (int __stay_open);

/* Close protocol data base files and clear `stay open' flag.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endprotoent (void);

/* Get next entry from protocol data base file.  Open data base if
   necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct protoent *getprotoent (void);

/* Return entry from protocol data base for network with NAME.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct protoent *getprotobyname (const char *__name);

/* Return entry from protocol data base which number is PROTO.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct protoent *getprotobynumber (int __proto);



/* Reentrant versions of the functions above.  The additional
   arguments specify a buffer of BUFLEN starting at BUF.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int getprotoent_r (struct protoent *__restrict __result_buf,
     char *__restrict __buf, size_t __buflen,
     struct protoent **__restrict __result);

extern int getprotobyname_r (const char *__restrict __name,
        struct protoent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct protoent **__restrict __result);

extern int getprotobynumber_r (int __proto,
          struct protoent *__restrict __result_buf,
          char *__restrict __buf, size_t __buflen,
          struct protoent **__restrict __result);


/* Establish network group NETGROUP for enumeration.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int setnetgrent (const char *__netgroup);

/* Free all space allocated by previous `setnetgrent' call.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern void endnetgrent (void);

/* Get next member of netgroup established by last `setnetgrent' call
   and return pointers to elements in HOSTP, USERP, and DOMAINP.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getnetgrent (char **__restrict __hostp,
   char **__restrict __userp,
   char **__restrict __domainp);


/* Test whether NETGROUP contains the triple (HOST,USER,DOMAIN).

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int innetgr (const char *__netgroup, const char *__host,
      const char *__user, const char *__domain);

/* Reentrant version of `getnetgrent' where result is placed in BUFFER.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getnetgrent_r (char **__restrict __hostp,
     char **__restrict __userp,
     char **__restrict __domainp,
     char *__restrict __buffer, size_t __buflen);




/* Call `rshd' at port RPORT on remote machine *AHOST to execute CMD.
   The local user is LOCUSER, on the remote machine the command is
   executed as REMUSER.  In *FD2P the descriptor to the socket for the
   connection is returned.  The caller must have the right to use a
   reserved port.  When the function returns *AHOST contains the
   official host name.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
   const char *__restrict __locuser,
   const char *__restrict __remuser,
   const char *__restrict __cmd, int *__restrict __fd2p);

/* This is the equivalent function where the protocol can be selected
   and which therefore can be used for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
      const char *__restrict __locuser,
      const char *__restrict __remuser,
      const char *__restrict __cmd, int *__restrict __fd2p,
      sa_family_t __af);

/* Call `rexecd' at port RPORT on remote machine *AHOST to execute
   CMD.  The process runs at the remote machine using the ID of user
   NAME whose cleartext password is PASSWD.  In *FD2P the descriptor
   to the socket for the connection is returned.  When the function
   returns *AHOST contains the official host name.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rexec (char **__restrict __ahost, int __rport,
    const char *__restrict __name,
    const char *__restrict __pass,
    const char *__restrict __cmd, int *__restrict __fd2p);

/* This is the equivalent function where the protocol can be selected
   and which therefore can be used for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rexec_af (char **__restrict __ahost, int __rport,
       const char *__restrict __name,
       const char *__restrict __pass,
       const char *__restrict __cmd, int *__restrict __fd2p,
       sa_family_t __af);

/* Check whether user REMUSER on system RHOST is allowed to login as LOCUSER.
   If SUSER is not zero the user tries to become superuser.  Return 0 if
   it is possible.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int ruserok (const char *__rhost, int __suser,
      const char *__remuser, const char *__locuser);

/* This is the equivalent function where the protocol can be selected
   and which therefore can be used for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int ruserok_af (const char *__rhost, int __suser,
         const char *__remuser, const char *__locuser,
         sa_family_t __af);

/* Check whether user REMUSER on system indicated by IPv4 address
   RADDR is allowed to login as LOCUSER.  Non-IPv4 (e.g., IPv6) are
   not supported.  If SUSER is not zero the user tries to become
   superuser.  Return 0 if it is possible.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int iruserok (uint32_t __raddr, int __suser,
       const char *__remuser, const char *__locuser);

/* This is the equivalent function where the pfamiliy if the address
   pointed to by RADDR is determined by the value of AF.  It therefore
   can be used for IPv6

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int iruserok_af (const void *__raddr, int __suser,
   const char *__remuser, const char *__locuser,
   sa_family_t __af);

/* Try to allocate reserved port, returning a descriptor for a socket opened
   at this port or -1 if unsuccessful.  The search for an available port
   will start at ALPORT and continues with lower numbers.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rresvport (int *__alport);

/* This is the equivalent function where the protocol can be selected
   and which therefore can be used for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rresvport_af (int *__alport, sa_family_t __af);



/* Extension from POSIX.1g.  */

/* Structure to contain information about address of a service provider.  */
struct addrinfo
{
  int ai_flags; /* Input flags.  */
  int ai_family; /* Protocol family for socket.  */
  int ai_socktype; /* Socket type.  */
  int ai_protocol; /* Protocol for socket.  */
  socklen_t ai_addrlen; /* Length of socket address.  */
  struct sockaddr *ai_addr; /* Socket address for socket.  */
  char *ai_canonname; /* Canonical name for service location.  */
  struct addrinfo *ai_next; /* Pointer to next in list.  */
};


/* Structure used as control block for asynchronous lookup.  */
struct gaicb
{
  const char *ar_name; /* Name to look up.  */
  const char *ar_service; /* Service name.  */
  const struct addrinfo *ar_request; /* Additional request specification.  */
  struct addrinfo *ar_result; /* Pointer to result.  */
  /* The following are internal elements.  */
  int __return;
  int __unused[5];
};

/* Lookup mode.  */




/* Possible values for `ai_flags' field in `addrinfo' structure.  */
# 617 "/usr/include/netdb.h" 3 4
/* Error values for `getaddrinfo' function.  */
# 657 "/usr/include/netdb.h" 3 4
/* Translate name of a service location and/or a service name to set of
   socket addresses.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getaddrinfo (const char *__restrict __name,
   const char *__restrict __service,
   const struct addrinfo *__restrict __req,
   struct addrinfo **__restrict __pai);

/* Free `addrinfo' structure AI including associated storage.  */
extern void freeaddrinfo (struct addrinfo *__ai) __attribute__ ((__nothrow__ , __leaf__));

/* Convert error return from getaddrinfo() to a string.  */
extern const char *gai_strerror (int __ecode) __attribute__ ((__nothrow__ , __leaf__));

/* Translate a socket address to a location and service name.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getnameinfo (const struct sockaddr *__restrict __sa,
   socklen_t __salen, char *__restrict __host,
   socklen_t __hostlen, char *__restrict __serv,
   socklen_t __servlen, int __flags);



/* Enqueue ENT requests from the LIST.  If MODE is GAI_WAIT wait until all
   requests are handled.  If WAIT is GAI_NOWAIT return immediately after
   queueing the requests and signal completion according to SIG.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getaddrinfo_a (int __mode, struct gaicb *__list[__restrict],
     int __ent, struct sigevent *__restrict __sig);

/* Suspend execution of the thread until at least one of the ENT requests
   in LIST is handled.  If TIMEOUT is not a null pointer it specifies the
   longest time the function keeps waiting before returning with an error.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int gai_suspend (const struct gaicb *const __list[], int __ent,
   const struct timespec *__timeout);

/* Get the error status of the request REQ.  */
extern int gai_error (struct gaicb *__req) __attribute__ ((__nothrow__ , __leaf__));

/* Cancel the requests associated with GAICBP.  */
extern int gai_cancel (struct gaicb *__gaicbp) __attribute__ ((__nothrow__ , __leaf__));



# 123 "src/exim.h" 2

# 1 "/usr/include/poll.h" 1 3 4
# 1 "/usr/include/sys/poll.h" 1 3 4
/* Compatibility definitions for System V `poll' interface.
   Copyright (C) 1994,1996-2001,2004-2006,2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/sys/poll.h" 2 3 4

/* Get the platform dependent bits of `poll'.  */
# 1 "/usr/include/bits/poll.h" 1 3 4
/* Copyright (C) 1997, 2001, 2006, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Event types that can be polled for.  These bits may be set in `events'
   to indicate the interesting event types; they will appear in `revents'
   to indicate the status of the file descriptor.  */





/* These values are defined in XPG4.2.  */







/* These are extensions for Linux.  */





/* Event types always implicitly polled for.  These bits need not be set in
   `events', but they will appear in `revents' to indicate the status of
   the file descriptor.  */
# 26 "/usr/include/sys/poll.h" 2 3 4

/* Get the __sigset_t definition.  */
# 1 "/usr/include/bits/sigset.h" 1 3 4
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991, 1992, 1994, 1996, 1997, 2007, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 36 "/usr/include/bits/sigset.h" 3 4
/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */
# 29 "/usr/include/sys/poll.h" 2 3 4
/* Get the timespec definition.  */

# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 32 "/usr/include/sys/poll.h" 2 3 4



/* Type used for the number of file descriptors.  */
typedef unsigned long int nfds_t;

/* Data structure describing a polling request.  */
struct pollfd
  {
    int fd; /* File descriptor to poll.  */
    short int events; /* Types of events poller cares about.  */
    short int revents; /* Types of events that actually occurred.  */
  };




/* Poll the file descriptors described by the NFDS structures starting at
   FDS.  If TIMEOUT is nonzero and not -1, allow TIMEOUT milliseconds for
   an event to occur; if TIMEOUT is -1, block until an event occurs.
   Returns the number of file descriptors with events, zero if timed out,
   or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int poll (struct pollfd *__fds, nfds_t __nfds, int __timeout);


/* Like poll, but before waiting the threads signal mask is replaced
   with that specified in the fourth parameter.  For better usability,
   the timeout value is specified using a TIMESPEC object.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int ppoll (struct pollfd *__fds, nfds_t __nfds,
    const struct timespec *__timeout,
    const __sigset_t *__ss);





/* Define some inlines helping to catch common problems.  */
# 1 "/usr/include/poll.h" 2 3 4
# 125 "src/exim.h" 2

# 1 "/usr/include/pwd.h" 1 3 4
/* Copyright (C) 1991,1992,1995-2001,2003,2004,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 9.2.2 User Database Access	<pwd.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/pwd.h" 2 3 4



# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 31 "/usr/include/pwd.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 34 "/usr/include/pwd.h" 2 3 4


/* The Single Unix specification says that some more types are
   available here.  */
# 49 "/usr/include/pwd.h" 3 4
/* The passwd structure.  */
struct passwd
{
  char *pw_name; /* Username.  */
  char *pw_passwd; /* Password.  */
  __uid_t pw_uid; /* User ID.  */
  __gid_t pw_gid; /* Group ID.  */
  char *pw_gecos; /* Real name.  */
  char *pw_dir; /* Home directory.  */
  char *pw_shell; /* Shell program.  */
};




# 1 "/usr/include/stdio.h" 1 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991, 1994-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */
# 65 "/usr/include/pwd.h" 2 3 4




/* Rewind the password-file stream.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void setpwent (void);

/* Close the password-file stream.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endpwent (void);

/* Read an entry from the password-file stream, opening it if necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct passwd *getpwent (void);



/* Read an entry from STREAM.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern struct passwd *fgetpwent (FILE *__stream);

/* Write the given entry onto the given stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int putpwent (const struct passwd *__restrict __p,
       FILE *__restrict __f);


/* Search for an entry with a matching user ID.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct passwd *getpwuid (__uid_t __uid);

/* Search for an entry with a matching username.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct passwd *getpwnam (const char *__name);




/* Reasonable value for the buffer sized used in the reentrant
   functions below.  But better use `sysconf'.  */



/* Reentrant versions of some of the functions above.

   PLEASE NOTE: the `getpwent_r' function is not (yet) standardized.
   The interface may change in later versions of this library.  But
   the interface is designed following the principals used for the
   other reentrant functions so the chances are good this is what the
   POSIX people would choose.  */


/* This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getpwent_r (struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result);


extern int getpwuid_r (__uid_t __uid,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result);

extern int getpwnam_r (const char *__restrict __name,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result);



/* Read an entry from STREAM.  This function is not standardized and
   probably never will.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fgetpwent_r (FILE *__restrict __stream,
   struct passwd *__restrict __resultbuf,
   char *__restrict __buffer, size_t __buflen,
   struct passwd **__restrict __result);





/* Re-construct the password-file line for the given uid
   in the given buffer.  This knows the format that the caller
   will expect, but this need not be the format of the password file.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getpw (__uid_t __uid, char *__buffer);



# 127 "src/exim.h" 2
# 1 "/usr/include/grp.h" 1 3 4
/* Copyright (C) 1991,1992,1995-2001,2003,2004,2010,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 9.2.1 Group Database Access	<grp.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/grp.h" 2 3 4



# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 31 "/usr/include/grp.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 34 "/usr/include/grp.h" 2 3 4


/* For the Single Unix specification we must define this type here.  */





/* The group structure.	 */
struct group
  {
    char *gr_name; /* Group name.	*/
    char *gr_passwd; /* Password.	*/
    __gid_t gr_gid; /* Group ID.	*/
    char **gr_mem; /* Member list.	*/
  };




# 1 "/usr/include/stdio.h" 1 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991, 1994-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */
# 55 "/usr/include/grp.h" 2 3 4




/* Rewind the group-file stream.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void setgrent (void);




/* Close the group-file stream.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endgrent (void);

/* Read an entry from the group-file stream, opening it if necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct group *getgrent (void);



/* Read a group entry from STREAM.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern struct group *fgetgrent (FILE *__stream);



/* Write the given entry onto the given stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int putgrent (const struct group *__restrict __p,
       FILE *__restrict __f);


/* Search for an entry with a matching group ID.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct group *getgrgid (__gid_t __gid);

/* Search for an entry with a matching group name.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct group *getgrnam (const char *__name);




/* Reasonable value for the buffer sized used in the reentrant
   functions below.  But better use `sysconf'.  */



/* Reentrant versions of some of the functions above.

   PLEASE NOTE: the `getgrent_r' function is not (yet) standardized.
   The interface may change in later versions of this library.  But
   the interface is designed following the principals used for the
   other reentrant functions so the chances are good this is what the
   POSIX people would choose.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */


extern int getgrent_r (struct group *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct group **__restrict __result);


/* Search for an entry with a matching group ID.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getgrgid_r (__gid_t __gid, struct group *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct group **__restrict __result);

/* Search for an entry with a matching group name.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getgrnam_r (const char *__restrict __name,
         struct group *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct group **__restrict __result);


/* Read a group entry from STREAM.  This function is not standardized
   an probably never will.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fgetgrent_r (FILE *__restrict __stream,
   struct group *__restrict __resultbuf,
   char *__restrict __buffer, size_t __buflen,
   struct group **__restrict __result);
# 178 "/usr/include/grp.h" 3 4
# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 179 "/usr/include/grp.h" 2 3 4

/* Set the group set for the current user to GROUPS (N of them).  */
extern int setgroups (size_t __n, const __gid_t *__groups) __attribute__ ((__nothrow__ , __leaf__));

/* Store at most *NGROUPS members of the group set for USER into
   *GROUPS.  Also include GROUP.  The actual number of groups found is
   returned in *NGROUPS.  Return -1 if the if *NGROUPS is too small.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getgrouplist (const char *__user, __gid_t __group,
    __gid_t *__groups, int *__ngroups);

/* Initialize the group set for the current user
   by reading the group database and using all groups
   of which USER is a member.  Also include GROUP.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int initgroups (const char *__user, __gid_t __group);




# 128 "src/exim.h" 2
# 1 "/usr/include/syslog.h" 1 3 4
# 1 "/usr/include/sys/syslog.h" 1 3 4
/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)syslog.h	8.1 (Berkeley) 6/2/93
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 36 "/usr/include/sys/syslog.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdarg.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
# 38 "/usr/include/sys/syslog.h" 2 3 4

/* This file defines _PATH_LOG.  */
# 1 "/usr/include/bits/syslog-path.h" 1 3 4
/* <bits/syslog-path.h> -- _PATH_LOG definition
   Copyright (C) 2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 41 "/usr/include/sys/syslog.h" 2 3 4

/*
 * priorities/facilities are encoded into a single 32-bit quantity, where the
 * bottom 3 bits are the priority (0-7) and the top 28 bits are the facility
 * (0-big number).  Both the priorities and the facilities map roughly
 * one-to-one to strings in the syslogd(8) source code.  This mapping is
 * included in this file.
 *
 * priorities (these are ordered)
 */
# 61 "/usr/include/sys/syslog.h" 3 4
    /* extract priority */
# 92 "/usr/include/sys/syslog.h" 3 4
/* facility codes */
# 106 "/usr/include/sys/syslog.h" 3 4
 /* other codes through 15 reserved for system use */
# 118 "/usr/include/sys/syslog.h" 3 4
    /* facility of pri */
# 150 "/usr/include/sys/syslog.h" 3 4
/*
 * arguments to setlogmask.
 */



/*
 * Option flags for openlog.
 *
 * LOG_ODELAY no longer does anything.
 * LOG_NDELAY is the inverse of what it used to be.
 */









/* Close descriptor used to write to system logger.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void closelog (void);

/* Open connection to system logger.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void openlog (const char *__ident, int __option, int __facility);

/* Set the log mask level.  */
extern int setlogmask (int __mask) __attribute__ ((__nothrow__ , __leaf__));

/* Generate a log message using FMT string and option arguments.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void syslog (int __pri, const char *__fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));


/* Generate a log message using FMT and using arguments pointed to by AP.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern void vsyslog (int __pri, const char *__fmt, __gnuc_va_list __ap)
     __attribute__ ((__format__ (__printf__, 2, 0)));



/* Define some macros helping to catch buffer overflows.  */








# 1 "/usr/include/syslog.h" 2 3 4
# 129 "src/exim.h" 2

/* Not all systems have flock() available. Those that do must define LOCK_SH
in sys/file.h. */






# 1 "/usr/include/sysexits.h" 1 3 4
/*
 * Copyright (c) 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)sysexits.h	8.1 (Berkeley) 6/2/93
 */




/*
 *  SYSEXITS.H -- Exit status codes for system programs.
 *
 *	This include file attempts to categorize possible error
 *	exit statuses for system programs, notably delivermail
 *	and the Berkeley network.
 *
 *	Error numbers begin at EX__BASE to reduce the possibility of
 *	clashing with other exit statuses that random programs may
 *	already return.  The meaning of the codes is approximately
 *	as follows:
 *
 *	EX_USAGE -- The command was used incorrectly, e.g., with
 *		the wrong number of arguments, a bad flag, a bad
 *		syntax in a parameter, or whatever.
 *	EX_DATAERR -- The input data was incorrect in some way.
 *		This should only be used for user's data & not
 *		system files.
 *	EX_NOINPUT -- An input file (not a system file) did not
 *		exist or was not readable.  This could also include
 *		errors like "No message" to a mailer (if it cared
 *		to catch it).
 *	EX_NOUSER -- The user specified did not exist.  This might
 *		be used for mail addresses or remote logins.
 *	EX_NOHOST -- The host specified did not exist.  This is used
 *		in mail addresses or network requests.
 *	EX_UNAVAILABLE -- A service is unavailable.  This can occur
 *		if a support program or file does not exist.  This
 *		can also be used as a catchall message when something
 *		you wanted to do doesn't work, but you don't know
 *		why.
 *	EX_SOFTWARE -- An internal software error has been detected.
 *		This should be limited to non-operating system related
 *		errors as possible.
 *	EX_OSERR -- An operating system error has been detected.
 *		This is intended to be used for such things as "cannot
 *		fork", "cannot create pipe", or the like.  It includes
 *		things like getuid returning a user that does not
 *		exist in the passwd file.
 *	EX_OSFILE -- Some system file (e.g., /etc/passwd, /etc/utmp,
 *		etc.) does not exist, cannot be opened, or has some
 *		sort of error (e.g., syntax error).
 *	EX_CANTCREAT -- A (user specified) output file cannot be
 *		created.
 *	EX_IOERR -- An error occurred while doing I/O on some file.
 *	EX_TEMPFAIL -- temporary failure, indicating something that
 *		is not really an error.  In sendmail, this means
 *		that a mailer (e.g.) could not create a connection,
 *		and the request should be reattempted later.
 *	EX_PROTOCOL -- the remote system returned something that
 *		was "not possible" during a protocol exchange.
 *	EX_NOPERM -- You did not have sufficient permission to
 *		perform the operation.  This is not intended for
 *		file system problems, which should use NOINPUT or
 *		CANTCREAT, but rather for higher level permissions.
 */
# 139 "src/exim.h" 2


/* A few OS don't have socklen_t; their os.h files define EXIM_SOCKLEN_T to
be size_t or whatever. We used to use SOCKLEN_T, but then it was discovered
that this is used by the AIX include files. */





/* Ensure that the sysexits we reference are defined */
# 164 "src/exim.h"
/* This one is not in any sysexits file that I've come across */




# 1 "/usr/include/sys/time.h" 1 3 4
/* Copyright (C) 1991-1994,1996-2003,2005,2006,2009,2012
	Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/sys/time.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 25 "/usr/include/sys/time.h" 2 3 4

# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 27 "/usr/include/sys/time.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
/* System-dependent timing definitions.  Linux version.
   Copyright (C) 1996,1997,1999-2003,2010,2011,2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <time.h> instead.
 */
# 29 "/usr/include/sys/time.h" 2 3 4

# 1 "/usr/include/sys/select.h" 1 3 4
/* `fd_set' type and related macros, and `select'/`pselect' declarations.
   Copyright (C) 1996-2003, 2009, 2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>  */
# 31 "/usr/include/sys/time.h" 2 3 4










/* Macros for converting between `struct timeval' and `struct timespec'.  */
# 54 "/usr/include/sys/time.h" 3 4
/* Structure crudely representing a timezone.
   This is obsolete and should never be used.  */
struct timezone
  {
    int tz_minuteswest; /* Minutes west of GMT.  */
    int tz_dsttime; /* Nonzero if DST is ever in effect.  */
  };

typedef struct timezone *__restrict __timezone_ptr_t;




/* Get the current time of day and timezone information,
   putting it into *TV and *TZ.  If TZ is NULL, *TZ is not filled.
   Returns 0 on success, -1 on errors.
   NOTE: This form of timezone information is obsolete.
   Use the functions and variables declared in <time.h> instead.  */
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Set the current time of day and timezone information.
   This call is restricted to the super-user.  */
extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     __attribute__ ((__nothrow__ , __leaf__));

/* Adjust the current time of day by the amount in DELTA.
   If OLDDELTA is not NULL, it is filled in with the amount
   of time adjustment remaining to be done from the last `adjtime' call.
   This call is restricted to the super-user.  */
extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__ , __leaf__));



/* Values for the first argument to `getitimer' and `setitimer'.  */
enum __itimer_which
  {
    /* Timers run in real time.  */
    ITIMER_REAL = 0,

    /* Timers run only when the process is executing.  */
    ITIMER_VIRTUAL = 1,

    /* Timers run when the process is executing and when
       the system is executing on behalf of the process.  */
    ITIMER_PROF = 2

  };

/* Type of the second argument to `getitimer' and
   the second and third arguments `setitimer'.  */
struct itimerval
  {
    /* Value to put into `it_value' when the timer expires.  */
    struct timeval it_interval;
    /* Time to the next timer expiration.  */
    struct timeval it_value;
  };


/* Use the nicer parameter type only in GNU mode and not for C++ since the
   strict C++ rules prevent the automatic promotion.  */
typedef enum __itimer_which __itimer_which_t;




/* Set *VALUE to the current setting of timer WHICH.
   Return 0 on success, -1 on errors.  */
extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ , __leaf__));

/* Set the timer WHICH to *NEW.  If OLD is not NULL,
   set *OLD to the old value of timer WHICH.
   Returns 0 on success, -1 on errors.  */
extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ , __leaf__));

/* Change the access time of FILE to TVP[0] and the modification time of
   FILE to TVP[1].  If TVP is a null pointer, use the current time instead.
   Returns 0 on success, -1 on errors.  */
extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Same as `utimes', but does not follow symbolic links.  */
extern int lutimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Same as `utimes', but takes an open file descriptor instead of a name.  */
extern int futimes (int __fd, const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));



/* Change the access time of FILE relative to FD to TVP[0] and the
   modification time of FILE to TVP[1].  If TVP is a null pointer, use
   the current time instead.  Returns 0 on success, -1 on errors.  */
extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));




/* Convenience macros for operations on timevals.
   NOTE: `timercmp' does not work for >= or <=.  */
# 190 "/usr/include/sys/time.h" 3 4

# 170 "src/exim.h" 2
# 1 "/usr/include/sys/param.h" 1 3 4
/* Compatibility header for old-style Unix parameters and limits.
   Copyright (C) 1995-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 24 "/usr/include/sys/param.h" 2 3 4

# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 26 "/usr/include/sys/param.h" 2 3 4
# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include-fixed/limits.h" 1 3 4
/* Copyright (C) 1992-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
# 27 "/usr/include/sys/param.h" 2 3 4
# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 28 "/usr/include/sys/param.h" 2 3 4
# 1 "/usr/include/signal.h" 1 3 4
/* Copyright (C) 1991-2004,2007,2009,2010,2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.14 Signal handling <signal.h>
 */
# 29 "/usr/include/sys/param.h" 2 3 4

/* This file defines some things in system-specific ways.  */
# 1 "/usr/include/bits/param.h" 1 3 4
/* Old-style Unix parameters and limits.  Linux version.
   Copyright (C) 1995-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 28 "/usr/include/bits/param.h" 3 4
# 1 "/usr/include/linux/param.h" 1 3 4



# 1 "/usr/include/asm/param.h" 1 3 4
# 1 "/usr/include/asm-generic/param.h" 1 3 4
# 1 "/usr/include/asm/param.h" 2 3 4
# 5 "/usr/include/linux/param.h" 2 3 4
# 29 "/usr/include/bits/param.h" 2 3 4

/* The kernel headers define ARG_MAX.  The value is wrong, though.  */







/* The following are not really correct but it is a value we used for a
   long time and which seems to be usable.  People should not use NOFILE
   and NCARGS anyway.  */
# 32 "/usr/include/sys/param.h" 2 3 4


/* BSD names for some <limits.h> values.  */
# 64 "/usr/include/sys/param.h" 3 4
/* Magical constants.  */
# 73 "/usr/include/sys/param.h" 3 4
/* Unit of `st_blocks'.  */



/* Bit map related macros.  */





/* Macros for counting and rounding.  */
# 96 "/usr/include/sys/param.h" 3 4
/* Macros for min/max.  */
# 171 "src/exim.h" 2


# 1 "/usr/include/sys/resource.h" 1 3 4
/* Copyright (C) 1992,94,1996-2000,2002,2004,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/sys/resource.h" 2 3 4

/* Get the system-dependent definitions of structures and bit values.  */
# 1 "/usr/include/bits/resource.h" 1 3 4
/* Bit values & structures for resource limits.  Linux version.
   Copyright (C) 1994-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 24 "/usr/include/bits/resource.h" 2 3 4

/* Transmute defines to enumerations.  The macro re-definitions are
   necessary because some programs want to test for operating system
   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
   definition is a no-op.  */

/* Kinds of resource limit.  */
enum __rlimit_resource
{
  /* Per-process CPU limit, in seconds.  */
  RLIMIT_CPU = 0,


  /* Largest file that can be created, in bytes.  */
  RLIMIT_FSIZE = 1,


  /* Maximum size of data segment, in bytes.  */
  RLIMIT_DATA = 2,


  /* Maximum size of stack segment, in bytes.  */
  RLIMIT_STACK = 3,


  /* Largest core file that can be created, in bytes.  */
  RLIMIT_CORE = 4,


  /* Largest resident set size, in bytes.
     This affects swapping; processes that are exceeding their
     resident set size will be more likely to have physical memory
     taken from them.  */
  __RLIMIT_RSS = 5,


  /* Number of open files.  */
  RLIMIT_NOFILE = 7,
  __RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */



  /* Address space limit.  */
  RLIMIT_AS = 9,


  /* Number of processes.  */
  __RLIMIT_NPROC = 6,


  /* Locked-in-memory address space.  */
  __RLIMIT_MEMLOCK = 8,


  /* Maximum number of file locks.  */
  __RLIMIT_LOCKS = 10,


  /* Maximum number of pending signals.  */
  __RLIMIT_SIGPENDING = 11,


  /* Maximum bytes in POSIX message queues.  */
  __RLIMIT_MSGQUEUE = 12,


  /* Maximum nice priority allowed to raise to.
     Nice levels 19 .. -20 correspond to 0 .. 39
     values of this resource limit.  */
  __RLIMIT_NICE = 13,


  /* Maximum realtime priority allowed for non-priviledged
     processes.  */
  __RLIMIT_RTPRIO = 14,


  /* Maximum CPU time in s that a process scheduled under a real-time
     scheduling policy may consume without making a blocking system
     call before being forcibly descheduled.  */
  __RLIMIT_RTTIME = 15,


  __RLIMIT_NLIMITS = 16,
  __RLIM_NLIMITS = __RLIMIT_NLIMITS


};

/* Value to indicate that there is no limit.  */
# 124 "/usr/include/bits/resource.h" 3 4
/* We can represent all limits.  */




/* Type for resource quantity measurement.  */

typedef __rlim_t rlim_t;




typedef __rlim64_t rlim64_t;


struct rlimit
  {
    /* The current (soft) limit.  */
    rlim_t rlim_cur;
    /* The hard limit.  */
    rlim_t rlim_max;
  };


struct rlimit64
  {
    /* The current (soft) limit.  */
    rlim64_t rlim_cur;
    /* The hard limit.  */
    rlim64_t rlim_max;
 };


/* Whose usage statistics do you want?  */
enum __rusage_who
{
  /* The calling process.  */
  RUSAGE_SELF = 0,


  /* All of its terminated child processes.  */
  RUSAGE_CHILDREN = -1



  ,
  /* The calling thread.  */
  RUSAGE_THREAD = 1

  /* Name for the same functionality on Solaris.  */


};


# 1 "/usr/include/bits/time.h" 1 3 4
/* System-dependent timing definitions.  Linux version.
   Copyright (C) 1996,1997,1999-2003,2010,2011,2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <time.h> instead.
 */
# 180 "/usr/include/bits/resource.h" 2 3 4

/* Structure which says how much of each resource has been used.  */

/* The purpose of all the unions is to have the kernel-compatible layout
   while keeping the API type as 'long int', and among machines where
   __syscall_slong_t is not 'long int', this only does the right thing
   for little-endian ones, like x32.  */
struct rusage
  {
    /* Total amount of user time used.  */
    struct timeval ru_utime;
    /* Total amount of system time used.  */
    struct timeval ru_stime;
    /* Maximum resident set size (in kilobytes).  */
    __extension__ union
      {
 long int ru_maxrss;
 __syscall_slong_t __ru_maxrss_word;
      };
    /* Amount of sharing of text segment memory
       with other processes (kilobyte-seconds).  */
    /* Maximum resident set size (in kilobytes).  */
    __extension__ union
      {
 long int ru_ixrss;
 __syscall_slong_t __ru_ixrss_word;
      };
    /* Amount of data segment memory used (kilobyte-seconds).  */
    __extension__ union
      {
 long int ru_idrss;
 __syscall_slong_t __ru_idrss_word;
      };
    /* Amount of stack memory used (kilobyte-seconds).  */
    __extension__ union
      {
 long int ru_isrss;
  __syscall_slong_t __ru_isrss_word;
      };
    /* Number of soft page faults (i.e. those serviced by reclaiming
       a page from the list of pages awaiting reallocation.  */
    __extension__ union
      {
 long int ru_minflt;
 __syscall_slong_t __ru_minflt_word;
      };
    /* Number of hard page faults (i.e. those that required I/O).  */
    __extension__ union
      {
 long int ru_majflt;
 __syscall_slong_t __ru_majflt_word;
      };
    /* Number of times a process was swapped out of physical memory.  */
    __extension__ union
      {
 long int ru_nswap;
 __syscall_slong_t __ru_nswap_word;
      };
    /* Number of input operations via the file system.  Note: This
       and `ru_oublock' do not include operations with the cache.  */
    __extension__ union
      {
 long int ru_inblock;
 __syscall_slong_t __ru_inblock_word;
      };
    /* Number of output operations via the file system.  */
    __extension__ union
      {
 long int ru_oublock;
 __syscall_slong_t __ru_oublock_word;
      };
    /* Number of IPC messages sent.  */
    __extension__ union
      {
 long int ru_msgsnd;
 __syscall_slong_t __ru_msgsnd_word;
      };
    /* Number of IPC messages received.  */
    __extension__ union
      {
 long int ru_msgrcv;
 __syscall_slong_t __ru_msgrcv_word;
      };
    /* Number of signals delivered.  */
    __extension__ union
      {
 long int ru_nsignals;
 __syscall_slong_t __ru_nsignals_word;
      };
    /* Number of voluntary context switches, i.e. because the process
       gave up the process before it had to (usually to wait for some
       resource to be available).  */
    __extension__ union
      {
 long int ru_nvcsw;
 __syscall_slong_t __ru_nvcsw_word;
      };
    /* Number of involuntary context switches, i.e. a higher priority process
       became runnable or the current process used up its time slice.  */
    __extension__ union
      {
 long int ru_nivcsw;
 __syscall_slong_t __ru_nivcsw_word;
      };
  };

/* Priority limits.  */



/* The type of the WHICH argument to `getpriority' and `setpriority',
   indicating what flavor of entity the WHO argument specifies.  */
enum __priority_which
{
  PRIO_PROCESS = 0, /* WHO is a process ID.  */

  PRIO_PGRP = 1, /* WHO is a process group ID.  */

  PRIO_USER = 2 /* WHO is a user ID.  */

};





/* Modify and return resource limits of a process atomically.  */

extern int prlimit (__pid_t __pid, enum __rlimit_resource __resource,
      const struct rlimit *__new_limit,
      struct rlimit *__old_limit) __attribute__ ((__nothrow__ , __leaf__));
# 322 "/usr/include/bits/resource.h" 3 4
extern int prlimit64 (__pid_t __pid, enum __rlimit_resource __resource,
        const struct rlimit64 *__new_limit,
        struct rlimit64 *__old_limit) __attribute__ ((__nothrow__ , __leaf__));




# 26 "/usr/include/sys/resource.h" 2 3 4








/* The X/Open standard defines that all the functions below must use
   `int' as the type for the first argument.  When we are compiling with
   GNU extensions we change this slightly to provide better error
   checking.  */

typedef enum __rlimit_resource __rlimit_resource_t;
typedef enum __rusage_who __rusage_who_t;
typedef enum __priority_which __priority_which_t;






/* Put the soft and hard limits for RESOURCE in *RLIMITS.
   Returns 0 if successful, -1 if not (and sets errno).  */

extern int getrlimit (__rlimit_resource_t __resource,
        struct rlimit *__rlimits) __attribute__ ((__nothrow__ , __leaf__));
# 62 "/usr/include/sys/resource.h" 3 4
extern int getrlimit64 (__rlimit_resource_t __resource,
   struct rlimit64 *__rlimits) __attribute__ ((__nothrow__ , __leaf__));


/* Set the soft and hard limits for RESOURCE to *RLIMITS.
   Only the super-user can increase hard limits.
   Return 0 if successful, -1 if not (and sets errno).  */

extern int setrlimit (__rlimit_resource_t __resource,
        const struct rlimit *__rlimits) __attribute__ ((__nothrow__ , __leaf__));
# 82 "/usr/include/sys/resource.h" 3 4
extern int setrlimit64 (__rlimit_resource_t __resource,
   const struct rlimit64 *__rlimits) __attribute__ ((__nothrow__ , __leaf__));


/* Return resource usage information on process indicated by WHO
   and put it in *USAGE.  Returns 0 for success, -1 for failure.  */
extern int getrusage (__rusage_who_t __who, struct rusage *__usage) __attribute__ ((__nothrow__ , __leaf__));

/* Return the highest priority of any process specified by WHICH and WHO
   (see above); if WHO is zero, the current process, process group, or user
   (as specified by WHO) is used.  A lower priority number means higher
   priority.  Priorities range from PRIO_MIN to PRIO_MAX (above).  */
extern int getpriority (__priority_which_t __which, id_t __who) __attribute__ ((__nothrow__ , __leaf__));

/* Set the priority of all processes specified by WHICH and WHO (see above)
   to PRIO.  Returns 0 on success, -1 on errors.  */
extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
     __attribute__ ((__nothrow__ , __leaf__));


# 174 "src/exim.h" 2


# 1 "/usr/include/sys/socket.h" 1 3 4
/* Declarations of socket constants, types, and functions.
   Copyright (C) 1991,92,1994-2001,2003,2005,2007,2008,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 177 "src/exim.h" 2

/* If we are on an IPv6 system, the macro AF_INET6 will have been defined in
the sys/socket.h header. It is helpful to have this defined on an IPv4 system
so that it can appear in the code, even if it is never actually used when
the code is run. It saves some #ifdef occurrences. */





# 1 "/usr/include/sys/ioctl.h" 1 3 4
/* Copyright (C) 1991, 92, 93, 94, 96, 98, 99 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/sys/ioctl.h" 2 3 4



/* Get the list of `ioctl' requests and related constants.  */
# 1 "/usr/include/bits/ioctls.h" 1 3 4
/* Copyright (C) 1996, 1997, 1998, 2003 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Use the definitions from the kernel header files.  */
# 1 "/usr/include/asm/ioctls.h" 1 3 4
# 1 "/usr/include/asm-generic/ioctls.h" 1 3 4



# 1 "/usr/include/linux/ioctl.h" 1 3 4



# 1 "/usr/include/asm/ioctl.h" 1 3 4
# 1 "/usr/include/asm-generic/ioctl.h" 1 3 4



/* ioctl command encoding: 32 bits total, command in lower 16 bits,
 * size of the parameter structure in the lower 14 bits of the
 * upper 16 bits.
 * Encoding the size of the parameter structure in the ioctl request
 * is useful for catching programs compiled with old versions
 * and to avoid overwriting user space outside the user buffer area.
 * The highest 2 bits are reserved for indicating the ``access mode''.
 * NOTE: This limits the max parameter size to 16kB -1 !
 */

/*
 * The following is for compatibility across the various Linux
 * platforms.  The generic ioctl numbering scheme doesn't really enforce
 * a type field.  De facto, however, the top 8 bits of the lower 16
 * bits are indeed used as a type field, so we might just as well make
 * this explicit here.  Please be sure to use the decoding macros
 * below from now on.
 */



/*
 * Let any architecture override either of the following before
 * including this file.
 */
# 48 "/usr/include/asm-generic/ioctl.h" 3 4
/*
 * Direction bits, which any architecture can choose to override
 * before including this file.
 */
# 73 "/usr/include/asm-generic/ioctl.h" 3 4
/* used to create numbers */
# 82 "/usr/include/asm-generic/ioctl.h" 3 4
/* used to decode ioctl numbers.. */





/* ...and for the drivers/sound files... */
# 1 "/usr/include/asm/ioctl.h" 2 3 4
# 5 "/usr/include/linux/ioctl.h" 2 3 4
# 5 "/usr/include/asm-generic/ioctls.h" 2 3 4

/*
 * These are the most common definitions for tty ioctl numbers.
 * Most of them do not use the recommended _IOC(), but there is
 * probably some source code out there hardcoding the number,
 * so we might as well use them for all new platforms.
 *
 * The architectures that use different values here typically
 * try to be compatible with some Unix variants for the same
 * architecture.
 */

/* 0x54 is just a magic number to make these relatively unique ('T') */
# 97 "/usr/include/asm-generic/ioctls.h" 3 4
/*
 * Some arches already define FIOQSIZE due to a historical
 * conflict with a Hayes modem-specific ioctl value.
 */




/* Used for packet mode */
# 1 "/usr/include/asm/ioctls.h" 2 3 4
# 24 "/usr/include/bits/ioctls.h" 2 3 4

/* Routing table calls.  */




/* Socket configuration controls. */
# 74 "/usr/include/bits/ioctls.h" 3 4
/* ARP cache control calls. */
      /*  0x8950 - 0x8952  * obsolete calls, don't re-use */




/* RARP cache control calls. */




/* Driver configuration calls */




/* DLCI configuration calls */




/* Device private ioctl calls.  */

/* These 16 ioctls are available to devices via the do_ioctl() device
   vector.  Each device should include this file and redefine these
   names as their own. Because these are device dependent it is a good
   idea _NOT_ to issue them to random objects and hope.  */



/*
 *	These 16 ioctl calls are protocol private
 */
# 27 "/usr/include/sys/ioctl.h" 2 3 4

/* Define some types used by `ioctl' requests.  */
# 1 "/usr/include/bits/ioctl-types.h" 1 3 4
/* Structure types for pre-termios terminal ioctls.  Linux version.
   Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Get definition of constants for use with `ioctl'.  */
# 1 "/usr/include/asm/ioctls.h" 1 3 4
# 25 "/usr/include/bits/ioctl-types.h" 2 3 4


struct winsize
  {
    unsigned short int ws_row;
    unsigned short int ws_col;
    unsigned short int ws_xpixel;
    unsigned short int ws_ypixel;
  };


struct termio
  {
    unsigned short int c_iflag; /* input mode flags */
    unsigned short int c_oflag; /* output mode flags */
    unsigned short int c_cflag; /* control mode flags */
    unsigned short int c_lflag; /* local mode flags */
    unsigned char c_line; /* line discipline */
    unsigned char c_cc[8]; /* control characters */
};

/* modem lines */
# 59 "/usr/include/bits/ioctl-types.h" 3 4
/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */

/* line disciplines */
# 30 "/usr/include/sys/ioctl.h" 2 3 4

/* On a Unix system, the system <sys/ioctl.h> probably defines some of
   the symbols we define in <sys/ttydefaults.h> (usually with the same
   values).  The code to generate <bits/ioctls.h> has omitted these
   symbols to avoid the conflict, but a Unix program expects <sys/ioctl.h>
   to define them, so we must include <sys/ttydefaults.h> here.  */
# 1 "/usr/include/sys/ttydefaults.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ttydefaults.h	8.4 (Berkeley) 1/21/94
 */

/*
 * System wide defaults for terminal state.  Linux version.
 */



/*
 * Defaults on "first" open.
 */






/*
 * Control Character Defaults
 */
# 82 "/usr/include/sys/ttydefaults.h" 3 4
/* compat */




/* PROTECTED INCLUSION ENDS HERE */


/*
 * #define TTYDEFCHARS to include an array of default control characters.
 */
# 37 "/usr/include/sys/ioctl.h" 2 3 4

/* Perform the I/O control operation specified by REQUEST on FD.
   One argument may follow; its presence and type depend on REQUEST.
   Return value depends on REQUEST.  Usually -1 indicates error.  */
extern int ioctl (int __fd, unsigned long int __request, ...) __attribute__ ((__nothrow__ , __leaf__));


# 188 "src/exim.h" 2

/* The new standard is statvfs; some OS have statfs. For statvfs the block
counts must be multiplied by the "fragment size" f_frsize to get the actual
size. In other cases the value seems to be f_bsize (which is sometimes the only
block size), so we use a macro to get that instead.

Also arrange to be able to cut it out altogether for way-out OS that don't have
anything. I've indented a bit here to try to make the mess a bit more
intelligible. Note that simply defining one name to be another when
HAVE_SYS_STATVFS_H is not set will not work if the system has a statvfs macro
or a macro with entries f_frsize and f_bsize. */



# 1 "/usr/include/sys/statvfs.h" 1 3 4
/* Definitions for getting information about a filesystem.
   Copyright (C) 1998, 1999, 2000, 2004, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/sys/statvfs.h" 2 3 4

/* Get the system-specific definition of `struct statfs'.  */
# 1 "/usr/include/bits/statvfs.h" 1 3 4
/* Copyright (C) 1997-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 23 "/usr/include/bits/statvfs.h" 2 3 4






struct statvfs
  {
    unsigned long int f_bsize;
    unsigned long int f_frsize;

    __fsblkcnt_t f_blocks;
    __fsblkcnt_t f_bfree;
    __fsblkcnt_t f_bavail;
    __fsfilcnt_t f_files;
    __fsfilcnt_t f_ffree;
    __fsfilcnt_t f_favail;
# 48 "/usr/include/bits/statvfs.h" 3 4
    unsigned long int f_fsid;



    unsigned long int f_flag;
    unsigned long int f_namemax;
    int __f_spare[6];
  };


struct statvfs64
  {
    unsigned long int f_bsize;
    unsigned long int f_frsize;
    __fsblkcnt64_t f_blocks;
    __fsblkcnt64_t f_bfree;
    __fsblkcnt64_t f_bavail;
    __fsfilcnt64_t f_files;
    __fsfilcnt64_t f_ffree;
    __fsfilcnt64_t f_favail;
    unsigned long int f_fsid;



    unsigned long int f_flag;
    unsigned long int f_namemax;
    int __f_spare[6];
  };


/* Definitions for the flag in `f_flag'.  These definitions should be
   kept in sync with the definitions in <sys/mount.h>.  */
enum
{
  ST_RDONLY = 1, /* Mount read-only.  */

  ST_NOSUID = 2 /* Ignore suid and sgid bits.  */


  ,
  ST_NODEV = 4, /* Disallow access to device special files.  */

  ST_NOEXEC = 8, /* Disallow program execution.  */

  ST_SYNCHRONOUS = 16, /* Writes are synced at once.  */

  ST_MANDLOCK = 64, /* Allow mandatory locks on an FS.  */

  ST_WRITE = 128, /* Write on file/directory/symlink.  */

  ST_APPEND = 256, /* Append-only file.  */

  ST_IMMUTABLE = 512, /* Immutable file.  */

  ST_NOATIME = 1024, /* Do not update access times.  */

  ST_NODIRATIME = 2048, /* Do not update directory access times.  */

  ST_RELATIME = 4096 /* Update atime relative to mtime/ctime.  */


};
# 26 "/usr/include/sys/statvfs.h" 2 3 4
# 47 "/usr/include/sys/statvfs.h" 3 4


/* Return information about the filesystem on which FILE resides.  */

extern int statvfs (const char *__restrict __file,
      struct statvfs *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 65 "/usr/include/sys/statvfs.h" 3 4
extern int statvfs64 (const char *__restrict __file,
        struct statvfs64 *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


/* Return information about the filesystem containing the file FILDES
   refers to.  */

extern int fstatvfs (int __fildes, struct statvfs *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 84 "/usr/include/sys/statvfs.h" 3 4
extern int fstatvfs64 (int __fildes, struct statvfs64 *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 203 "src/exim.h" 2
# 219 "src/exim.h"
  /* Macros for the fields for the available space for non-superusers; define
  these only if the OS header has not. Not all OS have f_favail; those that
  are known to have it define F_FAVAIL as f_favail. The default is to use
  f_free. */
# 232 "src/exim.h"
  /* All the systems I've been able to look at seem to have F_FILES */
# 245 "src/exim.h"
# 1 "/usr/include/sys/stat.h" 1 3 4
/* Copyright (C) 1991, 1992, 1995-2007, 2009, 2010, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 5.6 File Characteristics	<sys/stat.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/sys/stat.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 29 "/usr/include/sys/stat.h" 2 3 4
# 38 "/usr/include/sys/stat.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 39 "/usr/include/sys/stat.h" 2 3 4



/* The Single Unix specification says that some more types are
   available here.  */
# 104 "/usr/include/sys/stat.h" 3 4


# 1 "/usr/include/bits/stat.h" 1 3 4
/* Copyright (C) 1999-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 107 "/usr/include/sys/stat.h" 2 3 4
# 126 "/usr/include/sys/stat.h" 3 4
/* Test macros for file types.	*/
# 152 "/usr/include/sys/stat.h" 3 4
/* These are from POSIX.1b.  If the objects are not implemented using separate
   distinct file types, the macros always will evaluate to zero.  Unlike the
   other S_* macros the following three take a pointer to a `struct stat'
   object as the argument.  */







/* Protection bits.  */





/* Save swapped text after use (sticky bit).  This is pretty well obsolete.  */






/* Read, write, and execute by owner.  */
# 188 "/usr/include/sys/stat.h" 3 4
/* Read, write, and execute by group.  */





/* Read, write, and execute by others.  */




/* Macros for common mode bit masks.  */
# 209 "/usr/include/sys/stat.h" 3 4
/* Get file attributes for FILE and put them in BUF.  */
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Get file attributes for the file, device, pipe, or socket
   that file descriptor FD is open on and put them in BUF.  */
extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 229 "/usr/include/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* Similar to stat, get the attributes for FILE and put them in BUF.
   Relative path names are interpreted relative to FD unless FD is
   AT_FDCWD.  */

extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 254 "/usr/include/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));





/* Get file attributes about FILE and put them in BUF.
   If FILE is a symbolic link, do not follow it.  */
extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 277 "/usr/include/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



/* Set file access permissions for FILE to MODE.
   If FILE is a symbolic link, this affects its target instead.  */
extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Set file access permissions for FILE to MODE.
   If FILE is a symbolic link, this affects the link itself
   rather than its target.  */
extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Set file access permissions of the file FD is open on to MODE.  */

extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));



/* Set file access permissions of FILE relative to
   the directory FD is open on.  */
extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;




/* Set the file creation mask of the current process to MASK,
   and return the old creation mask.  */
extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));


/* Get the current `umask' value without changing it.
   This function is only available under the GNU Hurd.  */
extern __mode_t getumask (void) __attribute__ ((__nothrow__ , __leaf__));


/* Create a new directory named PATH, with permission bits MODE.  */
extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Like mkdir, create a new directory with permission bits MODE.  But
   interpret relative PATH names relative to the directory associated
   with FD.  */
extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


/* Create a device file named PATH, with permission and special bits MODE
   and device number DEV (which can be constructed from major and minor
   device numbers with the `makedev' macro above).  */

extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Like mknod, create a new device file with permission bits MODE and
   device number DEV.  But interpret relative PATH names relative to
   the directory associated with FD.  */
extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




/* Create a new FIFO named PATH, with permission bits MODE.  */
extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Like mkfifo, create a new FIFO with permission bits MODE.  But
   interpret relative PATH names relative to the directory associated
   with FD.  */
extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* Set file access and modification times relative to directory file
   descriptor.  */
extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* Set file access and modification times of the file associated with FD.  */
extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));


/* To allow the `struct stat' structure and the file type `mode_t'
   bits to vary without changing shared library major version number,
   the `stat' family of functions and `mknod' are in fact inline
   wrappers around calls to `xstat', `fxstat', `lxstat', and `xmknod',
   which all take a leading version-number argument designating the
   data structure and bits used.  <bits/stat.h> defines _STAT_VER with
   the version number corresponding to `struct stat' as defined in
   that file; and _MKNOD_VER with the version number corresponding to
   the S_IF* macros defined therein.  It is arranged that when not
   inlined these function are always statically linked; that way a
   dynamically-linked executable always encodes the version number
   corresponding to the data structures it uses, so the `x' functions
   in the shared library can adapt without needing to recompile all
   callers.  */
# 398 "/usr/include/sys/stat.h" 3 4
/* Wrappers for stat and mknod system calls.  */

extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
# 433 "/usr/include/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 5)));
# 535 "/usr/include/sys/stat.h" 3 4

# 246 "src/exim.h" 2
# 1 "/usr/include/sys/wait.h" 1 3 4
/* Copyright (C) 1991-1994,1996-2001,2003,2004,2005,2007,2009,2010,2011,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 3.2.1 Wait for Process Termination	<sys/wait.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/sys/wait.h" 2 3 4



# 1 "/usr/include/signal.h" 1 3 4
/* Copyright (C) 1991-2004,2007,2009,2010,2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.14 Signal handling <signal.h>
 */
# 31 "/usr/include/sys/wait.h" 2 3 4

/* These macros could also be defined in <stdlib.h>.  */
# 98 "/usr/include/sys/wait.h" 3 4
/* The following values are used by the `waitid' function.  */

typedef enum
{
  P_ALL, /* Wait for any child.  */
  P_PID, /* Wait for specified process.  */
  P_PGID /* Wait for members of process group.  */
} idtype_t;



/* Wait for a child to die.  When one does, put its status in *STAT_LOC
   and return its process ID.  For errors, return (pid_t) -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern __pid_t wait (__WAIT_STATUS __stat_loc);


/* Special values for the PID argument to `waitpid' and `wait4'.  */




/* Wait for a child matching PID to die.
   If PID is greater than 0, match any process whose process ID is PID.
   If PID is (pid_t) -1, match any process.
   If PID is (pid_t) 0, match any process with the
   same process group as the current process.
   If PID is less than -1, match any process whose
   process group is the absolute value of PID.
   If the WNOHANG bit is set in OPTIONS, and that child
   is not already dead, return (pid_t) 0.  If successful,
   return PID and store the dead child's status in STAT_LOC.
   Return (pid_t) -1 for errors.  If the WUNTRACED bit is
   set in OPTIONS, return status for stopped children; otherwise don't.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern __pid_t waitpid (__pid_t __pid, int *__stat_loc, int __options);
# 147 "/usr/include/sys/wait.h" 3 4
# 1 "/usr/include/bits/siginfo.h" 1 3 4
/* siginfo_t, sigevent and constants.  Linux x86-64 version.
   Copyright (C) 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 25 "/usr/include/bits/siginfo.h" 2 3 4
# 148 "/usr/include/sys/wait.h" 2 3 4

/* Wait for a childing matching IDTYPE and ID to change the status and
   place appropriate information in *INFOP.
   If IDTYPE is P_PID, match any process whose process ID is ID.
   If IDTYPE is P_PGID, match any process whose process group is ID.
   If IDTYPE is P_ALL, match any process.
   If the WNOHANG bit is set in OPTIONS, and that child
   is not already dead, clear *INFOP and return 0.  If successful, store
   exit code and status in *INFOP.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int waitid (idtype_t __idtype, __id_t __id, siginfo_t *__infop,
     int __options);



/* This being here makes the prototypes valid whether or not
   we have already included <sys/resource.h> to define `struct rusage'.  */
struct rusage;

/* Wait for a child to exit.  When one does, put its status in *STAT_LOC and
   return its process ID.  For errors return (pid_t) -1.  If USAGE is not
   nil, store information about the child's resource usage there.  If the
   WUNTRACED bit is set in OPTIONS, return status for stopped children;
   otherwise don't.  */
extern __pid_t wait3 (__WAIT_STATUS __stat_loc, int __options,
        struct rusage * __usage) __attribute__ ((__nothrow__));



/* PID is like waitpid.  Other args are like wait3.  */
extern __pid_t wait4 (__pid_t __pid, __WAIT_STATUS __stat_loc, int __options,
        struct rusage *__usage) __attribute__ ((__nothrow__));




# 247 "src/exim.h" 2
# 1 "/usr/include/sys/utsname.h" 1 3 4
/* Copyright (C) 1991,92,94,96,97,99,2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 4.4 System Identification	<sys/utsname.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/sys/utsname.h" 2 3 4



# 1 "/usr/include/bits/utsname.h" 1 3 4
/* Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Length of the entries in `struct utsname' is 65.  */


/* Linux provides as additional information in the `struct utsname'
   the name of the current domain.  Define _UTSNAME_DOMAIN_LENGTH
   to a value != 0 to activate this entry.  */
# 30 "/usr/include/sys/utsname.h" 2 3 4
# 47 "/usr/include/sys/utsname.h" 3 4
/* Structure describing the system and machine.  */
struct utsname
  {
    /* Name of the implementation of the operating system.  */
    char sysname[65];

    /* Name of this node on the network.  */
    char nodename[65];

    /* Current release level of this implementation.  */
    char release[65];
    /* Current version level of this release.  */
    char version[65];

    /* Name of the hardware type the system is running on.  */
    char machine[65];


    /* Name of the domain of this node on the network.  */

    char domainname[65];




  };


/* Note that SVID assumes all members have the same size.  */




/* Put information about the system in NAME.  */
extern int uname (struct utsname *__name) __attribute__ ((__nothrow__ , __leaf__));



# 248 "src/exim.h" 2
# 1 "/usr/include/fcntl.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 6.5 File Control Operations	<fcntl.h>
 */
# 249 "src/exim.h" 2

/* There's a shambles in IRIX6 - it defines EX_OK in unistd.h which conflicts
with the definition in sysexits.h. Exim does not actually use this macro, so we
just undefine it. It would be nice to be able to re-instate the definition from
sysexits.h if there is no definition in unistd.h, but I do not think there is a
way to do this in C because macro definitions are not scanned for other macros
at definition time. [The code here used to assume they were, until I was
disabused of the notion. Luckily, since EX_OK is not used, it didn't matter.] */





# 1 "/usr/include/unistd.h" 1 3 4
/* Copyright (C) 1991-2009, 2010, 2011, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/unistd.h" 2 3 4



/* These may be used to determine what facilities are present at compile time.
   Their values can be obtained at run time from `sysconf'.  */


/* POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.  */
# 49 "/usr/include/unistd.h" 3 4
/* These are not #ifdef __USE_POSIX2 because they are
   in the theoretically application-owned namespace.  */



/* The utilities on GNU systems also correspond to this version.  */
# 66 "/usr/include/unistd.h" 3 4
/* The utilities on GNU systems also correspond to this version.  */


/* If defined, the implementation supports the
   C Language Bindings Option.  */


/* If defined, the implementation supports the
   C Language Development Utilities Option.  */


/* If defined, the implementation supports the
   Software Development Utilities Option.  */


/* If defined, the implementation supports the
   creation of locales with the localedef utility.  */


/* X/Open version number to which the library conforms.  It is selectable.  */
# 96 "/usr/include/unistd.h" 3 4
/* Commands and utilities from XPG4 are available.  */


/* We are compatible with the old published standards as well.  */




/* The X/Open Unix extensions are available.  */


/* Encryption is present.  */


/* The enhanced internationalization capabilities according to XPG4.2
   are present.  */


/* The legacy interfaces are also available.  */



/* Get values of POSIX options:

   If these symbols are defined, the corresponding features are
   always available.  If not, they may be available sometimes.
   The current values can be obtained with `sysconf'.

   _POSIX_JOB_CONTROL		Job control is supported.
   _POSIX_SAVED_IDS		Processes have a saved set-user-ID
				and a saved set-group-ID.
   _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
   _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
   _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
   _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
   _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
   _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
   _POSIX_FSYNC			The fsync function is present.
   _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
   _POSIX_MEMLOCK		Locking of all memory is supported.
   _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
   _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
   _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
   _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
   _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
   _POSIX_THREADS		POSIX.1c pthreads are supported.
   _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
   _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
   _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
   _POSIX_THREAD_PRIORITY_SCHEDULING
				POSIX.1c thread execution scheduling supported.
   _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
   _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
   _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
   _POSIX_PII			Protocol-independent interfaces are supported.
   _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
   _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
   _POSIX_PII_INTERNET		Internet family of protocols supported.
   _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
   _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
   _POSIX_PII_OSI		ISO/OSI family of protocols supported.
   _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
   _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
   _POSIX_POLL			Implementation supports `poll' function.
   _POSIX_SELECT		Implementation supports `select' and `pselect'.

   _XOPEN_REALTIME		X/Open realtime support is available.
   _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
   _XOPEN_SHM			Shared memory interface according to XPG4.2.

   _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
				int, long, pointer, and off_t types.
   _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
				int, long, and pointer and off_t with at least
				64 bits.
   _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
				int, and 64-bit long, pointer, and off_t types.
   _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
				least 32 bits int and long, pointer, and off_t
				with at least 64 bits.

   If any of these symbols is defined as -1, the corresponding option is not
   true for any file.  If any is defined as other than -1, the corresponding
   option is true for all files.  If a symbol is not defined at all, the value
   for a specific file can be obtained from `pathconf' and `fpathconf'.

   _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
				the owner of a file.  `chown' can only be used
				to change the group ID of a file to a group of
				which the calling process is a member.
   _POSIX_NO_TRUNC		Pathname components longer than
				NAME_MAX generate an error.
   _POSIX_VDISABLE		If defined, if the value of an element of the
				`c_cc' member of `struct termios' is
				_POSIX_VDISABLE, no character will have the
				effect associated with that element.
   _POSIX_SYNC_IO		Synchronous I/O may be performed.
   _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
   _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.

   Support for the Large File Support interface is not generally available.
   If it is available the following constants are defined to one.
   _LFS64_LARGEFILE		Low-level I/O supports large files.
   _LFS64_STDIO			Standard I/O supports large files.
   */

# 1 "/usr/include/bits/posix_opt.h" 1 3 4
/* Define POSIX options for Linux.
   Copyright (C) 1996-2004, 2006, 2008, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If
   not, see <http://www.gnu.org/licenses/>.  */




/* Job control is supported.  */


/* Processes have a saved set-user-ID and a saved set-group-ID.  */


/* Priority scheduling is supported.  */


/* Synchronizing file data is supported.  */


/* The fsync function is present.  */


/* Mapping of files to memory is supported.  */


/* Locking of all memory is supported.  */


/* Locking of ranges of memory is supported.  */


/* Setting of memory protections is supported.  */


/* Some filesystems allow all users to change file ownership.  */


/* `c_cc' member of 'struct termios' structure can be disabled by
   using the value _POSIX_VDISABLE.  */


/* Filenames are not silently truncated.  */


/* X/Open realtime support is available.  */


/* X/Open thread realtime support is available.  */


/* XPG4.2 shared memory is supported.  */


/* Tell we have POSIX threads.  */


/* We have the reentrant functions described in POSIX.  */



/* We provide priority scheduling for threads.  */


/* We support user-defined stack sizes.  */


/* We support user-defined stacks.  */


/* We support priority inheritence.  */


/* We support priority protection, though only for non-robust
   mutexes.  */



/* We support priority inheritence for robust mutexes.  */


/* We do not support priority protection for robust mutexes.  */



/* We support POSIX.1b semaphores.  */


/* Real-time signals are supported.  */


/* We support asynchronous I/O.  */


/* Alternative name for Unix98.  */

/* Support for prioritization is also available.  */


/* The LFS support in asynchronous I/O is also available.  */


/* The rest of the LFS is also available.  */




/* POSIX shared memory objects are implemented.  */


/* CPU-time clocks support needs to be checked at runtime.  */


/* Clock support in threads must be also checked at runtime.  */


/* GNU libc provides regular expression handling.  */


/* Reader/Writer locks are available.  */


/* We have a POSIX shell.  */


/* We support the Timeouts option.  */


/* We support spinlocks.  */


/* The `spawn' function family is supported.  */


/* We have POSIX timers.  */


/* The barrier functions are available.  */


/* POSIX message queues are available.  */


/* Thread process-shared synchronization is supported.  */


/* The monotonic clock might be available.  */


/* The clock selection interfaces are available.  */


/* Advisory information interfaces are available.  */


/* IPv6 support is available.  */


/* Raw socket support is available.  */


/* We have at least one terminal.  */


/* Neither process nor thread sporadic server interfaces is available.  */



/* trace.h is not available.  */





/* Typed memory objects are not available.  */
# 203 "/usr/include/unistd.h" 2 3 4

/* Get the environment definitions from Unix98.  */

# 1 "/usr/include/bits/environments.h" 1 3 4
/* Copyright (C) 1999, 2001, 2004, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 23 "/usr/include/bits/environments.h" 2 3 4

/* This header should define the following symbols under the described
   situations.  A value `1' means that the model is always supported,
   `-1' means it is never supported.  Undefined means it cannot be
   statically decided.

   _POSIX_V7_ILP32_OFF32   32bit int, long, pointers, and off_t type
   _POSIX_V7_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type

   _POSIX_V7_LP64_OFF32	   64bit long and pointers and 32bit off_t type
   _POSIX_V7_LPBIG_OFFBIG  64bit long and pointers and large off_t type

   The macros _POSIX_V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG,
   _POSIX_V6_LP64_OFF32, _POSIX_V6_LPBIG_OFFBIG, _XBS5_ILP32_OFF32,
   _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and _XBS5_LPBIG_OFFBIG were
   used in previous versions of the Unix standard and are available
   only for compatibility.
*/



/* Environments with 32-bit wide pointers are optionally provided.
   Therefore following macros aren't defined:
   # undef _POSIX_V7_ILP32_OFF32
   # undef _POSIX_V7_ILP32_OFFBIG
   # undef _POSIX_V6_ILP32_OFF32
   # undef _POSIX_V6_ILP32_OFFBIG
   # undef _XBS5_ILP32_OFF32
   # undef _XBS5_ILP32_OFFBIG
   and users need to check at runtime.  */

/* We also have no use (for now) for an environment with bigger pointers
   and offsets.  */




/* By default we have 64-bit wide `long int', pointers and `off_t'.  */
# 207 "/usr/include/unistd.h" 2 3 4


/* Standard file descriptors.  */





/* All functions that are not declared anywhere else.  */

# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 218 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 227 "/usr/include/unistd.h" 2 3 4


/* The Single Unix specification says that some more types are
   available here.  */
# 279 "/usr/include/unistd.h" 3 4
/* Values for the second argument to access.
   These may be OR'd together.  */





/* Test for access to NAME using the real UID and real GID.  */
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Test for access to NAME using the effective UID and GID
   (as normal file operations use).  */
extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* An alias for `euidaccess', used by some other systems.  */
extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Test for access to FILE relative to the directory FD is open on.
   If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',
   otherwise use real IDs like `access'.  */
extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



/* Values for the WHENCE argument to lseek.  */
# 328 "/usr/include/unistd.h" 3 4
/* Move FD's file position to OFFSET bytes from the
   beginning of the file (if WHENCE is SEEK_SET),
   the current position (if WHENCE is SEEK_CUR),
   or the end of the file (if WHENCE is SEEK_END).
   Return the new file position.  */

extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));


/* Close the file descriptor FD.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int close (int __fd);

/* Read NBYTES into BUF from FD.  Return the
   number read, -1 for errors or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;

/* Write N bytes of BUF to FD.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t write (int __fd, const void *__buf, size_t __n) ;



/* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;

/* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 401 "/usr/include/unistd.h" 3 4
/* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.  */
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;
/* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.  */
extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;



/* Create a one-way communication channel (pipe).
   If successful, two file descriptors are stored in PIPEDES;
   bytes written on PIPEDES[1] can be read from PIPEDES[0].
   Returns 0 if successful, -1 if not.  */
extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Same as pipe but apply flags passed in FLAGS to the new file
   descriptors.  */
extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.
   If SECONDS is zero, any currently scheduled alarm will be cancelled.
   The function returns the number of seconds remaining until the last
   alarm scheduled would have signaled, or zero if there wasn't one.
   There is no return value to indicate an error, but you can set `errno'
   to 0 and check its value after calling `alarm', and this might tell you.
   The signal may come late due to processor scheduling.  */
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));

/* Make the process sleep for SECONDS seconds, or until a signal arrives
   and is not ignored.  The function returns the number of seconds less
   than SECONDS which it actually slept (thus zero if it slept the full time).
   If a signal handler does a `longjmp' or modifies the handling of the
   SIGALRM signal while inside `sleep' call, the handling of the SIGALRM
   signal afterwards is undefined.  There is no return value to indicate
   error, but if `sleep' returns SECONDS, it probably didn't work.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern unsigned int sleep (unsigned int __seconds);



/* Set an alarm to go off (generating a SIGALRM signal) in VALUE
   microseconds.  If INTERVAL is nonzero, when the alarm goes off, the
   timer is reset to go off every INTERVAL microseconds thereafter.
   Returns the number of microseconds remaining before the alarm.  */
extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));

/* Sleep USECONDS microseconds, or until a signal arrives that is not blocked
   or ignored.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int usleep (__useconds_t __useconds);



/* Suspend the process until a signal arrives.
   This always returns -1 and sets `errno' to EINTR.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pause (void);


/* Change the owner and group of FILE.  */
extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;


/* Change the owner and group of the file that FD is open on.  */
extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Change owner and group of FILE, if it is a symbolic
   link the ownership of the symbolic link is changed.  */
extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




/* Change the owner and group of FILE relative to the directory FD is open
   on.  */
extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;


/* Change the process's working directory to PATH.  */
extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;


/* Change the process's working directory to the one FD is open on.  */
extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Get the pathname of the current working directory,
   and put it in SIZE bytes of BUF.  Returns NULL if the
   directory couldn't be determined or SIZE was too small.
   If successful, returns BUF.  In GNU, if BUF is NULL,
   an array is allocated with `malloc'; the array is SIZE
   bytes long, unless SIZE == 0, in which case it is as
   big as necessary.  */
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Return a malloc'd string containing the current directory name.
   If the environment variable `PWD' is set, and its value is correct,
   that value is used.  */
extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));




/* Put the absolute pathname of the current working directory in BUF.
   If successful, return BUF.  If not, put an error message in
   BUF and return NULL.  BUF should be at least PATH_MAX bytes long.  */
extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;



/* Duplicate FD, returning a new file descriptor on the same file.  */
extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;

/* Duplicate FD to FD2, closing FD2 and making it open on the same file.  */
extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));


/* Duplicate FD to FD2, closing FD2 and making it open on the same
   file while setting flags according to FLAGS.  */
extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));


/* NULL-terminated array of "NAME=VALUE" environment variables.  */
extern char **__environ;

extern char **environ;



/* Replace the current process, executing PATH with arguments ARGV and
   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */
extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


/* Execute the file FD refers to, overlaying the running program image.
   ARGV and ENVP are passed to the new program, as for `execve'.  */
extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* Execute PATH with arguments ARGV and environment from `environ'.  */
extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Execute PATH with all arguments after PATH until a NULL pointer,
   and the argument after that for environment.  */
extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Execute PATH with all arguments after PATH until
   a NULL pointer and environment from `environ'.  */
extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Execute FILE, searching in the `PATH' environment variable if it contains
   no slashes, with arguments ARGV and environment from `environ'.  */
extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Execute FILE, searching in the `PATH' environment variable if
   it contains no slashes, with all arguments after FILE until a
   NULL pointer and environment from `environ'.  */
extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


/* Execute FILE, searching in the `PATH' environment variable if it contains
   no slashes, with arguments ARGV and environment from `environ'.  */
extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




/* Add INC to priority of the current process.  */
extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Terminate program execution with the low-order 8 bits of STATUS.  */
extern void _exit (int __status) __attribute__ ((__noreturn__));


/* Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';
   the `_SC_*' symbols for the NAME argument to `sysconf';
   and the `_CS_*' symbols for the NAME argument to `confstr'.  */
# 1 "/usr/include/bits/confname.h" 1 3 4
/* `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
   Copyright (C) 1993,1995-1998,2000,2001,2003,2004,2007,2009,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Values for the NAME argument to `pathconf' and `fpathconf'.  */
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };

/* Values for the argument to `sysconf'.  */
enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,


    /* Values for the argument to `sysconf'
       corresponding to _POSIX2_* symbols.  */
    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,


    /* Values according to POSIX 1003.1c (POSIX threads).  */
    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,

    /* Leave room here, maybe we need a few more cache levels some day.  */

    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };

/* Values for the NAME argument to `confstr'.  */
enum
  {
    _CS_PATH, /* The default search path.  */


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4

/* Get file-specific configuration information about PATH.  */
extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Get file-specific configuration about descriptor FD.  */
extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));

/* Get the value of the system variable NAME.  */
extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));


/* Get the value of the string-valued system variable NAME.  */
extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));



/* Get the process ID of the calling process.  */
extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));

/* Get the process ID of the calling process's parent.  */
extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));

/* Get the process group ID of the calling process.
   This function is different on old BSD. */

extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));
# 645 "/usr/include/unistd.h" 3 4
/* Get the process group ID of process PID.  */
extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



/* Set the process group ID of the process matching PID to PGID.
   If PID is zero, the current process's process group ID is set.
   If PGID is zero, the process ID of the process is used.  */
extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));


/* Both System V and BSD have `setpgrp' functions, but with different
   calling conventions.  The BSD function is the same as POSIX.1 `setpgid'
   (above).  The System V function takes no arguments and puts the calling
   process in its on group like `setpgid (0, 0)'.

   New programs should always use `setpgid' instead.

   The default in GNU is to provide the System V function.  The BSD
   function is available under -D_BSD_SOURCE.  */



/* Set the process group ID of the calling process to its own PID.
   This is exactly the same as `setpgid (0, 0)'.  */
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));
# 686 "/usr/include/unistd.h" 3 4
/* Create a new session with the calling process as its leader.
   The process group IDs of the session and the calling process
   are set to the process ID of the calling process, which is returned.  */
extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));


/* Return the session ID of the given process.  */
extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));


/* Get the real user ID of the calling process.  */
extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));

/* Get the effective user ID of the calling process.  */
extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));

/* Get the real group ID of the calling process.  */
extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));

/* Get the effective group ID of the calling process.  */
extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));

/* If SIZE is zero, return the number of supplementary groups
   the calling process is in.  Otherwise, fill in the group IDs
   of its supplementary groups in LIST and return the number written.  */
extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Return nonzero iff the calling process is in group GID.  */
extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));


/* Set the user ID of the calling process to UID.
   If the calling process is the super-user, set the real
   and effective user IDs, and the saved set-user-ID to UID;
   if not, the effective user ID is set to UID.  */
extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Set the real user ID of the calling process to RUID,
   and the effective user ID of the calling process to EUID.  */
extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Set the effective user ID of the calling process to UID.  */
extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Set the group ID of the calling process to GID.
   If the calling process is the super-user, set the real
   and effective group IDs, and the saved set-group-ID to GID;
   if not, the effective group ID is set to GID.  */
extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Set the real group ID of the calling process to RGID,
   and the effective group ID of the calling process to EGID.  */
extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Set the effective group ID of the calling process to GID.  */
extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Fetch the real user ID, effective user ID, and saved-set user ID,
   of the calling process.  */
extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));

/* Fetch the real group ID, effective group ID, and saved-set group ID,
   of the calling process.  */
extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));

/* Set the real user ID, effective user ID, and saved-set user ID,
   of the calling process to RUID, EUID, and SUID, respectively.  */
extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) ;

/* Set the real group ID, effective group ID, and saved-set group ID,
   of the calling process to RGID, EGID, and SGID, respectively.  */
extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) ;



/* Clone the calling process, creating an exact copy.
   Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  */
extern __pid_t fork (void) __attribute__ ((__nothrow__));



/* Clone the calling process, but without copying the whole address space.
   The calling process is suspended until the new process exits or is
   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  */
extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));



/* Return the pathname of the terminal FD is open on, or NULL on errors.
   The returned storage is good only until the next call to this function.  */
extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));

/* Store at most BUFLEN characters of the pathname of the terminal FD is
   open on in BUF.  Return 0 on success, otherwise an error number.  */
extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;

/* Return 1 if FD is a valid descriptor associated
   with a terminal, zero if not.  */
extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));



/* Return the index into the active-logins file (utmp) for
   the controlling terminal.  */
extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));



/* Make a link to FROM named TO.  */
extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;


/* Like link but relative paths in TO and FROM are interpreted relative
   to FROMFD and TOFD respectively.  */
extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;



/* Make a symbolic link to FROM named TO.  */
extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;

/* Read the contents of the symbolic link PATH into no more than
   LEN bytes of BUF.  The contents are not null-terminated.
   Returns the number of characters read, or -1 for errors.  */
extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;



/* Like symlink but a relative path in TO is interpreted relative to TOFD.  */
extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;

/* Like readlink but a relative PATH is interpreted relative to FD.  */
extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;


/* Remove the link NAME.  */
extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Remove the link NAME relative to FD.  */
extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


/* Remove the directory PATH.  */
extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return the foreground process group ID of FD.  */
extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));

/* Set the foreground process group ID of FD set PGRP_ID.  */
extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));


/* Return the login name of the user.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *getlogin (void);

/* Return at most NAME_LEN characters of the login name of the user in NAME.
   If it cannot be determined or some other error occurred, return the error
   code.  Otherwise return 0.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));



/* Set the login name returned by `getlogin'.  */
extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.  */

# 1 "/usr/include/getopt.h" 1 3 4
/* Declarations for getopt.
   Copyright (C) 1989-1994,1996-1999,2001,2003,2004,2009,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */







/* If __GNU_LIBRARY__ is not already defined, either we are being used
   standalone, or this is the first header included in the source file.
   If we are being used with glibc, we need to include <features.h>, but
   that does not exist if we are standalone.  So: if __GNU_LIBRARY__ is
   not defined, include <ctype.h>, which will pull in <features.h> for us
   if it's from glibc.  (Why ctype.h?  It's guaranteed to exist and it
   doesn't flood the namespace with stuff the way some other headers do.)  */
# 52 "/usr/include/getopt.h" 3 4
/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */

extern char *optarg;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns -1, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

extern int optind;

/* Callers store zero here to inhibit the error message `getopt' prints
   for unrecognized options.  */

extern int opterr;

/* Set to an option character which was unrecognized.  */

extern int optopt;
# 123 "/usr/include/getopt.h" 3 4
/* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.

   Return the option character from OPTS just read.  Return -1 when
   there are no more options.  For unrecognized options, or options
   missing arguments, `optopt' is set to the option letter, and '?' is
   returned.

   The OPTS string is a list of characters which are recognized option
   letters, optionally followed by colons, specifying that that letter
   takes an argument, to be placed in `optarg'.

   If a letter in OPTS is followed by two colons, its argument is
   optional.  This behavior is specific to the GNU `getopt'.

   The argument `--' causes premature termination of argument
   scanning, explicitly telling `getopt' that there are no more
   options.

   If OPTS begins with `--', then non-option arguments are treated as
   arguments to the option '\0'.  This behavior is specific to the GNU
   `getopt'.  */


/* Many other libraries have conflicting prototypes for getopt, with
   differences in the consts, in stdlib.h.  To avoid compilation
   errors, only prototype getopt for the GNU C library.  */
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__));
# 189 "/usr/include/getopt.h" 3 4
/* Make sure we later can get all the definitions and declarations.  */
# 894 "/usr/include/unistd.h" 2 3 4




/* Put the name of the current host in no more than LEN bytes of NAME.
   The result is null-terminated if LEN is large enough for the full
   name and the terminator.  */
extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Set the name of the current host to NAME, which is LEN bytes long.
   This call is restricted to the super-user.  */
extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

/* Set the current machine's Internet number to ID.
   This call is restricted to the super-user.  */
extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Get and set the NIS (aka YP) domain name, if any.
   Called just like `gethostname' and `sethostname'.
   The NIS domain name is usually the empty string when not using NIS.  */
extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;


/* Revoke access permissions to all processes currently communicating
   with the control terminal, and then send a SIGHUP signal to the process
   group of the control terminal.  */
extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));

/* Revoke the access of all descriptors currently open on FILE.  */
extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;


/* Enable statistical profiling, writing samples of the PC into at most
   SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling
   is enabled, the system examines the user PC and increments
   SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,
   disable profiling.  Returns zero on success, -1 on error.  */
extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Turn accounting on if NAME is an existing file.  The system will then write
   a record for each process as it terminates, to this file.  If NAME is NULL,
   turn accounting off.  This call is restricted to the super-user.  */
extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));


/* Successive calls return the shells listed in `/etc/shells'.  */
extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__)); /* Discard cached info.  */
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__)); /* Rewind and re-read the file.  */


/* Put the program in the background, and dissociate from the controlling
   terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,
   redirects stdin, stdout, and stderr to /dev/null.  */
extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;




/* Make PATH be the root directory (the starting point for absolute paths).
   This call is restricted to the super-user.  */
extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

/* Prompt with PROMPT and read a string from the terminal without echoing.
   Uses /dev/tty if possible; otherwise stderr and stdin.  */
extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));



/* Make all changes done to FD actually appear on disk.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int fsync (int __fd);



/* Make all changes done to all files on the file system associated
   with FD actually appear on disk.  */
extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));





/* Return identifier for the current host.  */
extern long int gethostid (void);

/* Make all changes done to all files actually appear on disk.  */
extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));



/* Return the number of bytes in a page.  This is the system's page size,
   which is not necessarily the same as the hardware page size.  */
extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Return the maximum number of file descriptors
   the current process could possibly have.  */
extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));







/* Truncate FILE to LENGTH bytes.  */

extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1027 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







/* Truncate the file FD is open on to LENGTH bytes.  */

extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1048 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1057 "/usr/include/unistd.h" 3 4
/* Set the end of accessible data space (aka "the break") to ADDR.
   Returns zero on success and -1 for errors (with errno set).  */
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;

/* Increase or decrease the end of accessible data space by DELTA bytes.
   If successful, returns the address the previous end of data space
   (i.e. the beginning of the new space, if DELTA > 0);
   returns (void *) -1 for errors (with errno set).  */
extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));




/* Invoke `system call' number SYSNO, passing it the remaining arguments.
   This is completely system-dependent, and not often useful.

   In Unix, `syscall' sets `errno' for all errors and most calls return -1
   for errors; in many systems you cannot pass arguments or get return
   values for all system calls (`pipe', `fork', and `getppid' typically
   among them).

   In Mach, all system calls take normal arguments and always return an
   error code (zero for success).  */
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1120 "/usr/include/unistd.h" 3 4
/* Evaluate EXPRESSION, and repeat as long as it returns -1 with `errno'
   set to EINTR.  */
# 1132 "/usr/include/unistd.h" 3 4
/* Synchronize at least the data part of a file with the underlying
   media.  */
extern int fdatasync (int __fildes);



/* XPG4.2 specifies that prototypes for the encryption functions must
   be defined here.  */

/* Encrypt at most 8 characters from KEY using salt to perturb DES.  */
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Encrypt data in BLOCK in place if EDFLAG is zero; otherwise decrypt
   block in place.  */
extern void encrypt (char *__block, int __edflag) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Swab pairs bytes in the first N bytes of the area pointed to by
   FROM and copy the result to TO.  The value of TO must not be in the
   range [FROM - N + 1, FROM - 1].  If N is odd the first byte in FROM
   is without partner.  */
extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



/* The Single Unix specification demands this prototype to be here.
   It is also found in <stdio.h>.  */






/* Define some macros helping to catch buffer overflows.  */





# 263 "src/exim.h" 2

# 1 "/usr/include/utime.h" 1 3 4
/* Copyright (C) 1991-1992,1996-1999,2004,2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 5.6.6 Set File Access and Modification Times  <utime.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/utime.h" 2 3 4



# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 30 "/usr/include/utime.h" 2 3 4



# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 34 "/usr/include/utime.h" 2 3 4


/* Structure describing file times.  */
struct utimbuf
  {
    __time_t actime; /* Access time.  */
    __time_t modtime; /* Modification time.  */
  };

/* Set the access and modification times of FILE to those given in
   *FILE_TIMES.  If FILE_TIMES is NULL, set them to the current time.  */
extern int utime (const char *__file,
    const struct utimbuf *__file_times)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 265 "src/exim.h" 2

# 1 "/usr/include/net/if.h" 1 3 4
/* net/if.h -- declarations for inquiring about network interfaces
   Copyright (C) 1997,98,99,2000,2001,2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/net/if.h" 2 3 4


# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 26 "/usr/include/net/if.h" 2 3 4
# 1 "/usr/include/sys/socket.h" 1 3 4
/* Declarations of socket constants, types, and functions.
   Copyright (C) 1991,92,1994-2001,2003,2005,2007,2008,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/net/if.h" 2 3 4



/* Length of interface name.  */


struct if_nameindex
  {
    unsigned int if_index; /* 1, 2, ... */
    char *if_name; /* null terminated name: "eth0", ... */
  };



/* Standard interface flags. */
enum
  {
    IFF_UP = 0x1, /* Interface is up.  */

    IFF_BROADCAST = 0x2, /* Broadcast address valid.  */

    IFF_DEBUG = 0x4, /* Turn on debugging.  */

    IFF_LOOPBACK = 0x8, /* Is a loopback net.  */

    IFF_POINTOPOINT = 0x10, /* Interface is point-to-point link.  */

    IFF_NOTRAILERS = 0x20, /* Avoid use of trailers.  */

    IFF_RUNNING = 0x40, /* Resources allocated.  */

    IFF_NOARP = 0x80, /* No address resolution protocol.  */

    IFF_PROMISC = 0x100, /* Receive all packets.  */


    /* Not supported */
    IFF_ALLMULTI = 0x200, /* Receive all multicast packets.  */


    IFF_MASTER = 0x400, /* Master of a load balancer.  */

    IFF_SLAVE = 0x800, /* Slave of a load balancer.  */


    IFF_MULTICAST = 0x1000, /* Supports multicast.  */


    IFF_PORTSEL = 0x2000, /* Can set media type.  */

    IFF_AUTOMEDIA = 0x4000, /* Auto media select active.  */

    IFF_DYNAMIC = 0x8000 /* Dialup device with changing addresses.  */

  };

/* The ifaddr structure contains information about one address of an
   interface.  They are maintained by the different address families,
   are allocated and attached when an address is set, and are linked
   together so all addresses for an interface can be located.  */

struct ifaddr
  {
    struct sockaddr ifa_addr; /* Address of interface.  */
    union
      {
 struct sockaddr ifu_broadaddr;
 struct sockaddr ifu_dstaddr;
      } ifa_ifu;
    struct iface *ifa_ifp; /* Back-pointer to interface.  */
    struct ifaddr *ifa_next; /* Next address for interface.  */
  };




/* Device mapping structure. I'd just gone off and designed a
   beautiful scheme using only loadable modules with arguments for
   driver options and along come the PCMCIA people 8)

   Ah well. The get() side of this is good for WDSETUP, and it'll be
   handy for debugging things. The set side is fine for now and being
   very small might be worth keeping for clean configuration.  */

struct ifmap
  {
    unsigned long int mem_start;
    unsigned long int mem_end;
    unsigned short int base_addr;
    unsigned char irq;
    unsigned char dma;
    unsigned char port;
    /* 3 bytes spare */
  };

/* Interface request structure used for socket ioctl's.  All interface
   ioctl's must have parameter definitions which begin with ifr_name.
   The remainder may be interface specific.  */

struct ifreq
  {


    union
      {
 char ifrn_name[16]; /* Interface name, e.g. "en0".  */
      } ifr_ifrn;

    union
      {
 struct sockaddr ifru_addr;
 struct sockaddr ifru_dstaddr;
 struct sockaddr ifru_broadaddr;
 struct sockaddr ifru_netmask;
 struct sockaddr ifru_hwaddr;
 short int ifru_flags;
 int ifru_ivalue;
 int ifru_mtu;
 struct ifmap ifru_map;
 char ifru_slave[16]; /* Just fits the size */
 char ifru_newname[16];
 __caddr_t ifru_data;
      } ifr_ifru;
  };
# 172 "/usr/include/net/if.h" 3 4
/* Structure used in SIOCGIFCONF request.  Used to retrieve interface
   configuration for machine (useful for programs which must know all
   networks accessible).  */

struct ifconf
  {
    int ifc_len; /* Size of buffer.  */
    union
      {
 __caddr_t ifcu_buf;
 struct ifreq *ifcu_req;
      } ifc_ifcu;
  };







/* Convert an interface name to an index, and vice versa.  */
extern unsigned int if_nametoindex (const char *__ifname) __attribute__ ((__nothrow__ , __leaf__));
extern char *if_indextoname (unsigned int __ifindex, char *__ifname) __attribute__ ((__nothrow__ , __leaf__));

/* Return a list of all interfaces and their indices.  */
extern struct if_nameindex *if_nameindex (void) __attribute__ ((__nothrow__ , __leaf__));

/* Free the data returned from if_nameindex.  */
extern void if_freenameindex (struct if_nameindex *__ptr) __attribute__ ((__nothrow__ , __leaf__));


# 267 "src/exim.h" 2

# 1 "/usr/include/sys/un.h" 1 3 4
/* Copyright (C) 1991, 1995, 1996, 2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/sys/cdefs.h" 1 3 4
/* Copyright (C) 1992-2002, 2004, 2005, 2006, 2007, 2009, 2011, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/sys/un.h" 2 3 4

/* Get the definition of the macro to define the common sockaddr members.  */
# 1 "/usr/include/bits/sockaddr.h" 1 3 4
/* Definition of `struct sockaddr_*' common members.  Generic/4.2 BSD version.
   Copyright (C) 1995,1996,1997,1998,2000,2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/socket.h> instead.
 */
# 25 "/usr/include/sys/un.h" 2 3 4



/* Structure describing the address of an AF_LOCAL (aka AF_UNIX) socket.  */
struct sockaddr_un
  {
    sa_family_t sun_family;
    char sun_path[108]; /* Path name.  */
  };



# 1 "/usr/include/string.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.21 String handling	<string.h>
 */
# 38 "/usr/include/sys/un.h" 2 3 4

/* Evaluate to actual length of the `sockaddr_un' structure.  */





# 269 "src/exim.h" 2
# 1 "/usr/include/netinet/in.h" 1 3 4
/* Copyright (C) 1991-2001, 2003, 2004, 2006, 2007, 2008, 2011, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 270 "src/exim.h" 2
# 1 "/usr/include/netinet/tcp.h" 1 3 4
/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)tcp.h	8.1 (Berkeley) 6/10/93
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 36 "/usr/include/netinet/tcp.h" 2 3 4

/*
 * User-settable options (used with setsockopt).
 */
# 65 "/usr/include/netinet/tcp.h" 3 4
# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 66 "/usr/include/netinet/tcp.h" 2 3 4
# 1 "/usr/include/sys/socket.h" 1 3 4
/* Declarations of socket constants, types, and functions.
   Copyright (C) 1991,92,1994-2001,2003,2005,2007,2008,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 67 "/usr/include/netinet/tcp.h" 2 3 4
# 101 "/usr/include/netinet/tcp.h" 3 4
struct tcphdr
  {
    u_int16_t source;
    u_int16_t dest;
    u_int32_t seq;
    u_int32_t ack_seq;

    u_int16_t res1:4;
    u_int16_t doff:4;
    u_int16_t fin:1;
    u_int16_t syn:1;
    u_int16_t rst:1;
    u_int16_t psh:1;
    u_int16_t ack:1;
    u_int16_t urg:1;
    u_int16_t res2:2;
# 130 "/usr/include/netinet/tcp.h" 3 4
    u_int16_t window;
    u_int16_t check;
    u_int16_t urg_ptr;
};


enum
{
  TCP_ESTABLISHED = 1,
  TCP_SYN_SENT,
  TCP_SYN_RECV,
  TCP_FIN_WAIT1,
  TCP_FIN_WAIT2,
  TCP_TIME_WAIT,
  TCP_CLOSE,
  TCP_CLOSE_WAIT,
  TCP_LAST_ACK,
  TCP_LISTEN,
  TCP_CLOSING /* now a valid state */
};
# 167 "/usr/include/netinet/tcp.h" 3 4
/*
 * Default maximum segment size for TCP.
 * With an IP MSS of 576, this is 536,
 * but 512 is probably more convenient.
 * This should be defined as MIN(512, IP_MSS - sizeof (struct tcpiphdr)).
 */
# 189 "/usr/include/netinet/tcp.h" 3 4
/* Values for tcpi_state.  */
enum tcp_ca_state
{
  TCP_CA_Open = 0,
  TCP_CA_Disorder = 1,
  TCP_CA_CWR = 2,
  TCP_CA_Recovery = 3,
  TCP_CA_Loss = 4
};

struct tcp_info
{
  u_int8_t tcpi_state;
  u_int8_t tcpi_ca_state;
  u_int8_t tcpi_retransmits;
  u_int8_t tcpi_probes;
  u_int8_t tcpi_backoff;
  u_int8_t tcpi_options;
  u_int8_t tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;

  u_int32_t tcpi_rto;
  u_int32_t tcpi_ato;
  u_int32_t tcpi_snd_mss;
  u_int32_t tcpi_rcv_mss;

  u_int32_t tcpi_unacked;
  u_int32_t tcpi_sacked;
  u_int32_t tcpi_lost;
  u_int32_t tcpi_retrans;
  u_int32_t tcpi_fackets;

  /* Times. */
  u_int32_t tcpi_last_data_sent;
  u_int32_t tcpi_last_ack_sent; /* Not remembered, sorry.  */
  u_int32_t tcpi_last_data_recv;
  u_int32_t tcpi_last_ack_recv;

  /* Metrics. */
  u_int32_t tcpi_pmtu;
  u_int32_t tcpi_rcv_ssthresh;
  u_int32_t tcpi_rtt;
  u_int32_t tcpi_rttvar;
  u_int32_t tcpi_snd_ssthresh;
  u_int32_t tcpi_snd_cwnd;
  u_int32_t tcpi_advmss;
  u_int32_t tcpi_reordering;

  u_int32_t tcpi_rcv_rtt;
  u_int32_t tcpi_rcv_space;

  u_int32_t tcpi_total_retrans;
};


/* For TCP_MD5SIG socket option.  */


struct tcp_md5sig
{
  struct sockaddr_storage tcpm_addr; /* Address associated.  */
  u_int16_t __tcpm_pad1; /* Zero.  */
  u_int16_t tcpm_keylen; /* Key length.  */
  u_int32_t __tcpm_pad2; /* Zero.  */
  u_int8_t tcpm_key[80]; /* Key (binary).  */
};

/* For socket repair options.  */
struct tcp_repair_opt
{
  u_int32_t opt_code;
  u_int32_t opt_val;
};

/* Queue to repair, for TCP_REPAIR_QUEUE.  */
enum
{
  TCP_NO_QUEUE,
  TCP_RECV_QUEUE,
  TCP_SEND_QUEUE,
  TCP_QUEUES_NR,
};

/* For cookie transactions socket options.  */




/* Flags for both getsockopt and setsockopt */




/* Flags for getsockopt */






struct tcp_cookie_transactions
{
  u_int16_t tcpct_flags;
  u_int8_t __tcpct_pad1;
  u_int8_t tcpct_cookie_desired;
  u_int16_t tcpct_s_data_desired;
  u_int16_t tcpct_used;
  u_int8_t tcpct_value[536U];
};
# 271 "src/exim.h" 2
# 1 "/usr/include/arpa/inet.h" 1 3 4
/* Copyright (C) 1997, 1999-2001, 2004, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/arpa/inet.h" 2 3 4
# 1 "/usr/include/netinet/in.h" 1 3 4
/* Copyright (C) 1991-2001, 2003, 2004, 2006, 2007, 2008, 2011, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/arpa/inet.h" 2 3 4

/* Type for length arguments in socket calls.  */







/* Convert Internet host address from numbers-and-dots notation in CP
   into binary data in network byte order.  */
extern in_addr_t inet_addr (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));

/* Return the local host address part of the Internet address in IN.  */
extern in_addr_t inet_lnaof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));

/* Make Internet host address in network byte order by combining the
   network number NET with the local address HOST.  */
extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
     __attribute__ ((__nothrow__ , __leaf__));

/* Return network number part of the Internet address IN.  */
extern in_addr_t inet_netof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));

/* Extract the network number in network byte order from the address
   in numbers-and-dots natation starting at CP.  */
extern in_addr_t inet_network (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));

/* Convert Internet number in IN to ASCII representation.  The return value
   is a pointer to an internal array containing the string.  */
extern char *inet_ntoa (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));

/* Convert from presentation format of an Internet number in buffer
   starting at CP to the binary network format and store result for
   interface type AF in buffer starting at BUF.  */
extern int inet_pton (int __af, const char *__restrict __cp,
        void *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));

/* Convert a Internet address in binary network format for interface
   type AF in buffer starting at CP to presentation form and place
   result in buffer of length LEN astarting at BUF.  */
extern const char *inet_ntop (int __af, const void *__restrict __cp,
         char *__restrict __buf, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));


/* The following functions are not part of XNS 5.2.  */

/* Convert Internet host address from numbers-and-dots notation in CP
   into binary data and store the result in the structure INP.  */
extern int inet_aton (const char *__cp, struct in_addr *__inp) __attribute__ ((__nothrow__ , __leaf__));

/* Format a network number NET into presentation format and place result
   in buffer starting at BUF with length of LEN bytes.  */
extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));

/* Convert network number for interface type AF in buffer starting at
   CP to presentation format.  The result will specifiy BITS bits of
   the number.  */
extern char *inet_net_ntop (int __af, const void *__cp, int __bits,
       char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));

/* Convert network number for interface type AF from presentation in
   buffer starting at CP to network format and store result int
   buffer starting at BUF of size LEN.  */
extern int inet_net_pton (int __af, const char *__cp,
     void *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));

/* Convert ASCII representation in hexadecimal form of the Internet
   address to binary form and place result in buffer of length LEN
   starting at BUF.  */
extern unsigned int inet_nsap_addr (const char *__cp,
        unsigned char *__buf, int __len) __attribute__ ((__nothrow__ , __leaf__));

/* Convert internet address in binary form in LEN bytes starting at CP
   a presentation form and place result in BUF.  */
extern char *inet_nsap_ntoa (int __len, const unsigned char *__cp,
        char *__buf) __attribute__ ((__nothrow__ , __leaf__));



# 272 "src/exim.h" 2
# 1 "/usr/include/arpa/nameser.h" 1 3 4
/*
 * Copyright (c) 1983, 1989, 1993
 *    The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
 * Copyright (c) 1996-1999 by Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/*
 *	$BINDId: nameser.h,v 8.37 2000/03/30 21:16:49 vixie Exp $
 */




/*! \file */



# 1 "/usr/include/sys/param.h" 1 3 4
/* Compatibility header for old-style Unix parameters and limits.
   Copyright (C) 1995-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 60 "/usr/include/arpa/nameser.h" 2 3 4

# 1 "/usr/include/sys/bitypes.h" 1 3 4
/* The GNU <sys/types.h> defines all the necessary types.  */

# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 3 "/usr/include/sys/bitypes.h" 2 3 4
# 62 "/usr/include/arpa/nameser.h" 2 3 4



# 1 "/usr/include/sys/cdefs.h" 1 3 4
/* Copyright (C) 1992-2002, 2004, 2005, 2006, 2007, 2009, 2011, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 66 "/usr/include/arpa/nameser.h" 2 3 4

/*%
 * Revision information.  This is the release date in YYYYMMDD format.
 * It can change every day so the right thing to do with it is use it
 * in preprocessor commands such as "#if (__NAMESER > 19931104)".  Do not
 * compare for equality; rather, use it to determine whether your libbind.a
 * contains a new enough lib/nameser/ to support the feature you need.
 */


/*
 * Define constants based on RFC 883, RFC 1034, RFC 1035
 */
# 94 "/usr/include/arpa/nameser.h" 3 4
/*
 * These can be expanded with synonyms, just keep ns_parse.c:ns_parserecord()
 * in synch with it.
 */
typedef enum __ns_sect {
 ns_s_qd = 0, /*%< Query: Question. */
 ns_s_zn = 0, /*%< Update: Zone. */
 ns_s_an = 1, /*%< Query: Answer. */
 ns_s_pr = 1, /*%< Update: Prerequisites. */
 ns_s_ns = 2, /*%< Query: Name servers. */
 ns_s_ud = 2, /*%< Update: Update. */
 ns_s_ar = 3, /*%< Query|Update: Additional records. */
 ns_s_max = 4
} ns_sect;

/*%
 * This is a message handle.  It is caller allocated and has no dynamic data.
 * This structure is intended to be opaque to all but ns_parse.c, thus the
 * leading _'s on the member names.  Use the accessor functions, not the _'s.
 */
typedef struct __ns_msg {
 const u_char *_msg, *_eom;
 u_int16_t _id, _flags, _counts[ns_s_max];
 const u_char *_sections[ns_s_max];
 ns_sect _sect;
 int _rrnum;
 const u_char *_msg_ptr;
} ns_msg;

/* Private data structure - do not use from outside library. */
struct _ns_flagdata { int mask, shift; };
extern const struct _ns_flagdata _ns_flagdata[];

/* Accessor macros - this is part of the public interface. */







/*%
 * This is a parsed record.  It is caller allocated and has no dynamic data.
 */
typedef struct __ns_rr {
 char name[1025];
 u_int16_t type;
 u_int16_t rr_class;
 u_int32_t ttl;
 u_int16_t rdlength;
 const u_char * rdata;
} ns_rr;

/* Accessor macros - this is part of the public interface. */







/*%
 * These don't have to be in the same order as in the packet flags word,
 * and they can even overlap in some cases, but they will need to be kept
 * in synch with ns_parse.c:ns_flagdata[].
 */
typedef enum __ns_flag {
 ns_f_qr, /*%< Question/Response. */
 ns_f_opcode, /*%< Operation code. */
 ns_f_aa, /*%< Authoritative Answer. */
 ns_f_tc, /*%< Truncation occurred. */
 ns_f_rd, /*%< Recursion Desired. */
 ns_f_ra, /*%< Recursion Available. */
 ns_f_z, /*%< MBZ. */
 ns_f_ad, /*%< Authentic Data (DNSSEC). */
 ns_f_cd, /*%< Checking Disabled (DNSSEC). */
 ns_f_rcode, /*%< Response code. */
 ns_f_max
} ns_flag;

/*%
 * Currently defined opcodes.
 */
typedef enum __ns_opcode {
 ns_o_query = 0, /*%< Standard query. */
 ns_o_iquery = 1, /*%< Inverse query (deprecated/unsupported). */
 ns_o_status = 2, /*%< Name server status query (unsupported). */
    /* Opcode 3 is undefined/reserved. */
 ns_o_notify = 4, /*%< Zone change notification. */
 ns_o_update = 5, /*%< Zone update message. */
 ns_o_max = 6
} ns_opcode;

/*%
 * Currently defined response codes.
 */
typedef enum __ns_rcode {
 ns_r_noerror = 0, /*%< No error occurred. */
 ns_r_formerr = 1, /*%< Format error. */
 ns_r_servfail = 2, /*%< Server failure. */
 ns_r_nxdomain = 3, /*%< Name error. */
 ns_r_notimpl = 4, /*%< Unimplemented. */
 ns_r_refused = 5, /*%< Operation refused. */
 /* these are for BIND_UPDATE */
 ns_r_yxdomain = 6, /*%< Name exists */
 ns_r_yxrrset = 7, /*%< RRset exists */
 ns_r_nxrrset = 8, /*%< RRset does not exist */
 ns_r_notauth = 9, /*%< Not authoritative for zone */
 ns_r_notzone = 10, /*%< Zone of record different from zone section */
 ns_r_max = 11,
 /* The following are EDNS extended rcodes */
 ns_r_badvers = 16,
 /* The following are TSIG errors */
 ns_r_badsig = 16,
 ns_r_badkey = 17,
 ns_r_badtime = 18
} ns_rcode;

/* BIND_UPDATE */
typedef enum __ns_update_operation {
 ns_uop_delete = 0,
 ns_uop_add = 1,
 ns_uop_max = 2
} ns_update_operation;

/*%
 * This structure is used for TSIG authenticated messages
 */
struct ns_tsig_key {
        char name[1025], alg[1025];
        unsigned char *data;
        int len;
};
typedef struct ns_tsig_key ns_tsig_key;

/*%
 * This structure is used for TSIG authenticated TCP messages
 */
struct ns_tcp_tsig_state {
 int counter;
 struct dst_key *key;
 void *ctx;
 unsigned char sig[512];
 int siglen;
};
typedef struct ns_tcp_tsig_state ns_tcp_tsig_state;
# 249 "/usr/include/arpa/nameser.h" 3 4
/*%
 * Currently defined type values for resources and queries.
 */
typedef enum __ns_type {
 ns_t_invalid = 0, /*%< Cookie. */
 ns_t_a = 1, /*%< Host address. */
 ns_t_ns = 2, /*%< Authoritative server. */
 ns_t_md = 3, /*%< Mail destination. */
 ns_t_mf = 4, /*%< Mail forwarder. */
 ns_t_cname = 5, /*%< Canonical name. */
 ns_t_soa = 6, /*%< Start of authority zone. */
 ns_t_mb = 7, /*%< Mailbox domain name. */
 ns_t_mg = 8, /*%< Mail group member. */
 ns_t_mr = 9, /*%< Mail rename name. */
 ns_t_null = 10, /*%< Null resource record. */
 ns_t_wks = 11, /*%< Well known service. */
 ns_t_ptr = 12, /*%< Domain name pointer. */
 ns_t_hinfo = 13, /*%< Host information. */
 ns_t_minfo = 14, /*%< Mailbox information. */
 ns_t_mx = 15, /*%< Mail routing information. */
 ns_t_txt = 16, /*%< Text strings. */
 ns_t_rp = 17, /*%< Responsible person. */
 ns_t_afsdb = 18, /*%< AFS cell database. */
 ns_t_x25 = 19, /*%< X_25 calling address. */
 ns_t_isdn = 20, /*%< ISDN calling address. */
 ns_t_rt = 21, /*%< Router. */
 ns_t_nsap = 22, /*%< NSAP address. */
 ns_t_nsap_ptr = 23, /*%< Reverse NSAP lookup (deprecated). */
 ns_t_sig = 24, /*%< Security signature. */
 ns_t_key = 25, /*%< Security key. */
 ns_t_px = 26, /*%< X.400 mail mapping. */
 ns_t_gpos = 27, /*%< Geographical position (withdrawn). */
 ns_t_aaaa = 28, /*%< Ip6 Address. */
 ns_t_loc = 29, /*%< Location Information. */
 ns_t_nxt = 30, /*%< Next domain (security). */
 ns_t_eid = 31, /*%< Endpoint identifier. */
 ns_t_nimloc = 32, /*%< Nimrod Locator. */
 ns_t_srv = 33, /*%< Server Selection. */
 ns_t_atma = 34, /*%< ATM Address */
 ns_t_naptr = 35, /*%< Naming Authority PoinTeR */
 ns_t_kx = 36, /*%< Key Exchange */
 ns_t_cert = 37, /*%< Certification record */
 ns_t_a6 = 38, /*%< IPv6 address (deprecated, use ns_t_aaaa) */
 ns_t_dname = 39, /*%< Non-terminal DNAME (for IPv6) */
 ns_t_sink = 40, /*%< Kitchen sink (experimentatl) */
 ns_t_opt = 41, /*%< EDNS0 option (meta-RR) */
 ns_t_apl = 42, /*%< Address prefix list (RFC3123) */
 ns_t_tkey = 249, /*%< Transaction key */
 ns_t_tsig = 250, /*%< Transaction signature. */
 ns_t_ixfr = 251, /*%< Incremental zone transfer. */
 ns_t_axfr = 252, /*%< Transfer zone of authority. */
 ns_t_mailb = 253, /*%< Transfer mailbox records. */
 ns_t_maila = 254, /*%< Transfer mail agent records. */
 ns_t_any = 255, /*%< Wildcard match. */
 ns_t_zxfr = 256, /*%< BIND-specific, nonstandard. */
 ns_t_max = 65536
} ns_type;

/* Exclusively a QTYPE? (not also an RTYPE) */


/* Some kind of meta-RR? (not a QTYPE, but also not an RTYPE) */

/* Exclusively an RTYPE? (not also a QTYPE or a meta-RR) */





/*%
 * Values for class field
 */
typedef enum __ns_class {
 ns_c_invalid = 0, /*%< Cookie. */
 ns_c_in = 1, /*%< Internet. */
 ns_c_2 = 2, /*%< unallocated/unsupported. */
 ns_c_chaos = 3, /*%< MIT Chaos-net. */
 ns_c_hs = 4, /*%< MIT Hesiod. */
 /* Query class values which do not appear in resource records */
 ns_c_none = 254, /*%< for prereq. sections in update requests */
 ns_c_any = 255, /*%< Wildcard match. */
 ns_c_max = 65536
} ns_class;

/* DNSSEC constants. */

typedef enum __ns_key_types {
 ns_kt_rsa = 1, /*%< key type RSA/MD5 */
 ns_kt_dh = 2, /*%< Diffie Hellman */
 ns_kt_dsa = 3, /*%< Digital Signature Standard (MANDATORY) */
 ns_kt_private = 254 /*%< Private key type starts with OID */
} ns_key_types;

typedef enum __ns_cert_types {
 cert_t_pkix = 1, /*%< PKIX (X.509v3) */
 cert_t_spki = 2, /*%< SPKI */
 cert_t_pgp = 3, /*%< PGP */
 cert_t_url = 253, /*%< URL private type */
 cert_t_oid = 254 /*%< OID private type */
} ns_cert_types;

/* Flags field of the KEY RR rdata. */





/* The type bits can also be interpreted independently, as single bits: */
# 381 "/usr/include/arpa/nameser.h" 3 4
/* The Algorithm field of the KEY and SIG RR's is an integer, {1..254} */






/* Protocol values  */
/* value 0 is reserved */






/* Signatures */


 /* Total of binary mod and exp */

 /* Max length of text sig block */
# 410 "/usr/include/arpa/nameser.h" 3 4
/* Offsets into SIG record rdata to find various values */
# 419 "/usr/include/arpa/nameser.h" 3 4
/* How RR types are represented as bit-flags in NXT records */






/*%
 * EDNS0 extended flags and option codes, host order.
 */



/*%
 * Inline versions of get/put short/long.  Pointer is advanced.
 */
# 471 "/usr/include/arpa/nameser.h" 3 4

int ns_msg_getflag (ns_msg, int) __attribute__ ((__nothrow__ , __leaf__));
u_int ns_get16 (const u_char *) __attribute__ ((__nothrow__ , __leaf__));
u_long ns_get32 (const u_char *) __attribute__ ((__nothrow__ , __leaf__));
void ns_put16 (u_int, u_char *) __attribute__ ((__nothrow__ , __leaf__));
void ns_put32 (u_long, u_char *) __attribute__ ((__nothrow__ , __leaf__));
int ns_initparse (const u_char *, int, ns_msg *) __attribute__ ((__nothrow__ , __leaf__));
int ns_skiprr (const u_char *, const u_char *, ns_sect, int)
     __attribute__ ((__nothrow__ , __leaf__));
int ns_parserr (ns_msg *, ns_sect, int, ns_rr *) __attribute__ ((__nothrow__ , __leaf__));
int ns_sprintrr (const ns_msg *, const ns_rr *,
        const char *, const char *, char *, size_t)
     __attribute__ ((__nothrow__ , __leaf__));
int ns_sprintrrf (const u_char *, size_t, const char *,
         ns_class, ns_type, u_long, const u_char *,
         size_t, const char *, const char *,
         char *, size_t) __attribute__ ((__nothrow__ , __leaf__));
int ns_format_ttl (u_long, char *, size_t) __attribute__ ((__nothrow__ , __leaf__));
int ns_parse_ttl (const char *, u_long *) __attribute__ ((__nothrow__ , __leaf__));
u_int32_t ns_datetosecs (const char *, int *) __attribute__ ((__nothrow__ , __leaf__));
int ns_name_ntol (const u_char *, u_char *, size_t) __attribute__ ((__nothrow__ , __leaf__));
int ns_name_ntop (const u_char *, char *, size_t) __attribute__ ((__nothrow__ , __leaf__));
int ns_name_pton (const char *, u_char *, size_t) __attribute__ ((__nothrow__ , __leaf__));
int ns_name_unpack (const u_char *, const u_char *,
    const u_char *, u_char *, size_t) __attribute__ ((__nothrow__ , __leaf__));
int ns_name_pack (const u_char *, u_char *, int,
         const u_char **, const u_char **) __attribute__ ((__nothrow__ , __leaf__));
int ns_name_uncompress (const u_char *, const u_char *,
        const u_char *, char *, size_t) __attribute__ ((__nothrow__ , __leaf__));
int ns_name_compress (const char *, u_char *, size_t,
      const u_char **, const u_char **) __attribute__ ((__nothrow__ , __leaf__));
int ns_name_skip (const u_char **, const u_char *) __attribute__ ((__nothrow__ , __leaf__));
void ns_name_rollback (const u_char *, const u_char **,
      const u_char **) __attribute__ ((__nothrow__ , __leaf__));
int ns_sign (u_char *, int *, int, int, void *,
    const u_char *, int, u_char *, int *, time_t) __attribute__ ((__nothrow__ , __leaf__));
int ns_sign2 (u_char *, int *, int, int, void *,
     const u_char *, int, u_char *, int *, time_t,
     u_char **, u_char **) __attribute__ ((__nothrow__ , __leaf__));
int ns_sign_tcp (u_char *, int *, int, int,
        ns_tcp_tsig_state *, int) __attribute__ ((__nothrow__ , __leaf__));
int ns_sign_tcp2 (u_char *, int *, int, int,
         ns_tcp_tsig_state *, int,
         u_char **, u_char **) __attribute__ ((__nothrow__ , __leaf__));
int ns_sign_tcp_init (void *, const u_char *, int,
      ns_tcp_tsig_state *) __attribute__ ((__nothrow__ , __leaf__));
u_char *ns_find_tsig (u_char *, u_char *) __attribute__ ((__nothrow__ , __leaf__));
int ns_verify (u_char *, int *, void *, const u_char *, int,
      u_char *, int *, time_t *, int) __attribute__ ((__nothrow__ , __leaf__));
int ns_verify_tcp (u_char *, int *, ns_tcp_tsig_state *, int)
     __attribute__ ((__nothrow__ , __leaf__));
int ns_verify_tcp_init (void *, const u_char *, int,
        ns_tcp_tsig_state *) __attribute__ ((__nothrow__ , __leaf__));
int ns_samedomain (const char *, const char *) __attribute__ ((__nothrow__ , __leaf__));
int ns_subdomain (const char *, const char *) __attribute__ ((__nothrow__ , __leaf__));
int ns_makecanon (const char *, char *, size_t) __attribute__ ((__nothrow__ , __leaf__));
int ns_samename (const char *, const char *) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/arpa/nameser_compat.h" 1 3 4
/* Copyright (c) 1983, 1989
 *    The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*%
 *      from nameser.h	8.1 (Berkeley) 6/2/93
 *	$BINDId: nameser_compat.h,v 8.11 1999/01/02 08:00:58 vixie Exp $
 */






# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 40 "/usr/include/arpa/nameser_compat.h" 2 3 4

/*%
 * Structure for query header.  The order of the fields is machine- and
 * compiler-dependent, depending on the byte/bit order and the layout
 * of bit fields.  We use bit fields only in int variables, as this
 * is all ANSI requires.  This requires a somewhat confusing rearrangement.
 */

typedef struct {
 unsigned id :16; /*%< query identification number */
# 65 "/usr/include/arpa/nameser_compat.h" 3 4
   /* fields in third byte */
 unsigned rd :1; /*%< recursion desired */
 unsigned tc :1; /*%< truncated message */
 unsigned aa :1; /*%< authoritive answer */
 unsigned opcode :4; /*%< purpose of message */
 unsigned qr :1; /*%< response flag */
   /* fields in fourth byte */
 unsigned rcode :4; /*%< response code */
 unsigned cd: 1; /*%< checking disabled by resolver */
 unsigned ad: 1; /*%< authentic data from named */
 unsigned unused :1; /*%< unused bits (MBZ as of 4.9.3a3) */
 unsigned ra :1; /*%< recursion available */

   /* remaining bytes */
 unsigned qdcount :16; /*%< number of question entries */
 unsigned ancount :16; /*%< number of answer entries */
 unsigned nscount :16; /*%< number of authority entries */
 unsigned arcount :16; /*%< number of resource entries */
} HEADER;
# 122 "/usr/include/arpa/nameser_compat.h" 3 4
/*#define BADSIG		ns_r_badsig*/
/*#define BADKEY		ns_r_badkey*/
/*#define BADTIME		ns_r_badtime*/
# 177 "/usr/include/arpa/nameser_compat.h" 3 4
/* BIND_UPDATE */
# 187 "/usr/include/arpa/nameser_compat.h" 3 4
/*! \file */
# 532 "/usr/include/arpa/nameser.h" 2 3 4



/*! \file */
# 273 "src/exim.h" 2


/* If arpa/nameser.h defines a maximum name server packet size, use it,
provided it is greater than 2048. Otherwise go for a default. PACKETSZ was used
for this, but it seems that NS_PACKETSZ is coming into use. */
# 287 "src/exim.h"
/* While IPv6 is still young the definitions of T_AAAA and T_A6 may not be
included in arpa/nameser.h. Fudge them here. */
# 298 "src/exim.h"
/* Ancient systems (e.g. SunOS4) don't appear to have T_TXT defined in their
header files. I don't suppose they have T_SRV either. */
# 309 "src/exim.h"
/* Many systems do not have T_SPF. */





/* It seems that some versions of arpa/nameser.h don't define *any* of the
T_xxx macros, which seem to be non-standard nowadays. Just to be on the safe
side, put in definitions for all the ones that Exim uses. */
# 344 "src/exim.h"
/* We define a few private types for special DNS lookups:

 . T_ZNS gets the nameservers of the enclosing zone of a domain

 . T_MXH gets the MX hostnames only (without their priorities)

 . T_CSA gets the domain's Client SMTP Authorization SRV record

*/





/* The resolv.h header defines __P(x) on some Solaris 2.5.1 systems (without
checking that it is already defined, in fact). This conflicts with other
headers that behave likewise (see below), leading to compiler warnings. Arrange
to undefine it if resolv.h defines it. */





# 1 "/usr/include/resolv.h" 1 3 4
/*
 * Copyright (c) 1983, 1987, 1989
 *    The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Portions Copyright (c) 1996-1999 by Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/*
 *	@(#)resolv.h	8.1 (Berkeley) 6/2/93
 *	$BINDId: resolv.h,v 8.31 2000/03/30 20:16:50 vixie Exp $
 */



/* These headers are needed for types used in the `struct res_state'
   declaration.  */
# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 57 "/usr/include/resolv.h" 2 3 4
# 1 "/usr/include/netinet/in.h" 1 3 4
/* Copyright (C) 1991-2001, 2003, 2004, 2006, 2007, 2008, 2011, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 58 "/usr/include/resolv.h" 2 3 4




# 1 "/usr/include/sys/param.h" 1 3 4
/* Compatibility header for old-style Unix parameters and limits.
   Copyright (C) 1995-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 63 "/usr/include/resolv.h" 2 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
/* Copyright (C) 1992-2002, 2004, 2005, 2006, 2007, 2009, 2011, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 64 "/usr/include/resolv.h" 2 3 4
# 1 "/usr/include/stdio.h" 1 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991, 1994-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */
# 65 "/usr/include/resolv.h" 2 3 4
# 1 "/usr/include/arpa/nameser.h" 1 3 4
/*
 * Copyright (c) 1983, 1989, 1993
 *    The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
 * Copyright (c) 1996-1999 by Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/*
 *	$BINDId: nameser.h,v 8.37 2000/03/30 21:16:49 vixie Exp $
 */
# 535 "/usr/include/arpa/nameser.h" 3 4
/*! \file */
# 66 "/usr/include/resolv.h" 2 3 4





typedef enum { res_goahead, res_nextns, res_modified, res_done, res_error }
 res_sendhookact;

typedef res_sendhookact (*res_send_qhook) (struct sockaddr_in * const *__ns,
        const u_char **__query,
        int *__querylen,
        u_char *__ans,
        int __anssiz,
        int *__resplen);

typedef res_sendhookact (*res_send_rhook) (const struct sockaddr_in *__ns,
        const u_char *__query,
        int __querylen,
        u_char *__ans,
        int __anssiz,
        int *__resplen);

/*
 * Global defines and variables for resolver stub.
 */
# 104 "/usr/include/resolv.h" 3 4
struct __res_state {
 int retrans; /* retransmition time interval */
 int retry; /* number of times to retransmit */
 u_long options; /* option flags - see below. */
 int nscount; /* number of name servers */
 struct sockaddr_in
  nsaddr_list[3]; /* address of name server */

 u_short id; /* current message id */
 /* 2 byte hole here.  */
 char *dnsrch[6 +1]; /* components of domain to search */
 char defdname[256]; /* default domain (deprecated) */
 u_long pfcode; /* RES_PRF_ flags - see below. */
 unsigned ndots:4; /* threshold for initial abs. query */
 unsigned nsort:4; /* number of elements in sort_list[] */
 unsigned ipv6_unavail:1; /* connecting to IPv6 server failed */
 unsigned unused:23;
 struct {
  struct in_addr addr;
  u_int32_t mask;
 } sort_list[10];
 /* 4 byte hole here on 64-bit architectures.  */
 res_send_qhook qhook; /* query hook */
 res_send_rhook rhook; /* response hook */
 int res_h_errno; /* last one set for this context */
 int _vcsock; /* PRIVATE: for res_send VC i/o */
 u_int _flags; /* PRIVATE: see below */
 /* 4 byte hole here on 64-bit architectures.  */
 union {
  char pad[52]; /* On an i386 this means 512b total. */
  struct {
   u_int16_t nscount;
   u_int16_t nsmap[3];
   int nssocks[3];
   u_int16_t nscount6;
   u_int16_t nsinit;
   struct sockaddr_in6 *nsaddrs[3];




   unsigned int _initstamp[2];

  } _ext;
 } _u;
};

typedef struct __res_state *res_state;




/*
 * Revision information.  This is the release date in YYYYMMDD format.
 * It can change every day so the right thing to do with it is use it
 * in preprocessor commands such as "#if (__RES > 19931104)".  Do not
 * compare for equality; rather, use it to determine whether your resolver
 * is new enough to contain a certain feature.
 */



/*
 * Resolver configuration file.
 * Normally not present, but may contain the address of the
 * inital name server(s) to query and the domain search list.
 */





struct res_sym {
 int number; /* Identifying number, like T_MX */
 char * name; /* Its symbolic name, like "MX" */
 char * humanname; /* Its fun name, like "mail exchanger" */
};

/*
 * Resolver flags (used to be discrete per-module statics ints).
 */




/* res_findzonecut() options */


/*
 * Resolver options (keep these in synch with res_debug.c, please)
 */
# 227 "/usr/include/resolv.h" 3 4
/*
 * Resolver "pfcode" values.  Used by dig.
 */
# 245 "/usr/include/resolv.h" 3 4
/*			0x00008000	*/

/* Things involving an internal (static) resolver context. */

extern struct __res_state *__res_state(void) __attribute__ ((__const__));

# 267 "/usr/include/resolv.h" 3 4

void __fp_nquery (const u_char *, int, FILE *) __attribute__ ((__nothrow__ , __leaf__));
void __fp_query (const u_char *, FILE *) __attribute__ ((__nothrow__ , __leaf__));
const char * __hostalias (const char *) __attribute__ ((__nothrow__ , __leaf__));
void __p_query (const u_char *) __attribute__ ((__nothrow__ , __leaf__));
void __res_close (void) __attribute__ ((__nothrow__ , __leaf__));
int __res_init (void) __attribute__ ((__nothrow__ , __leaf__));
int __res_isourserver (const struct sockaddr_in *) __attribute__ ((__nothrow__ , __leaf__));
int __res_mkquery (int, const char *, int, int, const u_char *,
        int, const u_char *, u_char *, int) __attribute__ ((__nothrow__ , __leaf__));
int __res_query (const char *, int, int, u_char *, int) __attribute__ ((__nothrow__ , __leaf__));
int __res_querydomain (const char *, const char *, int, int,
     u_char *, int) __attribute__ ((__nothrow__ , __leaf__));
int __res_search (const char *, int, int, u_char *, int) __attribute__ ((__nothrow__ , __leaf__));
int __res_send (const u_char *, int, u_char *, int) __attribute__ ((__nothrow__ , __leaf__));

# 327 "/usr/include/resolv.h" 3 4

int __res_hnok (const char *) __attribute__ ((__nothrow__ , __leaf__));
int __res_ownok (const char *) __attribute__ ((__nothrow__ , __leaf__));
int __res_mailok (const char *) __attribute__ ((__nothrow__ , __leaf__));
int __res_dnok (const char *) __attribute__ ((__nothrow__ , __leaf__));
int __sym_ston (const struct res_sym *, const char *, int *) __attribute__ ((__nothrow__ , __leaf__));
const char * __sym_ntos (const struct res_sym *, int, int *) __attribute__ ((__nothrow__ , __leaf__));
const char * __sym_ntop (const struct res_sym *, int, int *) __attribute__ ((__nothrow__ , __leaf__));
int __b64_ntop (u_char const *, size_t, char *, size_t) __attribute__ ((__nothrow__ , __leaf__));
int __b64_pton (char const *, u_char *, size_t) __attribute__ ((__nothrow__ , __leaf__));
int __loc_aton (const char *__ascii, u_char *__binary) __attribute__ ((__nothrow__ , __leaf__));
const char * __loc_ntoa (const u_char *__binary, char *__ascii) __attribute__ ((__nothrow__ , __leaf__));
int __dn_skipname (const u_char *, const u_char *) __attribute__ ((__nothrow__ , __leaf__));
void __putlong (u_int32_t, u_char *) __attribute__ ((__nothrow__ , __leaf__));
void __putshort (u_int16_t, u_char *) __attribute__ ((__nothrow__ , __leaf__));
const char * __p_class (int) __attribute__ ((__nothrow__ , __leaf__));
const char * __p_time (u_int32_t) __attribute__ ((__nothrow__ , __leaf__));
const char * __p_type (int) __attribute__ ((__nothrow__ , __leaf__));
const char * __p_rcode (int) __attribute__ ((__nothrow__ , __leaf__));
const u_char * __p_cdnname (const u_char *, const u_char *, int, FILE *)
     __attribute__ ((__nothrow__ , __leaf__));
const u_char * __p_cdname (const u_char *, const u_char *, FILE *) __attribute__ ((__nothrow__ , __leaf__));
const u_char * __p_fqnname (const u_char *__cp, const u_char *__msg,
      int, char *, int) __attribute__ ((__nothrow__ , __leaf__));
const u_char * __p_fqname (const u_char *, const u_char *, FILE *) __attribute__ ((__nothrow__ , __leaf__));
const char * __p_option (u_long __option) __attribute__ ((__nothrow__ , __leaf__));
char * __p_secstodate (u_long) __attribute__ ((__nothrow__ , __leaf__));
int __dn_count_labels (const char *) __attribute__ ((__nothrow__ , __leaf__));
int __dn_comp (const char *, u_char *, int, u_char **, u_char **)
     __attribute__ ((__nothrow__ , __leaf__));
int __dn_expand (const u_char *, const u_char *, const u_char *,
      char *, int) __attribute__ ((__nothrow__ , __leaf__));
u_int __res_randomid (void) __attribute__ ((__nothrow__ , __leaf__));
int __res_nameinquery (const char *, int, int,
     const u_char *, const u_char *) __attribute__ ((__nothrow__ , __leaf__));
int __res_queriesmatch (const u_char *, const u_char *,
      const u_char *, const u_char *) __attribute__ ((__nothrow__ , __leaf__));
const char * __p_section (int __section, int __opcode) __attribute__ ((__nothrow__ , __leaf__));
/* Things involving a resolver context. */
int __res_ninit (res_state) __attribute__ ((__nothrow__ , __leaf__));
int __res_nisourserver (const res_state,
      const struct sockaddr_in *) __attribute__ ((__nothrow__ , __leaf__));
void __fp_resstat (const res_state, FILE *) __attribute__ ((__nothrow__ , __leaf__));
void __res_npquery (const res_state, const u_char *, int, FILE *)
     __attribute__ ((__nothrow__ , __leaf__));
const char * __res_hostalias (const res_state, const char *, char *, size_t)
     __attribute__ ((__nothrow__ , __leaf__));
int __res_nquery (res_state, const char *, int, int, u_char *, int)
     __attribute__ ((__nothrow__ , __leaf__));
int __res_nsearch (res_state, const char *, int, int, u_char *, int)
     __attribute__ ((__nothrow__ , __leaf__));
int __res_nquerydomain (res_state, const char *, const char *, int,
      int, u_char *, int) __attribute__ ((__nothrow__ , __leaf__));
int __res_nmkquery (res_state, int, const char *, int, int,
         const u_char *, int, const u_char *, u_char *,
         int) __attribute__ ((__nothrow__ , __leaf__));
int __res_nsend (res_state, const u_char *, int, u_char *, int)
     __attribute__ ((__nothrow__ , __leaf__));
void __res_nclose (res_state) __attribute__ ((__nothrow__ , __leaf__));

# 368 "src/exim.h" 2





/* If not defined by os.h, we do nothing special to push DNS resolver state
back to be available by the classic resolver routines.  Also, provide
prototype for our get routine, unless defined away. */





res_state os_get_dns_resolver_res(void);


/* These three are to support the IP option logging code. Linux is
different to everyone else and there are also other systems which don't
have netinet/ip_var.h, so there's a general macro to control its inclusion. */

# 1 "/usr/include/netinet/in_systm.h" 1 3 4
/* System specific type definitions for networking code.
   Copyright (C) 1997 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/sys/cdefs.h" 1 3 4
/* Copyright (C) 1992-2002, 2004, 2005, 2006, 2007, 2009, 2011, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/netinet/in_systm.h" 2 3 4
# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 24 "/usr/include/netinet/in_systm.h" 2 3 4



/*
 * Network order versions of various data types. Unfortunately, BSD
 * assumes specific sizes for shorts (16 bit) and longs (32 bit) which
 * don't hold in general. As a consequence, the network order versions
 * may not reflect the actual size of the native data types.
 */

typedef u_int16_t n_short; /* short as received from the net */
typedef u_int32_t n_long; /* long as received from the net  */
typedef u_int32_t n_time; /* ms since 00:00 GMT, byte rev   */


# 389 "src/exim.h" 2
# 1 "/usr/include/netinet/ip.h" 1 3 4
/* Copyright (C) 1991-1993,1995-2000,2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/netinet/ip.h" 2 3 4
# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 23 "/usr/include/netinet/ip.h" 2 3 4

# 1 "/usr/include/netinet/in.h" 1 3 4
/* Copyright (C) 1991-2001, 2003, 2004, 2006, 2007, 2008, 2011, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 25 "/usr/include/netinet/ip.h" 2 3 4



struct timestamp
  {
    u_int8_t len;
    u_int8_t ptr;

    unsigned int flags:4;
    unsigned int overflow:4;






    u_int32_t data[9];
  };

struct iphdr
  {

    unsigned int ihl:4;
    unsigned int version:4;






    u_int8_t tos;
    u_int16_t tot_len;
    u_int16_t id;
    u_int16_t frag_off;
    u_int8_t ttl;
    u_int8_t protocol;
    u_int16_t check;
    u_int32_t saddr;
    u_int32_t daddr;
    /*The options start here. */
  };


/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ip.h	8.1 (Berkeley) 6/10/93
 */

/*
 * Definitions for internet protocol version 4.
 * Per RFC 791, September 1981.
 */

/*
 * Structure of an internet header, naked of options.
 */
struct ip
  {

    unsigned int ip_hl:4; /* header length */
    unsigned int ip_v:4; /* version */





    u_int8_t ip_tos; /* type of service */
    u_short ip_len; /* total length */
    u_short ip_id; /* identification */
    u_short ip_off; /* fragment offset field */




    u_int8_t ip_ttl; /* time to live */
    u_int8_t ip_p; /* protocol */
    u_short ip_sum; /* checksum */
    struct in_addr ip_src, ip_dst; /* source and dest address */
  };

/*
 * Time stamp option structure.
 */
struct ip_timestamp
  {
    u_int8_t ipt_code; /* IPOPT_TS */
    u_int8_t ipt_len; /* size of structure (variable) */
    u_int8_t ipt_ptr; /* index of current entry */

    unsigned int ipt_flg:4; /* flags, see below */
    unsigned int ipt_oflw:4; /* overflow counter */





    u_int32_t data[9];
  };





/*
 * Definitions for Explicit Congestion Notification (ECN)
 *
 * Taken from RFC-3168, Section 5.
 */
# 167 "/usr/include/netinet/ip.h" 3 4
/*
 * Definitions for IP differentiated services code points (DSCP)
 *
 * Taken from RFC-2597, Section 6 and RFC-2598, Section 2.3.
 */
# 189 "/usr/include/netinet/ip.h" 3 4
/*
 * In RFC 2474, Section 4.2.2.1, the Class Selector Codepoints subsume
 * the old ToS Precedence values.
 */
# 207 "/usr/include/netinet/ip.h" 3 4
/*
 * Definitions for IP type of service (ip_tos) [deprecated; use DSCP
 * and CS definitions above instead.]
 */
# 219 "/usr/include/netinet/ip.h" 3 4
/*
 * Definitions for IP precedence (also in ip_tos) [also deprecated.]
 */
# 233 "/usr/include/netinet/ip.h" 3 4
/*
 * Definitions for options.
 */
# 266 "/usr/include/netinet/ip.h" 3 4
/*
 * Offsets to fields in options other than EOL and NOP.
 */







/* flag bits for ipt_flg */




/* bits for security (not byte swapped) */
# 290 "/usr/include/netinet/ip.h" 3 4
/*
 * Internet implementation parameters.
 */








# 390 "src/exim.h" 2





/* Linux (and some others) uses a different type for the 2nd argument of
iconv(). It's os.h file defines ICONV_ARG2_TYPE. For the rest, define a default
here. */





/* One OS uses a different type for the 5th argument of getsockopt */





/* One operating system uses a different type for the 2nd argument of select().
Its os.h file defines SELECT_ARG2_TYPE. For the rest, define a default here. */





/* One operating system uses a different type for the 4th argument of
dn_expand(). Its os.h file defines DN_EXPAND_ARG4_TYPE. For the rest, define a
default here. */





/* One operating system defines a different type for the yield of inet_addr().
In Exim code, its value is always assigned to the s_addr members of address
structures. Casting the yield to the type of s_addr should fix the problem,
since the size of the data is correct. Just in case this ever has to be
changed, use a macro for the type, and define it here so that it is possible to
use different values for specific OS if ever necessary. */





/* (At least) one operating system (Solaris) defines a different type for the
second argument of pam_converse() - the difference is the absence of "const".
Its os.h file defines PAM_CONVERSE_ARG2_TYPE. For the rest, define a default
here. */





/* One operating system (SunOS4) defines getc, ungetc, feof, and ferror as
macros and not as functions. Exim needs them to be assignable functions. This
flag gets set to cause this to be sorted out here. */
# 459 "src/exim.h"
/* The header from the PCRE regex package */

# 1 "/usr/include/pcre.h" 1 3 4
/*************************************************
*       Perl-Compatible Regular Expressions      *
*************************************************/

/* This is the public header file for the PCRE library, to be #included by
applications that call the PCRE functions.

           Copyright (c) 1997-2013 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/




/* The current PCRE version information. */






/* When an application links to a PCRE DLL in Windows, the symbols that are
imported have to be identified as such. When building PCRE, the appropriate
export setting is defined in pcre_internal.h, which includes this file. So we
don't change existing definitions of PCRE_EXP_DECL and PCRECPP_EXP_DECL. */
# 68 "/usr/include/pcre.h" 3 4
/* By default, we use the standard "extern" declarations. */
# 87 "/usr/include/pcre.h" 3 4
/* Have to include stdlib.h in order to ensure that size_t is defined;
it is needed here for malloc. */

# 1 "/usr/include/stdlib.h" 1 3 4
/* Copyright (C) 1991-2007, 2009-2011, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.20 General utilities	<stdlib.h>
 */
# 91 "/usr/include/pcre.h" 2 3 4

/* Allow for C++ users */





/* Public options. Some are compile-time only, some are run-time only, and some
are both. Most of the compile-time options are saved with the compiled regex so
that they can be inspected during studying (and therefore JIT compiling). Note
that pcre_study() has its own set of options. Originally, all the options
defined here used distinct bits. However, almost all the bits in a 32-bit word
are now used, so in order to conserve them, option bits that were previously
only recognized at matching time (i.e. by pcre_exec() or pcre_dfa_exec()) may
also be used for compile-time options that affect only compiling and are not
relevant for studying or JIT compiling.

Some options for pcre_compile() change its behaviour but do not affect the
behaviour of the execution functions. Other options are passed through to the
execution functions and affect their behaviour, with or without affecting the
behaviour of pcre_compile().

Options that can be passed to pcre_compile() are tagged Cx below, with these
variants:

C1   Affects compile only
C2   Does not affect compile; affects exec, dfa_exec
C3   Affects compile, exec, dfa_exec
C4   Affects compile, exec, dfa_exec, study
C5   Affects compile, exec, study

Options that can be set for pcre_exec() and/or pcre_dfa_exec() are flagged with
E and D, respectively. They take precedence over C3, C4, and C5 settings passed
from pcre_compile(). Those that are compatible with JIT execution are flagged
with J. */
# 149 "/usr/include/pcre.h" 3 4
/* This pair use the same bit. */
# 170 "/usr/include/pcre.h" 3 4
/* Exec-time and get/set-time error codes */
# 211 "/usr/include/pcre.h" 3 4
/* Specific error codes for UTF-8 validity checks */
# 237 "/usr/include/pcre.h" 3 4
/* Specific error codes for UTF-16 validity checks */







/* Specific error codes for UTF-32 validity checks */






/* Request types for pcre_fullinfo() */
# 281 "/usr/include/pcre.h" 3 4
/* Request types for pcre_config(). Do not re-arrange, in order to remain
compatible. */
# 298 "/usr/include/pcre.h" 3 4
/* Request types for pcre_study(). Do not re-arrange, in order to remain
compatible. */






/* Bit flags for the pcre[16|32]_extra structure. Do not re-arrange or redefine
these bits, just add new ones on the end, in order to remain compatible. */
# 317 "/usr/include/pcre.h" 3 4
/* Types */

struct real_pcre; /* declaration; the definition is private  */
typedef struct real_pcre pcre;

struct real_pcre16; /* declaration; the definition is private  */
typedef struct real_pcre16 pcre16;

struct real_pcre32; /* declaration; the definition is private  */
typedef struct real_pcre32 pcre32;

struct real_pcre_jit_stack; /* declaration; the definition is private  */
typedef struct real_pcre_jit_stack pcre_jit_stack;

struct real_pcre16_jit_stack; /* declaration; the definition is private  */
typedef struct real_pcre16_jit_stack pcre16_jit_stack;

struct real_pcre32_jit_stack; /* declaration; the definition is private  */
typedef struct real_pcre32_jit_stack pcre32_jit_stack;

/* If PCRE is compiled with 16 bit character support, PCRE_UCHAR16 must contain
a 16 bit wide signed data type. Otherwise it can be a dummy data type since
pcre16 functions are not implemented. There is a check for this in pcre_internal.h. */
# 348 "/usr/include/pcre.h" 3 4
/* If PCRE is compiled with 32 bit character support, PCRE_UCHAR32 must contain
a 32 bit wide signed data type. Otherwise it can be a dummy data type since
pcre32 functions are not implemented. There is a check for this in pcre_internal.h. */
# 359 "/usr/include/pcre.h" 3 4
/* When PCRE is compiled as a C++ library, the subject pointer type can be
replaced with a custom type. For conventional use, the public interface is a
const char *. */





/* The structure for passing additional data to pcre_exec(). This is defined in
such as way as to be extensible. Always add new fields at the end, in order to
remain compatible. */

typedef struct pcre_extra {
  unsigned long int flags; /* Bits for which fields are set */
  void *study_data; /* Opaque data from pcre_study() */
  unsigned long int match_limit; /* Maximum number of calls to match() */
  void *callout_data; /* Data passed back in callouts */
  const unsigned char *tables; /* Pointer to character tables */
  unsigned long int match_limit_recursion; /* Max recursive calls to match() */
  unsigned char **mark; /* For passing back a mark pointer */
  void *executable_jit; /* Contains a pointer to a compiled jit code */
} pcre_extra;

/* Same structure as above, but with 16 bit char pointers. */

typedef struct pcre16_extra {
  unsigned long int flags; /* Bits for which fields are set */
  void *study_data; /* Opaque data from pcre_study() */
  unsigned long int match_limit; /* Maximum number of calls to match() */
  void *callout_data; /* Data passed back in callouts */
  const unsigned char *tables; /* Pointer to character tables */
  unsigned long int match_limit_recursion; /* Max recursive calls to match() */
  unsigned short **mark; /* For passing back a mark pointer */
  void *executable_jit; /* Contains a pointer to a compiled jit code */
} pcre16_extra;

/* Same structure as above, but with 32 bit char pointers. */

typedef struct pcre32_extra {
  unsigned long int flags; /* Bits for which fields are set */
  void *study_data; /* Opaque data from pcre_study() */
  unsigned long int match_limit; /* Maximum number of calls to match() */
  void *callout_data; /* Data passed back in callouts */
  const unsigned char *tables; /* Pointer to character tables */
  unsigned long int match_limit_recursion; /* Max recursive calls to match() */
  unsigned int **mark; /* For passing back a mark pointer */
  void *executable_jit; /* Contains a pointer to a compiled jit code */
} pcre32_extra;

/* The structure for passing out data via the pcre_callout_function. We use a
structure so that new fields can be added on the end in future versions,
without changing the API of the function, thereby allowing old clients to work
without modification. */

typedef struct pcre_callout_block {
  int version; /* Identifies version of block */
  /* ------------------------ Version 0 ------------------------------- */
  int callout_number; /* Number compiled into pattern */
  int *offset_vector; /* The offset vector */
  const char * subject; /* The subject being matched */
  int subject_length; /* The length of the subject */
  int start_match; /* Offset to start of this match attempt */
  int current_position; /* Where we currently are in the subject */
  int capture_top; /* Max current capture */
  int capture_last; /* Most recently closed capture */
  void *callout_data; /* Data passed in with the call */
  /* ------------------- Added for Version 1 -------------------------- */
  int pattern_position; /* Offset to next item in the pattern */
  int next_item_length; /* Length of next item in the pattern */
  /* ------------------- Added for Version 2 -------------------------- */
  const unsigned char *mark; /* Pointer to current mark or NULL    */
  /* ------------------------------------------------------------------ */
} pcre_callout_block;

/* Same structure as above, but with 16 bit char pointers. */

typedef struct pcre16_callout_block {
  int version; /* Identifies version of block */
  /* ------------------------ Version 0 ------------------------------- */
  int callout_number; /* Number compiled into pattern */
  int *offset_vector; /* The offset vector */
  const unsigned short * subject; /* The subject being matched */
  int subject_length; /* The length of the subject */
  int start_match; /* Offset to start of this match attempt */
  int current_position; /* Where we currently are in the subject */
  int capture_top; /* Max current capture */
  int capture_last; /* Most recently closed capture */
  void *callout_data; /* Data passed in with the call */
  /* ------------------- Added for Version 1 -------------------------- */
  int pattern_position; /* Offset to next item in the pattern */
  int next_item_length; /* Length of next item in the pattern */
  /* ------------------- Added for Version 2 -------------------------- */
  const unsigned short *mark; /* Pointer to current mark or NULL    */
  /* ------------------------------------------------------------------ */
} pcre16_callout_block;

/* Same structure as above, but with 32 bit char pointers. */

typedef struct pcre32_callout_block {
  int version; /* Identifies version of block */
  /* ------------------------ Version 0 ------------------------------- */
  int callout_number; /* Number compiled into pattern */
  int *offset_vector; /* The offset vector */
  const unsigned int * subject; /* The subject being matched */
  int subject_length; /* The length of the subject */
  int start_match; /* Offset to start of this match attempt */
  int current_position; /* Where we currently are in the subject */
  int capture_top; /* Max current capture */
  int capture_last; /* Most recently closed capture */
  void *callout_data; /* Data passed in with the call */
  /* ------------------- Added for Version 1 -------------------------- */
  int pattern_position; /* Offset to next item in the pattern */
  int next_item_length; /* Length of next item in the pattern */
  /* ------------------- Added for Version 2 -------------------------- */
  const unsigned int *mark; /* Pointer to current mark or NULL    */
  /* ------------------------------------------------------------------ */
} pcre32_callout_block;

/* Indirection for store get and free functions. These can be set to
alternative malloc/free functions if required. Special ones are used in the
non-recursive case for "frames". There is also an optional callout function
that is triggered by the (?) regex item. For Virtual Pascal, these definitions
have to take another form. */


extern void *(*pcre_malloc)(size_t);
extern void (*pcre_free)(void *);
extern void *(*pcre_stack_malloc)(size_t);
extern void (*pcre_stack_free)(void *);
extern int (*pcre_callout)(pcre_callout_block *);

extern void *(*pcre16_malloc)(size_t);
extern void (*pcre16_free)(void *);
extern void *(*pcre16_stack_malloc)(size_t);
extern void (*pcre16_stack_free)(void *);
extern int (*pcre16_callout)(pcre16_callout_block *);

extern void *(*pcre32_malloc)(size_t);
extern void (*pcre32_free)(void *);
extern void *(*pcre32_stack_malloc)(size_t);
extern void (*pcre32_stack_free)(void *);
extern int (*pcre32_callout)(pcre32_callout_block *);
# 521 "/usr/include/pcre.h" 3 4
/* User defined callback which provides a stack just before the match starts. */

typedef pcre_jit_stack *(*pcre_jit_callback)(void *);
typedef pcre16_jit_stack *(*pcre16_jit_callback)(void *);
typedef pcre32_jit_stack *(*pcre32_jit_callback)(void *);

/* Exported PCRE functions */

extern pcre *pcre_compile(const char *, int, const char **, int *,
                  const unsigned char *);
extern pcre16 *pcre16_compile(const unsigned short *, int, const char **, int *,
                  const unsigned char *);
extern pcre32 *pcre32_compile(const unsigned int *, int, const char **, int *,
                  const unsigned char *);
extern pcre *pcre_compile2(const char *, int, int *, const char **,
                  int *, const unsigned char *);
extern pcre16 *pcre16_compile2(const unsigned short *, int, int *, const char **,
                  int *, const unsigned char *);
extern pcre32 *pcre32_compile2(const unsigned int *, int, int *, const char **,
                  int *, const unsigned char *);
extern int pcre_config(int, void *);
extern int pcre16_config(int, void *);
extern int pcre32_config(int, void *);
extern int pcre_copy_named_substring(const pcre *, const char *,
                  int *, int, const char *, char *, int);
extern int pcre16_copy_named_substring(const pcre16 *, const unsigned short *,
                  int *, int, const unsigned short *, unsigned short *, int);
extern int pcre32_copy_named_substring(const pcre32 *, const unsigned int *,
                  int *, int, const unsigned int *, unsigned int *, int);
extern int pcre_copy_substring(const char *, int *, int, int,
                  char *, int);
extern int pcre16_copy_substring(const unsigned short *, int *, int, int,
                  unsigned short *, int);
extern int pcre32_copy_substring(const unsigned int *, int *, int, int,
                  unsigned int *, int);
extern int pcre_dfa_exec(const pcre *, const pcre_extra *,
                  const char *, int, int, int, int *, int , int *, int);
extern int pcre16_dfa_exec(const pcre16 *, const pcre16_extra *,
                  const unsigned short *, int, int, int, int *, int , int *, int);
extern int pcre32_dfa_exec(const pcre32 *, const pcre32_extra *,
                  const unsigned int *, int, int, int, int *, int , int *, int);
extern int pcre_exec(const pcre *, const pcre_extra *, const char *,
                   int, int, int, int *, int);
extern int pcre16_exec(const pcre16 *, const pcre16_extra *,
                   const unsigned short *, int, int, int, int *, int);
extern int pcre32_exec(const pcre32 *, const pcre32_extra *,
                   const unsigned int *, int, int, int, int *, int);
extern int pcre_jit_exec(const pcre *, const pcre_extra *,
                   const char *, int, int, int, int *, int,
                   pcre_jit_stack *);
extern int pcre16_jit_exec(const pcre16 *, const pcre16_extra *,
                   const unsigned short *, int, int, int, int *, int,
                   pcre16_jit_stack *);
extern int pcre32_jit_exec(const pcre32 *, const pcre32_extra *,
                   const unsigned int *, int, int, int, int *, int,
                   pcre32_jit_stack *);
extern void pcre_free_substring(const char *);
extern void pcre16_free_substring(const unsigned short *);
extern void pcre32_free_substring(const unsigned int *);
extern void pcre_free_substring_list(const char **);
extern void pcre16_free_substring_list(const unsigned short * *);
extern void pcre32_free_substring_list(const unsigned int * *);
extern int pcre_fullinfo(const pcre *, const pcre_extra *, int,
                  void *);
extern int pcre16_fullinfo(const pcre16 *, const pcre16_extra *, int,
                  void *);
extern int pcre32_fullinfo(const pcre32 *, const pcre32_extra *, int,
                  void *);
extern int pcre_get_named_substring(const pcre *, const char *,
                  int *, int, const char *, const char **);
extern int pcre16_get_named_substring(const pcre16 *, const unsigned short *,
                  int *, int, const unsigned short *, const unsigned short * *);
extern int pcre32_get_named_substring(const pcre32 *, const unsigned int *,
                  int *, int, const unsigned int *, const unsigned int * *);
extern int pcre_get_stringnumber(const pcre *, const char *);
extern int pcre16_get_stringnumber(const pcre16 *, const unsigned short *);
extern int pcre32_get_stringnumber(const pcre32 *, const unsigned int *);
extern int pcre_get_stringtable_entries(const pcre *, const char *,
                  char **, char **);
extern int pcre16_get_stringtable_entries(const pcre16 *, const unsigned short *,
                  unsigned short **, unsigned short **);
extern int pcre32_get_stringtable_entries(const pcre32 *, const unsigned int *,
                  unsigned int **, unsigned int **);
extern int pcre_get_substring(const char *, int *, int, int,
                  const char **);
extern int pcre16_get_substring(const unsigned short *, int *, int, int,
                  const unsigned short * *);
extern int pcre32_get_substring(const unsigned int *, int *, int, int,
                  const unsigned int * *);
extern int pcre_get_substring_list(const char *, int *, int,
                  const char ***);
extern int pcre16_get_substring_list(const unsigned short *, int *, int,
                  const unsigned short * **);
extern int pcre32_get_substring_list(const unsigned int *, int *, int,
                  const unsigned int * **);
extern const unsigned char *pcre_maketables(void);
extern const unsigned char *pcre16_maketables(void);
extern const unsigned char *pcre32_maketables(void);
extern int pcre_refcount(pcre *, int);
extern int pcre16_refcount(pcre16 *, int);
extern int pcre32_refcount(pcre32 *, int);
extern pcre_extra *pcre_study(const pcre *, int, const char **);
extern pcre16_extra *pcre16_study(const pcre16 *, int, const char **);
extern pcre32_extra *pcre32_study(const pcre32 *, int, const char **);
extern void pcre_free_study(pcre_extra *);
extern void pcre16_free_study(pcre16_extra *);
extern void pcre32_free_study(pcre32_extra *);
extern const char *pcre_version(void);
extern const char *pcre16_version(void);
extern const char *pcre32_version(void);

/* Utility functions for byte order swaps. */
extern int pcre_pattern_to_host_byte_order(pcre *, pcre_extra *,
                  const unsigned char *);
extern int pcre16_pattern_to_host_byte_order(pcre16 *, pcre16_extra *,
                  const unsigned char *);
extern int pcre32_pattern_to_host_byte_order(pcre32 *, pcre32_extra *,
                  const unsigned char *);
extern int pcre16_utf16_to_host_byte_order(unsigned short *,
                  const unsigned short *, int, int *, int);
extern int pcre32_utf32_to_host_byte_order(unsigned int *,
                  const unsigned int *, int, int *, int);

/* JIT compiler related functions. */

extern pcre_jit_stack *pcre_jit_stack_alloc(int, int);
extern pcre16_jit_stack *pcre16_jit_stack_alloc(int, int);
extern pcre32_jit_stack *pcre32_jit_stack_alloc(int, int);
extern void pcre_jit_stack_free(pcre_jit_stack *);
extern void pcre16_jit_stack_free(pcre16_jit_stack *);
extern void pcre32_jit_stack_free(pcre32_jit_stack *);
extern void pcre_assign_jit_stack(pcre_extra *,
                  pcre_jit_callback, void *);
extern void pcre16_assign_jit_stack(pcre16_extra *,
                  pcre16_jit_callback, void *);
extern void pcre32_assign_jit_stack(pcre32_extra *,
                  pcre32_jit_callback, void *);
# 462 "src/exim.h" 2

/* Exim includes are in several files. Note that local_scan.h #includes
config.h, mytypes.h, and store.h, so we don't need to mention them explicitly.
*/

# 1 "src/local_scan.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2012 */
/* See the file NOTICE for conditions of use and distribution. */

/* This file is the header that is the only Exim header to be included in the
source for the local_scan.c() function. It contains definitions that are made
available for use in that function, and which are documented.

This API is also used for functions called by the ${dlfunc expansion item. */


/* Some basic types that make some things easier, the Exim configuration
settings, and the store functions. */

# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdarg.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
# 19 "src/local_scan.h" 2
# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 20 "src/local_scan.h" 2
# 1 "build-Linux-x86_64/config.h" 1
/*************************************************
*           Configuration header for Exim        *
*************************************************/

/* This file was automatically generated from Makefile and config.h.defaults,
using values specified in the configuration file Local/Makefile.
Do not edit it. Instead, edit Local/Makefile and rerun make. */
# 23 "build-Linux-x86_64/config.h"
/* ALT_CONFIG_PREFIX not set */
/* TRUSTED_CONFIG_LIST not set */




/* AUTH_CRAM_MD5 not set */
/* AUTH_CYRUS_SASL not set */
/* AUTH_DOVECOT not set */
/* AUTH_GSASL not set */
/* AUTH_HEIMDAL_GSSAPI not set */
/* AUTH_PLAINTEXT not set */
/* AUTH_SPA not set */



/* CONFIGURE_FILE_USE_EUID not set */
/* CONFIGURE_FILE_USE_NODE not set */
/* CONFIGURE_GROUP not set */
/* CONFIGURE_OWNER not set */
/* CYRUS_PWCHECK_SOCKET not set */
/* CYRUS_SASLAUTHD_SOCKET not set */



/* DISABLE_DKIM not set */
/* DISABLE_D_OPTION not set */
/* ENABLE_DISABLE_FSYNC not set */




/* EXIM_CLIENT_DH_MIN_BITS not set */
/* EXIM_GNUTLS_LIBRARY_LOG_LEVEL not set */
/* EXIM_SERVER_DH_BITS_PRE2_12 not set */
/* EXIM_PERL not set */


/* EXPAND_DLFUNC not set */
/* EXPAND_LISTMATCH_RHS not set */

/* HAVE_CRYPT16 not set */
/* HAVE_SA_LEN not set */




/* IPV6_USE_INET_PTON not set */
/* LDAP_LIB_TYPE not set */
/* LOCAL_SCAN_HAS_OPTIONS not set */

/* LOG_FILE_PATH not set */

/* LOOKUP_CDB not set */


/* LOOKUP_DSEARCH not set */
/* LOOKUP_IBASE not set */
/* LOOKUP_LDAP not set */

/* LOOKUP_MYSQL not set */
/* LOOKUP_NIS not set */
/* LOOKUP_NISPLUS not set */
/* LOOKUP_ORACLE not set */
/* LOOKUP_PASSWD not set */
/* LOOKUP_PGSQL not set */
/* LOOKUP_SQLITE not set */
/* LOOKUP_TESTDB not set */
/* LOOKUP_WHOSON not set */
/* LOOKUP_WILDLSEARCH not set */
/* LOOKUP_NWILDLSEARCH not set */
/* LOOKUP_MODULE_DIR not set */






/* NVALGRIND not set */
/* PID_FILE_PATH not set */
/* RADIUS_CONFIG_FILE not set */
/* RADIUS_LIB_TYPE not set */



/* ROUTER_IPLOOKUP not set */







/* SUPPORT_A6 not set */
/* SUPPORT_CRYPTEQ not set */
/* SUPPORT_MAILDIR not set */
/* SUPPORT_MAILSTORE not set */
/* SUPPORT_MBX not set */
/* SUPPORT_MOVE_FROZEN_MESSAGES not set */
/* SUPPORT_PAM not set */
/* SUPPORT_TLS not set */
/* SUPPORT_TRANSLATE_IP_ADDRESS not set */

/* SYSLOG_LONG_LINES not set */





/* TRANSPORT_LMTP not set */



/* USE_GDBM not set */
/* USE_GNUTLS not set */
/* USE_READLINE not set */
/* USE_TCP_WRAPPERS not set */
/* USE_TDB not set */
/* WHITELIST_D_MACROS not set */
/* WITH_CONTENT_SCAN not set */
/* WITH_OLD_DEMIME not set */
/* WITH_OLD_CLAMAV_STREAM not set */

/* EXPERIMENTAL_BRIGHTMAIL not set */
/* EXPERIMENTAL_DCC not set */
/* EXPERIMENTAL_OCSP not set */
/* EXPERIMENTAL_SPF not set */
/* EXPERIMENTAL_SRS not set */
/* WANT_DEEPER_PRINTF_CHECKS not set */
# 171 "build-Linux-x86_64/config.h"
/* End of config.h */
# 21 "src/local_scan.h" 2
# 1 "src/mytypes.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2012 */
/* See the file NOTICE for conditions of use and distribution. */


/* This header file contains type definitions and macros that I use as
"standard" in the code of Exim and its utilities. Make it idempotent because
local_scan.h includes it and exim.h includes them both (to get this earlier). */
# 29 "src/mytypes.h"
/* If gcc is being used to compile Exim, we can use its facility for checking
the arguments of printf-like functions. This is done by a macro. */
# 47 "src/mytypes.h"
/* Some operating systems (naughtily, imo) include a definition for "uchar" in
the standard header files, so we use "uschar". Solaris has u_char in
sys/types.h. This is just a typing convenience, of course. */

typedef unsigned char uschar;
typedef int BOOL;
/* We also have SIGNAL_BOOL, which requires signal.h be included, so is defined
elsewhere */


/* These macros save typing for the casting that is needed to cope with the
mess that is "char" in ISO/ANSI C. Having now been bitten enough times by
systems where "char" is actually signed, I've converted Exim to use entirely
unsigned chars, except in a few special places such as arguments that are
almost always literal strings. */
# 70 "src/mytypes.h"
/* The C library string functions expect "char *" arguments. Use macros to
avoid having to write a cast each time. We do this for string and file
functions that are called quite often; for other calls to external libraries
(which are on the whole special-purpose) we just use individual casts. */
# 117 "src/mytypes.h"
/* End of mytypes.h */
# 22 "src/local_scan.h" 2
# 1 "src/store.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2009 */
/* See the file NOTICE for conditions of use and distribution. */

/* Header for Exim's memory allocation functions */




/* Define symbols for identifying the store pools. */

enum { POOL_MAIN, POOL_PERM, POOL_SEARCH };

/* This variable (the one for the current pool) is set by store_get() to its
yield, and by store_reset() to NULL. This allows string_cat() to optimize its
store handling. */

extern void *store_last_get[3];

/* This variable contains the current store pool number. */

extern int store_pool;

/* Macros for calling the memory allocation routines with
tracing information for debugging. */
# 41 "src/store.h"
/* The real functions */

extern BOOL store_extend_3(void *, int, int, const char *, int); /* The */
extern void store_free_3(void *, const char *, int); /* value of the */
extern void *store_get_3(int, const char *, int); /* 2nd arg is   */
extern void *store_get_perm_3(int, const char *, int); /* __FILE__ in  */
extern void *store_malloc_3(int, const char *, int); /* every call,  */
extern void store_release_3(void *, const char *, int); /* so give its  */
extern void store_reset_3(void *, const char *, int); /* correct type */



/* End of store.h */
# 23 "src/local_scan.h" 2


/* The function and its return codes. */

extern int local_scan(int, uschar **);

enum {
  LOCAL_SCAN_ACCEPT, /* Accept */
  LOCAL_SCAN_ACCEPT_FREEZE, /* Accept, but freeze */
  LOCAL_SCAN_ACCEPT_QUEUE, /* Accept, but no immediate delivery */
  LOCAL_SCAN_REJECT, /* Permanent rejection */
  LOCAL_SCAN_REJECT_NOLOGHDR, /* Permanent rejection, no log header */
  LOCAL_SCAN_TEMPREJECT, /* Temporary rejection */
  LOCAL_SCAN_TEMPREJECT_NOLOGHDR /* Temporary rejection, no log header */
};


/* Functions called by ${dlfunc{file}{func}{arg}...} return one of the five
status codes defined immediately below. The function's first argument is either
the result of expansion, or the error message in case of failure. The second
and third arguments are standard argument count and vector, comprising the
{arg} values specified in the expansion item. */

typedef int exim_dlfunc_t(uschar **yield, int argc, uschar *argv[]);


/* Return codes from the support functions lss_match_xxx(). These are also the
codes that dynamically-loaded ${dlfunc functions must return. */






/* Extra return code for ${dlfunc functions */




/* Available logging destinations */






/* Accessible debugging bits */





/* Option types that can be used for local_scan_options. The boolean ones
MUST be last so that they are contiguous with the internal boolean specials. */

enum { opt_stringptr, opt_int, opt_octint, opt_mkint, opt_Kint, opt_fixed,
  opt_time, opt_bool };


/* The length of message identification strings. This is the id used internally
by exim. The external version for use in Received: strings has a leading 'E'
added to ensure it starts with a letter. */



/* The offset to the start of the data in the data file - this allows for
the name of the data file to be present in the first line. */



/* Some people (Marc Merlin et al) are maintaining a patch that allows for
dynamic local_scan() libraries. This code is not yet in Exim proper, but it
helps the maintainers if we keep their ABI version numbers here. This may
mutate into more general support later. The major number is increased when the
ABI is changed in a non backward compatible way. The minor number is increased
each time a new feature is added (in a way that doesn't break backward
compatibility). */






/* Structure definitions that are documented as visible in the function. */

typedef struct header_line {
  struct header_line *next;
  int type;
  int slen;
  uschar *text;
} header_line;

/* Entries in lists options are in this form. */

typedef struct {
  const char *name;
  int type;
  void *value;
} optionlist;

/*Structure for holding information about an envelope address. The errors_to
field is always NULL except for one_time aliases that had errors_to on the
routers that generated them. */

typedef struct recipient_item {
  uschar *address; /* the recipient address */
  int pno; /* parent number for "one_time" alias, or -1 */
  uschar *errors_to; /* the errors_to address or NULL */



} recipient_item;


/* Global variables that are documented as visible in the function. */

extern unsigned int debug_selector; /* Debugging bits */

extern int body_linecount; /* Line count in body */
extern int body_zerocount; /* Binary zero count in body */
extern uschar *expand_string_message; /* Error info for failing expansion */
extern uschar *headers_charset; /* Charset for RFC 2047 decoding */
extern header_line *header_last; /* Final header */
extern header_line *header_list; /* First header */
extern BOOL host_checking; /* Set when checking a host */
extern uschar *interface_address; /* Interface for incoming call */
extern int interface_port; /* Port number for incoming call */
extern uschar *message_id; /* Internal id of message being handled */
extern uschar *received_protocol; /* Name of incoming protocol */
extern int recipients_count; /* Number of recipients */
extern recipient_item *recipients_list;/* List of recipient addresses */
extern unsigned char *sender_address; /* Sender address */
extern uschar *sender_host_address; /* IP address of sender, as chars */
extern uschar *sender_host_authenticated; /* Name of authentication mechanism */
extern uschar *sender_host_name; /* Host name from lookup */
extern int sender_host_port; /* Port number of sender */
extern BOOL smtp_batched_input; /* TRUE if SMTP batch (no interaction) */
extern BOOL smtp_input; /* TRUE if input is via SMTP */


/* Functions that are documented as visible in local_scan(). */

extern int child_close(pid_t, int);
extern pid_t child_open(uschar **, uschar **, int, int *, int *, BOOL);
extern pid_t child_open_exim(int *);
extern pid_t child_open_exim2(int *, uschar *, uschar *);
extern void debug_printf(const char *, ...) __attribute__((format(printf,1,2)));
extern uschar *expand_string(uschar *);
extern void header_add(int, const char *, ...);
extern void header_add_at_position(BOOL, uschar *, BOOL, int, const char *, ...);
extern void header_remove(int, const uschar *);
extern BOOL header_testname(header_line *, const uschar *, int, BOOL);
extern BOOL header_testname_incomplete(header_line *, const uschar *, int, BOOL);
extern void log_write(unsigned int, int, const char *format, ...) __attribute__((format(printf,3,4)));
extern int lss_b64decode(uschar *, uschar **);
extern uschar *lss_b64encode(uschar *, int);
extern int lss_match_domain(uschar *, uschar *);
extern int lss_match_local_part(uschar *, uschar *, BOOL);
extern int lss_match_address(uschar *, uschar *, BOOL);
extern int lss_match_host(uschar *, uschar *, uschar *);
extern void receive_add_recipient(uschar *, int);
extern BOOL receive_remove_recipient(uschar *);
extern uschar *rfc2047_decode(uschar *, BOOL, uschar *, int, int *, uschar **);
extern int smtp_fflush(void);
extern void smtp_printf(const char *, ...) __attribute__((format(printf,1,2)));
extern void smtp_vprintf(const char *, va_list);
extern uschar *string_copy(const uschar *);
extern uschar *string_copyn(uschar *, int);
extern uschar *string_sprintf(const char *, ...) ;

/* End of local_scan.h */
# 468 "src/exim.h" 2
# 1 "src/macros.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2012 */
/* See the file NOTICE for conditions of use and distribution. */


/* These two macros make it possible to obtain the result of macro-expanding
a string as a text string. This is sometimes useful for debugging output. */





/* When running in the test harness, the load average is fudged. */





/* The address_item structure has a word full of 1-bit flags. These macros
manipulate them. */
# 38 "src/macros.h"
/* For almost all calls to convert things to printing characters, we want to
allow tabs. A macro just makes life a bit easier. */




/* We need a special return code for "no recipients and failed to send an error
message". ANSI C defines only EXIT_FAILURE and EXIT_SUCCESS. On the assumption
that these are always 1 and 0 on Unix systems ... */




/* Character-handling macros. It seems that the set of standard functions in
ctype.h aren't actually all that useful. One reason for this is that email is
international, so the concept of using a locale to vary what they do is not
helpful. Another problem is that in different operating systems, the libraries
yield different results, even in the default locale. For example, Linux yields
TRUE for iscntrl() for all characters > 127, whereas many other systems yield
FALSE. For these reasons we define our own set of macros for a number of
character testing functions. Ensure that all these tests treat their arguments
as unsigned. */
# 75 "src/macros.h"
/* Convenience for testing strings */




/* When built with TLS support, the act of flushing SMTP output becomes
a no-op once an SSL session is in progress. */
# 90 "src/macros.h"
/* Define which ends of pipes are for reading and writing, as some systems
don't make the file descriptors two-way. */




/* The RFC 1413 ident port */



/* A macro to simplify testing bits in lookup types */



/* Debugging control */




/* The default From: text for DSNs */



/* The size of the vector for saving/restoring address expansion pointers while
verifying. This has to be explicit because it is referenced in more than one
source module. */



/* The maximum permitted number of command-line (-D) macro definitions. We
need a limit only to make it easier to generate argument vectors for re-exec
of Exim. */



/* The number of integer variables available in filter files. If this is
changed, then the tables in expand.c for accessing them must be changed too. */



/* The size of the vector holding delay warning times */



/* The size of the buffer holding the processing information string. */



/* The size of buffer to get for constructing log entries. Make it big
enough to hold all the headers from a normal kind of message. */



/* The size of the circular buffer that remembers recent SMTP commands */



/* The initial size of a big buffer for use in various places. It gets put
into big_buffer_size and in some circumstances increased. It should be at least
as long as the maximum path length. */
# 159 "src/macros.h"
/* This limits the length of data returned by local_scan(). Because it is
written on the spool, it gets read into big_buffer. */



/* A limit to the length of an address. RFC 2821 limits the local part to 64
and the domain to 255, so this should be adequate, taking into account quotings
etc. */



/* The length of the base names of spool files, which consist of an internal
message id with a trailing "-H" or "-D" added. */



/* The maximum number of message ids to store in a waiting database
record. */



/* Fixed option values for all PCRE functions */




/* Macros for trivial functions */





/* Options for dns_next_rr */

enum { RESET_NEXT, RESET_ANSWERS, RESET_AUTHORITY, RESET_ADDITIONAL };

/* Argument values for the time-of-day function */

enum { tod_log, tod_log_bare, tod_log_zone, tod_log_datestamp_daily,
       tod_log_datestamp_monthly, tod_zone, tod_full, tod_bsdin,
       tod_mbx, tod_epoch, tod_epoch_l, tod_zulu };

/* For identifying types of driver */

enum {
  DTYPE_NONE,
  DTYPE_ROUTER,
  DTYPE_TRANSPORT
};

/* Error numbers for generating error messages when reading a message on the
standard input. */

enum {
  ERRMESS_BADARGADDRESS, /* Bad address via argument list */
  ERRMESS_BADADDRESS, /* Bad address read via -t */
  ERRMESS_NOADDRESS, /* Message has no addresses */
  ERRMESS_IGADDRESS, /* All -t addresses ignored */
  ERRMESS_BADNOADDRESS, /* Bad address via -t, leaving none */
  ERRMESS_IOERR, /* I/O error while reading a message */
  ERRMESS_VLONGHEADER, /* Excessively long message header */
  ERRMESS_VLONGHDRLINE, /* Excessively long single line in header */
  ERRMESS_TOOBIG, /* Message too big */
  ERRMESS_TOOMANYRECIP, /* Too many recipients */
  ERRMESS_LOCAL_SCAN, /* Rejected by local scan */
  ERRMESS_LOCAL_ACL /* Rejected by non-SMTP ACL */
};

/* Error handling styles - set by option, and apply only when receiving
a local message not via SMTP. */

enum {
  ERRORS_SENDER, /* Return to sender (default) */
  ERRORS_STDERR /* Write on stderr */
};

/* Exec control values when Exim execs itself via child_exec_exim. */

enum {
  CEE_RETURN_ARGV, /* Don't exec, just build and return argv */
  CEE_EXEC_EXIT, /* Just exit if exec fails */
  CEE_EXEC_PANIC /* Panic-die if exec fails */
};

/* Bit values for filter_test */





/* Returns from the routing, transport and authentication functions (not all
apply to all of them). Some other functions also use these convenient values,
and some additional values are used only by non-driver functions.

OK, FAIL, DEFER, ERROR, and FAIL_FORCED are also declared in local_scan.h for
use in the local_scan() function and in ${dlfunc loaded functions. Do not
change them unilaterally. */






/***********/
# 277 "src/macros.h"
/* Returns from the deliver_message() function */






/* Returns from DNS lookup functions. */

enum { DNS_SUCCEED, DNS_NOMATCH, DNS_NODATA, DNS_AGAIN, DNS_FAIL };

/* Ending states when reading a message. The order is important. The test
for having to swallow the rest of an SMTP message is whether the value is
>= END_NOTENDED. */
# 299 "src/macros.h"
/* Options bits for debugging; D_v and D_local_scan are also in local_scan.h */
# 334 "src/macros.h"
/* The D_all value must always have all bits set, as it is recognized specially
by the function that decodes debug and log selectors. This is to enable it to
set all the bits in a multi-word selector. Debug doesn't use this yet, but we
are getting close. In fact, we want to omit "memory" for -d+all, but can't
handle this here. It is fudged externally. */
# 358 "src/macros.h"
/* Options bits for logging. Those that will end up in log_write_selector have
values < 0x80000000. They can be used in calls to log_write(). The others have
values > 0x80000000 and are put into log_extra_selector (without the top bit).
These are only ever tested independently. "All" is a magic value that is used
only in the name table to set all options in both bit maps. */

/* The L_all value must always have all bits set, as it is recognized specially
by the function that decodes debug and log selectors. This is to enable it to
set all the bits in a multi-word selector. */
# 429 "src/macros.h"
/* Private error numbers for delivery failures, set negative so as not
to conflict with system errno values. */
# 479 "src/macros.h"
/* These must be last, so all retry deferments can easily be identified */
# 488 "src/macros.h"
/* Special actions to take after failure or deferment. */

enum {
  SPECIAL_NONE, /* No special action */
  SPECIAL_FREEZE, /* Freeze message */
  SPECIAL_FAIL, /* Fail the delivery */
  SPECIAL_WARN /* Send a warning message */
};

/* Flags that get ORed into the more_errno field of an address to give more
information about errors for retry purposes. They are greater than 256, because
the bottom byte contains 'A' or 'M' for remote addresses, to indicate whether
the name was looked up only via an address record or whether MX records were
used, respectively. */



/* Permission and other options for parse_extract_addresses(),
filter_interpret(), and rda_interpret(), i.e. what special things are allowed
in redirection operations. Not all apply to all cases. Some of the bits allow
and some forbid, reflecting the "allow" and "forbid" options in the redirect
router, which were chosen to represent the standard situation for users'
.forward files. */
# 534 "src/macros.h"
/* This is the set that apply to expansions in filters */




/* As well as the RDO bits themselves, we need the bit numbers in order to
access (most of) the individual bits as separate options. This could be
automated, but I haven't bothered. Keep this list in step with the above! */

enum { RDON_BLACKHOLE, RDON_DEFER, RDON_EACCES, RDON_ENOTDIR, RDON_EXISTS,
  RDON_FAIL, RDON_FILTER, RDON_FREEZE, RDON_INCLUDE, RDON_LOG, RDON_LOOKUP,
  RDON_PERL, RDON_READFILE, RDON_READSOCK, RDON_RUN, RDON_DLFUNC, RDON_REALLOG,
  RDON_REWRITE, RDON_EXIM_FILTER, RDON_SIEVE_FILTER, RDON_PREPEND_HOME };

/* Results of filter or forward file processing. Some are only from a filter;
some are only from a forward file. */

enum {
  FF_DELIVERED, /* Success, took significant action */
  FF_NOTDELIVERED, /* Success, didn't take significant action */
  FF_BLACKHOLE, /* Blackholing requested */
  FF_DEFER, /* Defer requested */
  FF_FAIL, /* Fail requested */
  FF_INCLUDEFAIL, /* :include: failed */
  FF_NONEXIST, /* Forward file does not exist */
  FF_FREEZE, /* Freeze requested */
  FF_ERROR /* We have a problem */
};

/* Values for identifying particular headers; printing characters are used, so
they can be read in the spool file for those headers that are permanently
marked. The lower case values don't get onto the spool; they are used only as
return values from header_checkname(). */
# 585 "src/macros.h"
/* These values are used only when adding new headers from an ACL; they too
never get onto the spool. The type of the added header is set by reference
to the header name, by calling header_checkname(). */






/* Types of item in options lists. These are the bottom 8 bits of the "type"
field, which is an int. The opt_void value is used for entries in tables that
point to special types of value that are accessed only indirectly (e.g. the
rewrite data that is built out of a string option.) We need to have some values
visible in local_scan, so the following are declared there:

  opt_stringptr, opt_int, opt_octint, opt_mkint, opt_Kint, opt_fixed, opt_time,
  opt_bool

To make sure we don't conflict, the local_scan.h values start from zero, and
those defined here start from 32. The boolean ones must all be together so they
can be easily tested as a group. That is the only use of opt_bool_last. */

enum { opt_bit = 32, opt_bool_verify, opt_bool_set, opt_expand_bool,
  opt_bool_last,
  opt_rewrite, opt_timelist, opt_uid, opt_gid, opt_uidlist, opt_gidlist,
  opt_expand_uid, opt_expand_gid, opt_void };

/* There's a high-ish bit which is used to flag duplicate options, kept
for compatibility, which shouldn't be output. Also used for hidden options
that are automatically maintained from others. Another high bit is used to
flag driver options that although private (so as to be settable only on some
drivers), are stored in the instance block so as to be accessible from outside.
A third high bit is set when an option is read, so as to be able to give an
error if any option is set twice. Finally, there's a bit which is set when an
option is set with the "hide" prefix, to prevent -bP from showing it to
non-admin callers. The next byte up in the int is used to keep the bit number
for booleans that are kept in one bit. */







/* Verify types when directing and routing */

enum { v_none, v_sender, v_recipient, v_expn };

/* Option flags for verify_address() */
# 646 "src/macros.h"
/* Values for fields in callout cache records */






/* Options for lookup functions */





/* Status values for host_item blocks. Require hstatus_unusable and
hstatus_unusable_expired to be last. */

enum { hstatus_unknown, hstatus_usable, hstatus_unusable,
       hstatus_unusable_expired };

/* Reasons why a host is unusable (for clearer log messages) */

enum { hwhy_unknown, hwhy_retry, hwhy_failed, hwhy_deferred, hwhy_ignored };

/* Domain lookup types for routers */

enum { lk_default, lk_byname, lk_bydns };

/* Values for the self_code fields */

enum { self_freeze, self_defer, self_send, self_reroute, self_pass, self_fail };

/* Flags for rewrite rules */
# 701 "src/macros.h"
/* Flags for log_write(); LOG_MAIN, LOG_PANIC, and LOG_REJECT are also in
local_scan.h */
# 714 "src/macros.h"
/* and for debug_bits() logging action control: */


/* SMTP command identifiers for the smtp_connection_had field that records the
most recent SMTP commands. Must be kept in step with the list of names in
smtp_in.c that is used for creating the smtp_no_mail logging action. SCH_NONE
is "empty". */

enum { SCH_NONE, SCH_AUTH, SCH_DATA, SCH_EHLO, SCH_ETRN, SCH_EXPN, SCH_HELO,
       SCH_HELP, SCH_MAIL, SCH_NOOP, SCH_QUIT, SCH_RCPT, SCH_RSET, SCH_STARTTLS,
       SCH_VRFY };

/* Returns from host_find_by{name,dns}() */

enum {
  HOST_FIND_FAILED, /* failed to find the host */
  HOST_FIND_AGAIN, /* could not resolve at this time */
  HOST_FOUND, /* found host */
  HOST_FOUND_LOCAL, /* found, but MX points to local host */
  HOST_IGNORED /* found but ignored - used internally only */
};

/* Flags for host_find_bydns() */







/* Actions applied to specific messages. */

enum { MSG_DELIVER, MSG_FREEZE, MSG_REMOVE, MSG_THAW, MSG_ADD_RECIPIENT,
       MSG_MARK_ALL_DELIVERED, MSG_MARK_DELIVERED, MSG_EDIT_SENDER,
       MSG_SHOW_COPY, MSG_LOAD,
       /* These ones must be last: a test for >= MSG_SHOW_BODY is used
       to test for actions that list individual spool files. */
       MSG_SHOW_BODY, MSG_SHOW_HEADER, MSG_SHOW_LOG };

/* Returns from the spool_read_header() function */

enum {
  spool_read_OK, /* success */
  spool_read_notopen, /* open failed */
  spool_read_enverror, /* error in the envelope */
  spool_read_hdrerror /* error in the headers */
};

/* Options for transport_write_message */
# 773 "src/macros.h"
/* Codes for the host_find_failed and host_all_ignored options. */
# 782 "src/macros.h"
/* Router information flags */




/* Codes for match types in match_check_list; to any of them, MCL_NOEXPAND may
be added */



enum { MCL_STRING, MCL_DOMAIN, MCL_HOST, MCL_ADDRESS, MCL_LOCALPART };

/* Codes for the places from which ACLs can be called. These are cunningly
ordered to make it easy to implement tests for certain ACLs when processing
"control" modifiers, by means of a maximum "where" value. Do not modify this
order without checking carefully!

**** IMPORTANT***
****   Furthermore, remember to keep these in step with the tables
****   of names and response codes in globals.c.
**** IMPORTANT ****
*/

enum { ACL_WHERE_RCPT, /* Some controls are for RCPT only */
       ACL_WHERE_MAIL, /* )                                           */
       ACL_WHERE_PREDATA, /* ) There are several tests for "in message", */
       ACL_WHERE_MIME, /* ) implemented by <= WHERE_NOTSMTP           */
       ACL_WHERE_DKIM, /* )                                           */
       ACL_WHERE_DATA, /* )                                           */
       ACL_WHERE_NOTSMTP, /* )                                           */

       ACL_WHERE_AUTH, /* These remaining ones are not currently    */
       ACL_WHERE_CONNECT, /* required to be in a special order so they */
       ACL_WHERE_ETRN, /* are just alphabetical.                    */
       ACL_WHERE_EXPN,
       ACL_WHERE_HELO,
       ACL_WHERE_MAILAUTH,
       ACL_WHERE_NOTSMTP_START,
       ACL_WHERE_NOTQUIT,
       ACL_WHERE_QUIT,
       ACL_WHERE_STARTTLS,
       ACL_WHERE_VRFY
     };

/* Situations for spool_write_header() */

enum { SW_RECEIVING, SW_DELIVERING, SW_MODIFYING };

/* MX fields for hosts not obtained from MX records are always negative.
MX_NONE is the default case; lesser values are used when the hosts are
randomized in batches. */



/* host_item.port defaults to PORT_NONE; the only current case where this
is changed before running the transport is when an dnslookup router sets an
explicit port number. */



/* Flags for single-key search defaults */




/* Filter types */

enum { FILTER_UNSET, FILTER_FORWARD, FILTER_EXIM, FILTER_SIEVE };

/* End of macros.h */
# 469 "src/exim.h" 2
# 1 "src/dbstuff.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2009 */
/* See the file NOTICE for conditions of use and distribution. */

/* This header file contains macro definitions so that a variety of DBM
libraries can be used by Exim. Nigel Metheringham provided the original set for
Berkeley DB 1.x in native mode and ndbm. Subsequently, versions for Berkeley DB
2.x and 3.x were added. Later still, support for tdb was added, courtesy of
James Antill. Most recently, support for native mode gdbm was added, with code
from Pierre A. Humblet, so Exim could be made to work with Cygwin.

For convenience, the definitions of the structures used in the various hints
databases are also kept in this file, which is used by the maintenance
utilities as well as the main Exim binary. */
# 101 "src/dbstuff.h"
# 1 "/usr/include/db.h" 1 3 4
/*
 * See the file LICENSE for redistribution information.
 *
 * Copyright (c) 1996, 2012 Oracle and/or its affiliates.  All rights reserved.
 *
 * $Id$
 *
 * db.h include file layout:
 *	General.
 *	Database Environment.
 *	Locking subsystem.
 *	Logging subsystem.
 *	Shared buffer cache (mpool) subsystem.
 *	Transaction subsystem.
 *	Access methods.
 *	Access method cursors.
 *	Dbm/Ndbm, Hsearch historic interfaces.
 */





# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 25 "/usr/include/db.h" 2 3 4
# 1 "/usr/include/inttypes.h" 1 3 4
/* Copyright (C) 1997-2001, 2004, 2007, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99: 7.8 Format conversion of integer types	<inttypes.h>
 */
# 26 "/usr/include/db.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 28 "/usr/include/db.h" 2 3 4
# 1 "/usr/include/stdio.h" 1 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991, 1994-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */
# 29 "/usr/include/db.h" 2 3 4
# 1 "/usr/include/unistd.h" 1 3 4
/* Copyright (C) 1991-2009, 2010, 2011, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>
 */
# 30 "/usr/include/db.h" 2 3 4
# 1 "/usr/include/pthread.h" 1 3 4
/* Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sched.h" 1 3 4
/* Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.
   Copyright (C) 1996,1997,1999,2001-2004,2007,2010,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 24 "/usr/include/sched.h" 2 3 4

/* Get type definitions.  */
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 27 "/usr/include/sched.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 30 "/usr/include/sched.h" 2 3 4



# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 34 "/usr/include/sched.h" 2 3 4







/* Get system specific constant and data structure definitions.  */
# 1 "/usr/include/bits/sched.h" 1 3 4
/* Definitions of constants and data structure for POSIX 1003.1b-1993
   scheduling interface.
   Copyright (C) 1996-1999,2001-2003,2005,2006,2007,2008,2009,2011,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 28 "/usr/include/bits/sched.h" 3 4
/* Scheduling algorithms.  */
# 40 "/usr/include/bits/sched.h" 3 4
/* Cloning flags.  */
# 72 "/usr/include/bits/sched.h" 3 4
/* The official definition.  */
struct sched_param
  {
    int __sched_priority;
  };




/* Clone current process.  */
extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) __attribute__ ((__nothrow__ , __leaf__));

/* Unshare the specified resources.  */
extern int unshare (int __flags) __attribute__ ((__nothrow__ , __leaf__));

/* Get index of currently used CPU.  */
extern int sched_getcpu (void) __attribute__ ((__nothrow__ , __leaf__));

/* Switch process to namespace of type NSTYPE indicated by FD.  */
extern int setns (int __fd, int __nstype) __attribute__ ((__nothrow__ , __leaf__));










/* Data structure to describe a process' schedulability.  */
struct __sched_param
  {
    int __sched_priority;
  };






/* Size definition for CPU sets.  */



/* Type for array elements in 'cpu_set_t'.  */
typedef unsigned long int __cpu_mask;

/* Basic access functions.  */



/* Data structure to describe CPU mask.  */
typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;

/* Access functions for CPU masks.  */
# 202 "/usr/include/bits/sched.h" 3 4


extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  __attribute__ ((__nothrow__ , __leaf__));
extern cpu_set_t *__sched_cpualloc (size_t __count) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void __sched_cpufree (cpu_set_t *__set) __attribute__ ((__nothrow__ , __leaf__));


# 43 "/usr/include/sched.h" 2 3 4
/* Define the real names for the elements of `struct sched_param'.  */





/* Set scheduling parameters for a process.  */
extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__));

/* Retrieve scheduling parameters for a particular process.  */
extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));

/* Set scheduling algorithm and/or parameters for a process.  */
extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));

/* Retrieve scheduling algorithm for a particular purpose.  */
extern int sched_getscheduler (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

/* Yield the processor.  */
extern int sched_yield (void) __attribute__ ((__nothrow__ , __leaf__));

/* Get maximum priority value for a scheduler.  */
extern int sched_get_priority_max (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));

/* Get minimum priority value for a scheduler.  */
extern int sched_get_priority_min (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));

/* Get the SCHED_RR interval for the named process.  */
extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __attribute__ ((__nothrow__ , __leaf__));



/* Access macros for `cpu_set'.  */
# 116 "/usr/include/sched.h" 3 4
/* Set the CPU affinity for a task */
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));

/* Get the CPU affinity for a task */
extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));



# 24 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 25 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
/* Copyright (C) 2002-2007, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/setjmp.h" 1 3 4
/* Copyright (C) 2001,2002,2003,2005,2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* Define the machine-dependent type `jmp_buf'.  x86-64 version.  */







# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 27 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 29 "/usr/include/pthread.h" 2 3 4


/* Detach state.  */
enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};


/* Mutex types.  */
enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL


  /* For compatibility.  */
  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};



/* Robust mutex or not flags.  */
enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};




/* Mutex protocols.  */
enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};



/* Mutex initializers.  */
# 111 "/usr/include/pthread.h" 3 4
/* Read-write lock types.  */

enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};

/* Define __PTHREAD_RWLOCK_INT_FLAGS_SHARED to 1 if pthread_rwlock_t
   has the shared field.  All 64-bit architectures have the shared field
   in pthread_rwlock_t.  */






/* Read-write lock initializers.  */
# 153 "/usr/include/pthread.h" 3 4
/* Scheduler inheritance.  */
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};


/* Scope handling.  */
enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};


/* Process shared or private flag.  */
enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};



/* Conditional variable handling.  */



/* Cleanup buffers */
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *); /* Function to call.  */
  void *__arg; /* Its argument.  */
  int __canceltype; /* Saved cancellation type. */
  struct _pthread_cleanup_buffer *__prev; /* Chaining of cleanup functions.  */
};

/* Cancellation */
enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};



/* Single execution handling.  */




/* Value returned by 'pthread_barrier_wait' for one of the threads after
   the required number of threads have called this function.
   -1 is distinct from 0 and all errno constants */






/* Create a new thread, starting with execution of START-ROUTINE
   getting passed ARG.  Creation attributed come from ATTR.  The new
   handle is stored in *NEWTHREAD.  */
extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));

/* Terminate calling thread.

   The registered cleanup handlers are called via exception handling
   so we cannot mark this function with __THROW.*/
extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));

/* Make calling thread wait for termination of the thread TH.  The
   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN
   is not NULL.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_join (pthread_t __th, void **__thread_return);


/* Check whether thread TH has terminated.  If yes return the status of
   the thread in *THREAD_RETURN, if THREAD_RETURN is not NULL.  */
extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __attribute__ ((__nothrow__ , __leaf__));

/* Make calling thread wait for termination of the thread TH, but only
   until TIMEOUT.  The exit status of the thread is stored in
   *THREAD_RETURN, if THREAD_RETURN is not NULL.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);


/* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.
   The resources of TH will therefore be freed immediately when it
   terminates, instead of waiting for another thread to perform PTHREAD_JOIN
   on it.  */
extern int pthread_detach (pthread_t __th) __attribute__ ((__nothrow__ , __leaf__));


/* Obtain the identifier of the current thread.  */
extern pthread_t pthread_self (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Compare two thread identifiers.  */
extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Thread attribute handling.  */

/* Initialize thread attribute *ATTR with default attributes
   (detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,
    no user-provided stack).  */
extern int pthread_attr_init (pthread_attr_t *__attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy thread attribute *ATTR.  */
extern int pthread_attr_destroy (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Get detach state attribute.  */
extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set detach state attribute.  */
extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Get the size of the guard area created for stack overflow protection.  */
extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the size of the guard area created for stack overflow protection.  */
extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return in *PARAM the scheduling parameters of *ATTR.  */
extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set scheduling parameters (priority, etc) in *ATTR according to PARAM.  */
extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Return in *POLICY the scheduling policy of *ATTR.  */
extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set scheduling policy in *ATTR according to POLICY.  */
extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return in *INHERIT the scheduling inheritance mode of *ATTR.  */
extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set scheduling inheritance mode in *ATTR according to INHERIT.  */
extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return in *SCOPE the scheduling contention scope of *ATTR.  */
extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set scheduling contention scope in *ATTR according to SCOPE.  */
extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return the previously set address for the stack.  */
extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));

/* Set the starting address of the stack of the thread to be created.
   Depending on whether the stack grows up or down the value must either
   be higher or lower than all the address in the memory block.  The
   minimal size of the block must be PTHREAD_STACK_MIN.  */
extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));

/* Return the currently used minimal stack size.  */
extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Add information about the minimum stack size needed for the thread
   to be started.  This size must never be less than PTHREAD_STACK_MIN
   and must also not exceed the system limits.  */
extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return the previously set address for the stack.  */
extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));

/* The following two interfaces are intended to replace the last two.  They
   require setting the address as well as the size since only setting the
   address will make the implementation on some architectures impossible.  */
extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Thread created with attribute ATTR will be limited to run only on
   the processors represented in CPUSET.  */
extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

/* Get bit set in CPUSET representing the processors threads created with
   ATTR can run on.  */
extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));


/* Initialize thread attribute *ATTR with attributes corresponding to the
   already running thread TH.  It shall be called on uninitialized ATTR
   and destroyed with pthread_attr_destroy when no longer needed.  */
extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* Functions for scheduling control.  */

/* Set the scheduling parameters for TARGET_THREAD according to POLICY
   and *PARAM.  */
extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

/* Return in *POLICY and *PARAM the scheduling parameters for TARGET_THREAD. */
extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

/* Set the scheduling priority for TARGET_THREAD.  */
extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     __attribute__ ((__nothrow__ , __leaf__));



/* Get thread name visible in the kernel and its interfaces.  */
extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

/* Set thread name visible in the kernel and its interfaces.  */
extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




/* Determine level of concurrency.  */
extern int pthread_getconcurrency (void) __attribute__ ((__nothrow__ , __leaf__));

/* Set new concurrency level to LEVEL.  */
extern int pthread_setconcurrency (int __level) __attribute__ ((__nothrow__ , __leaf__));



/* Yield the processor to another thread or process.
   This function is similar to the POSIX `sched_yield' function but
   might be differently implemented in the case of a m-on-n thread
   implementation.  */
extern int pthread_yield (void) __attribute__ ((__nothrow__ , __leaf__));


/* Limit specified thread TH to run only on the processors represented
   in CPUSET.  */
extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

/* Get bit set in CPUSET representing the processors TH can run on.  */
extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



/* Functions for handling initialization.  */

/* Guarantee that the initialization function INIT_ROUTINE will be called
   only once, even if pthread_once is executed several times with the
   same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or
   extern variable initialized to PTHREAD_ONCE_INIT.

   The initialization functions might throw exception which is why
   this function is not marked with __THROW.  */
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));


/* Functions for handling cancellation.

   Note that these functions are explicitly not marked to not throw an
   exception in C++ code.  If cancellation is implemented by unwinding
   this is necessary to have the compiler generate the unwind information.  */

/* Set cancelability state of current thread to STATE, returning old
   state in *OLDSTATE if OLDSTATE is not NULL.  */
extern int pthread_setcancelstate (int __state, int *__oldstate);

/* Set cancellation state of current thread to TYPE, returning the old
   type in *OLDTYPE if OLDTYPE is not NULL.  */
extern int pthread_setcanceltype (int __type, int *__oldtype);

/* Cancel THREAD immediately or at the next possibility.  */
extern int pthread_cancel (pthread_t __th);

/* Test for pending cancellation for the current thread and terminate
   the thread as per pthread_exit(PTHREAD_CANCELED) if it has been
   cancelled.  */
extern void pthread_testcancel (void);


/* Cancellation handling with integration into exception handling.  */

typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));

/* No special attributes by default.  */





/* Structure to hold the cleanup handler information.  */
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 648 "/usr/include/pthread.h" 3 4
/* Install a cleanup handler: ROUTINE will be called with arguments ARG
   when the thread is canceled or calls pthread_exit.  ROUTINE will also
   be called with arguments ARG when the matching pthread_cleanup_pop
   is executed with non-zero EXECUTE argument.

   pthread_cleanup_push and pthread_cleanup_pop are macros and must always
   be used in matching pairs at the same nesting level of braces.  */
# 671 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
     ;

/* Remove a cleanup handler installed by the matching pthread_cleanup_push.
   If EXECUTE is non-zero, the handler function is called. */







extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
  ;


/* Install a cleanup handler as pthread_cleanup_push does, but also
   saves the current cancellation type and sets it to deferred
   cancellation.  */
# 706 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
     ;

/* Remove a cleanup handler as pthread_cleanup_pop does, but also
   restores the cancellation type that was in effect when the matching
   pthread_cleanup_push_defer was called.  */







extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
  ;


/* Internal interface to initiate cleanup.  */
extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;


/* Function used in the macros.  */
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __attribute__ ((__nothrow__));


/* Mutex handling.  */

/* Initialize a mutex.  */
extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy a mutex.  */
extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Try locking a mutex.  */
extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Lock a mutex.  */
extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


/* Wait until lock becomes available, or specified time passes. */
extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


/* Unlock a mutex.  */
extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


/* Get the priority ceiling of MUTEX.  */
extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the priority ceiling of MUTEX to PRIOCEILING, return old
   priority ceiling value in *OLD_CEILING.  */
extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



/* Declare the state protected by MUTEX as consistent.  */
extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Functions for handling mutex attributes.  */

/* Initialize mutex attribute object ATTR with default attributes
   (kind is PTHREAD_MUTEX_TIMED_NP).  */
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy mutex attribute object ATTR.  */
extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Get the process-shared flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the process-shared flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return in *KIND the mutex kind attribute in *ATTR.  */
extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,
   PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or
   PTHREAD_MUTEX_DEFAULT).  */
extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return in *PROTOCOL the mutex protocol attribute in *ATTR.  */
extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the mutex protocol attribute in *ATTR to PROTOCOL (either
   PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, or PTHREAD_PRIO_PROTECT).  */
extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return in *PRIOCEILING the mutex prioceiling attribute in *ATTR.  */
extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the mutex prioceiling attribute in *ATTR to PRIOCEILING.  */
extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Get the robustness flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


/* Set the robustness flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





/* Functions for handling read-write locks.  */

/* Initialize read-write lock RWLOCK using attributes ATTR, or use
   the default values if later is NULL.  */
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy read-write lock RWLOCK.  */
extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Acquire read lock for RWLOCK.  */
extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Try to acquire read lock for RWLOCK.  */
extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


/* Try to acquire read lock for RWLOCK or return after specfied time.  */
extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


/* Acquire write lock for RWLOCK.  */
extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Try to acquire write lock for RWLOCK.  */
extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


/* Try to acquire write lock for RWLOCK or return after specfied time.  */
extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


/* Unlock RWLOCK.  */
extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


/* Functions for handling read-write lock attributes.  */

/* Initialize attribute object ATTR with default values.  */
extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy attribute object ATTR.  */
extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return current setting of process-shared attribute of ATTR in PSHARED.  */
extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set process-shared attribute of ATTR to PSHARED.  */
extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return current setting of reader/writer preference.  */
extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set reader/write preference.  */
extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Functions for handling conditional variables.  */

/* Initialize condition variable COND using attributes ATTR, or use
   the default values if later is NULL.  */
extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy condition variable COND.  */
extern int pthread_cond_destroy (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Wake up one thread waiting for condition variable COND.  */
extern int pthread_cond_signal (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Wake up all threads waiting for condition variables COND.  */
extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Wait for condition variable COND to be signaled or broadcast.
   MUTEX is assumed to be locked before.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));

/* Wait for condition variable COND to be signaled or broadcast until
   ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an
   absolute time specification; zero is the beginning of the epoch
   (00:00:00 GMT, January 1, 1970).

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));

/* Functions for handling condition variable attributes.  */

/* Initialize condition variable attribute ATTR.  */
extern int pthread_condattr_init (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy condition variable attribute ATTR.  */
extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Get the process-shared flag of the condition variable attribute ATTR.  */
extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the process-shared flag of the condition variable attribute ATTR.  */
extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Get the clock selected for the conditon variable attribute ATTR.  */
extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the clock selected for the conditon variable attribute ATTR.  */
extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Functions to handle spinlocks.  */

/* Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can
   be shared between different processes.  */
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy the spinlock LOCK.  */
extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Wait until spinlock LOCK is retrieved.  */
extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Try to lock spinlock LOCK.  */
extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Release spinlock LOCK.  */
extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


/* Functions to handle barriers.  */

/* Initialize BARRIER with the attributes in ATTR.  The barrier is
   opened when COUNT waiters arrived.  */
extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy a previously dynamically initialized barrier BARRIER.  */
extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Wait on barrier BARRIER.  */
extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


/* Initialize barrier attribute ATTR.  */
extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy previously dynamically initialized barrier attribute ATTR.  */
extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Get the process-shared flag of the barrier attribute ATTR.  */
extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the process-shared flag of the barrier attribute ATTR.  */
extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Functions for handling thread-specific data.  */

/* Create a key value identifying a location in the thread-specific
   data area.  Each thread maintains a distinct thread-specific data
   area.  DESTR_FUNCTION, if non-NULL, is called with the value
   associated to that key when the key is destroyed.
   DESTR_FUNCTION is not called if the value associated is NULL when
   the key is destroyed.  */
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy KEY.  */
extern int pthread_key_delete (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));

/* Return current value of the thread-specific data slot identified by KEY.  */
extern void *pthread_getspecific (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));

/* Store POINTER in the thread-specific data slot identified by KEY. */
extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Get ID of CPU-time clock for thread THREAD_ID.  */
extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* Install handlers to be called when a new process is created with FORK.
   The PREPARE handler is called in the parent process just before performing
   FORK. The PARENT handler is called in the parent process just after FORK.
   The CHILD handler is called in the child process.  Each of the three
   handlers can be NULL, meaning that no handler needs to be called at that
   point.
   PTHREAD_ATFORK can be called several times, in which case the PREPARE
   handlers are called in LIFO order (last added with PTHREAD_ATFORK,
   first called before FORK), and the PARENT and CHILD handlers are called
   in FIFO (first added, first called).  */

extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) __attribute__ ((__nothrow__ , __leaf__));
# 1150 "/usr/include/pthread.h" 3 4

# 31 "/usr/include/db.h" 2 3 4
# 42 "/usr/include/db.h" 3 4
/*
 * Berkeley DB version information.
 */
# 53 "/usr/include/db.h" 3 4
/*
 * !!!
 * Berkeley DB uses specifically sized types.  If they're not provided by
 * the system, typedef them here.
 *
 * We protect them against multiple inclusion using __BIT_TYPES_DEFINED__,
 * as does BIND and Kerberos, since we don't know for sure what #include
 * files the user is using.
 *
 * !!!
 * We also provide the standard u_int, u_long etc., if they're not provided
 * by the system.
 */
# 82 "/usr/include/db.h" 3 4
/*
 * Missing ANSI types.
 *
 * uintmax_t --
 * Largest unsigned type, used to align structures in memory.  We don't store
 * floating point types in structures, so integral types should be sufficient
 * (and we don't have to worry about systems that store floats in other than
 * power-of-2 numbers of bytes).  Additionally this fixes compilers that rewrite
 * structure assignments and ANSI C memcpy calls to be in-line instructions
 * that happen to require alignment.
 *
 * uintptr_t --
 * Unsigned type that's the same size as a pointer.  There are places where
 * DB modifies pointers by discarding the bottom bits to guarantee alignment.
 * We can't use uintmax_t, it may be larger than the pointer, and compilers
 * get upset about that.  So far we haven't run on any machine where there's
 * no unsigned type the same size as a pointer -- here's hoping.
 */
# 110 "/usr/include/db.h" 3 4
typedef size_t db_size_t;





typedef ssize_t db_ssize_t;



/*
 * Sequences are only available on machines with 64-bit integral types.
 */
typedef long db_seq_t;

/* Thread and process identification. */
typedef pthread_t db_threadid_t;

/* Basic types that are exported or quasi-exported. */
typedef u_int32_t db_pgno_t; /* Page number type. */
typedef u_int16_t db_indx_t; /* Page offset type. */


typedef u_int32_t db_recno_t; /* Record number type. */


typedef u_int32_t db_timeout_t; /* Type of a timeout. */

/*
 * Region offsets are the difference between a pointer in a region and the
 * region's base address.  With private environments, both addresses are the
 * result of calling malloc, and we can't assume anything about what malloc
 * will return, so region offsets have to be able to hold differences between
 * arbitrary pointers.
 */
typedef db_size_t roff_t;

/*
 * Forward structure declarations, so we can declare pointers and
 * applications can get type checking.
 */
struct __channel; typedef struct __channel CHANNEL;
struct __db; typedef struct __db DB;
struct __db_bt_stat; typedef struct __db_bt_stat DB_BTREE_STAT;
struct __db_channel; typedef struct __db_channel DB_CHANNEL;
struct __db_cipher; typedef struct __db_cipher DB_CIPHER;
struct __db_compact; typedef struct __db_compact DB_COMPACT;
struct __db_dbt; typedef struct __db_dbt DBT;
struct __db_distab; typedef struct __db_distab DB_DISTAB;
struct __db_env; typedef struct __db_env DB_ENV;
struct __db_h_stat; typedef struct __db_h_stat DB_HASH_STAT;
struct __db_heap_rid; typedef struct __db_heap_rid DB_HEAP_RID;
struct __db_heap_stat; typedef struct __db_heap_stat DB_HEAP_STAT;
struct __db_ilock; typedef struct __db_ilock DB_LOCK_ILOCK;
struct __db_lock_hstat; typedef struct __db_lock_hstat DB_LOCK_HSTAT;
struct __db_lock_pstat; typedef struct __db_lock_pstat DB_LOCK_PSTAT;
struct __db_lock_stat; typedef struct __db_lock_stat DB_LOCK_STAT;
struct __db_lock_u; typedef struct __db_lock_u DB_LOCK;
struct __db_locker; typedef struct __db_locker DB_LOCKER;
struct __db_lockreq; typedef struct __db_lockreq DB_LOCKREQ;
struct __db_locktab; typedef struct __db_locktab DB_LOCKTAB;
struct __db_log; typedef struct __db_log DB_LOG;
struct __db_log_cursor; typedef struct __db_log_cursor DB_LOGC;
struct __db_log_stat; typedef struct __db_log_stat DB_LOG_STAT;
struct __db_lsn; typedef struct __db_lsn DB_LSN;
struct __db_mpool; typedef struct __db_mpool DB_MPOOL;
struct __db_mpool_fstat;typedef struct __db_mpool_fstat DB_MPOOL_FSTAT;
struct __db_mpool_stat; typedef struct __db_mpool_stat DB_MPOOL_STAT;
struct __db_mpoolfile; typedef struct __db_mpoolfile DB_MPOOLFILE;
struct __db_mutex_stat; typedef struct __db_mutex_stat DB_MUTEX_STAT;
struct __db_mutex_t; typedef struct __db_mutex_t DB_MUTEX;
struct __db_mutexmgr; typedef struct __db_mutexmgr DB_MUTEXMGR;
struct __db_preplist; typedef struct __db_preplist DB_PREPLIST;
struct __db_qam_stat; typedef struct __db_qam_stat DB_QUEUE_STAT;
struct __db_rep; typedef struct __db_rep DB_REP;
struct __db_rep_stat; typedef struct __db_rep_stat DB_REP_STAT;
struct __db_repmgr_conn_err;
 typedef struct __db_repmgr_conn_err DB_REPMGR_CONN_ERR;
struct __db_repmgr_site;typedef struct __db_repmgr_site DB_REPMGR_SITE;
struct __db_repmgr_stat;typedef struct __db_repmgr_stat DB_REPMGR_STAT;
struct __db_seq_record; typedef struct __db_seq_record DB_SEQ_RECORD;
struct __db_seq_stat; typedef struct __db_seq_stat DB_SEQUENCE_STAT;
struct __db_site; typedef struct __db_site DB_SITE;
struct __db_sequence; typedef struct __db_sequence DB_SEQUENCE;
struct __db_thread_info;typedef struct __db_thread_info DB_THREAD_INFO;
struct __db_txn; typedef struct __db_txn DB_TXN;
struct __db_txn_active; typedef struct __db_txn_active DB_TXN_ACTIVE;
struct __db_txn_stat; typedef struct __db_txn_stat DB_TXN_STAT;
struct __db_txn_token; typedef struct __db_txn_token DB_TXN_TOKEN;
struct __db_txnmgr; typedef struct __db_txnmgr DB_TXNMGR;
struct __dbc; typedef struct __dbc DBC;
struct __dbc_internal; typedef struct __dbc_internal DBC_INTERNAL;
struct __env; typedef struct __env ENV;
struct __fh_t; typedef struct __fh_t DB_FH;
struct __fname; typedef struct __fname FNAME;
struct __key_range; typedef struct __key_range DB_KEY_RANGE;
struct __mpoolfile; typedef struct __mpoolfile MPOOLFILE;
struct __db_logvrfy_config;
typedef struct __db_logvrfy_config DB_LOG_VERIFY_CONFIG;

/*
 * The Berkeley DB API flags are automatically-generated -- the following flag
 * names are no longer used, but remain for compatibility reasons.
 */




/* Key/data structure -- a Data-Base Thang. */
struct __db_dbt {
 void *data; /* Key/data */
 u_int32_t size; /* key/data length */

 u_int32_t ulen; /* RO: length of user buffer. */
 u_int32_t dlen; /* RO: get/put record length. */
 u_int32_t doff; /* RO: get/put record offset. */

 void *app_data;
# 241 "/usr/include/db.h" 3 4
 u_int32_t flags;
};

/*******************************************************
 * Mutexes.
 *******************************************************/
/* 
 * When mixed size addressing is supported mutexes need to be the same size
 * independent of the process address size is.
 */



typedef uintptr_t db_mutex_t;


struct __db_mutex_stat { /* SHARED */
 /* The following fields are maintained in the region's copy. */
 u_int32_t st_mutex_align; /* Mutex alignment */
 u_int32_t st_mutex_tas_spins; /* Mutex test-and-set spins */
 u_int32_t st_mutex_init; /* Initial mutex count */
 u_int32_t st_mutex_cnt; /* Mutex count */
 u_int32_t st_mutex_max; /* Mutex max */
 u_int32_t st_mutex_free; /* Available mutexes */
 u_int32_t st_mutex_inuse; /* Mutexes in use */
 u_int32_t st_mutex_inuse_max; /* Maximum mutexes ever in use */

 /* The following fields are filled-in from other places. */

 uintmax_t st_region_wait; /* Region lock granted after wait. */
 uintmax_t st_region_nowait; /* Region lock granted without wait. */
 roff_t st_regsize; /* Region size. */
 roff_t st_regmax; /* Region max. */

};

/* This is the length of the buffer passed to DB_ENV->thread_id_string() */


/*******************************************************
 * Locking.
 *******************************************************/




/*
 * Deadlock detector modes; used in the DB_ENV structure to configure the
 * locking subsystem.
 */
# 302 "/usr/include/db.h" 3 4
/*
 * Simple R/W lock modes and for multi-granularity intention locking.
 *
 * !!!
 * These values are NOT random, as they are used as an index into the lock
 * conflicts arrays, i.e., DB_LOCK_IWRITE must be == 3, and DB_LOCK_IREAD
 * must be == 4.
 */
typedef enum {
 DB_LOCK_NG=0, /* Not granted. */
 DB_LOCK_READ=1, /* Shared/read. */
 DB_LOCK_WRITE=2, /* Exclusive/write. */
 DB_LOCK_WAIT=3, /* Wait for event */
 DB_LOCK_IWRITE=4, /* Intent exclusive/write. */
 DB_LOCK_IREAD=5, /* Intent to share/read. */
 DB_LOCK_IWR=6, /* Intent to read and write. */
 DB_LOCK_READ_UNCOMMITTED=7, /* Degree 1 isolation. */
 DB_LOCK_WWRITE=8 /* Was Written. */
} db_lockmode_t;

/*
 * Request types.
 */
typedef enum {
 DB_LOCK_DUMP=0, /* Display held locks. */
 DB_LOCK_GET=1, /* Get the lock. */
 DB_LOCK_GET_TIMEOUT=2, /* Get lock with a timeout. */
 DB_LOCK_INHERIT=3, /* Pass locks to parent. */
 DB_LOCK_PUT=4, /* Release the lock. */
 DB_LOCK_PUT_ALL=5, /* Release locker's locks. */
 DB_LOCK_PUT_OBJ=6, /* Release locker's locks on obj. */
 DB_LOCK_PUT_READ=7, /* Release locker's read locks. */
 DB_LOCK_TIMEOUT=8, /* Force a txn to timeout. */
 DB_LOCK_TRADE=9, /* Trade locker ids on a lock. */
 DB_LOCK_UPGRADE_WRITE=10 /* Upgrade writes for dirty reads. */
} db_lockop_t;

/*
 * Status of a lock.
 */
typedef enum {
 DB_LSTAT_ABORTED=1, /* Lock belongs to an aborted txn. */
 DB_LSTAT_EXPIRED=2, /* Lock has expired. */
 DB_LSTAT_FREE=3, /* Lock is unallocated. */
 DB_LSTAT_HELD=4, /* Lock is currently held. */
 DB_LSTAT_PENDING=5, /* Lock was waiting and has been
					 * promoted; waiting for the owner
					 * to run and upgrade it to held. */
 DB_LSTAT_WAITING=6 /* Lock is on the wait queue. */
}db_status_t;

/* Lock statistics structure. */
struct __db_lock_stat { /* SHARED */
 u_int32_t st_id; /* Last allocated locker ID. */
 u_int32_t st_cur_maxid; /* Current maximum unused ID. */
 u_int32_t st_initlocks; /* Initial number of locks in table. */
 u_int32_t st_initlockers; /* Initial num of lockers in table. */
 u_int32_t st_initobjects; /* Initial num of objects in table. */
 u_int32_t st_locks; /* Current number of locks in table. */
 u_int32_t st_lockers; /* Current num of lockers in table. */
 u_int32_t st_objects; /* Current num of objects in table. */
 u_int32_t st_maxlocks; /* Maximum number of locks in table. */
 u_int32_t st_maxlockers; /* Maximum num of lockers in table. */
 u_int32_t st_maxobjects; /* Maximum num of objects in table. */
 u_int32_t st_partitions; /* number of partitions. */
 u_int32_t st_tablesize; /* Size of object hash table. */
 int32_t st_nmodes; /* Number of lock modes. */
 u_int32_t st_nlockers; /* Current number of lockers. */

 u_int32_t st_nlocks; /* Current number of locks. */
 u_int32_t st_maxnlocks; /* Maximum number of locks so far. */
 u_int32_t st_maxhlocks; /* Maximum number of locks in any bucket. */
 uintmax_t st_locksteals; /* Number of lock steals so far. */
 uintmax_t st_maxlsteals; /* Maximum number steals in any partition. */
 u_int32_t st_maxnlockers; /* Maximum number of lockers so far. */
 u_int32_t st_nobjects; /* Current number of objects. */
 u_int32_t st_maxnobjects; /* Maximum number of objects so far. */
 u_int32_t st_maxhobjects; /* Maximum number of objectsin any bucket. */
 uintmax_t st_objectsteals; /* Number of objects steals so far. */
 uintmax_t st_maxosteals; /* Maximum number of steals in any partition. */
 uintmax_t st_nrequests; /* Number of lock gets. */
 uintmax_t st_nreleases; /* Number of lock puts. */
 uintmax_t st_nupgrade; /* Number of lock upgrades. */
 uintmax_t st_ndowngrade; /* Number of lock downgrades. */
 uintmax_t st_lock_wait; /* Lock conflicts w/ subsequent wait */
 uintmax_t st_lock_nowait; /* Lock conflicts w/o subsequent wait */
 uintmax_t st_ndeadlocks; /* Number of lock deadlocks. */
 db_timeout_t st_locktimeout; /* Lock timeout. */
 uintmax_t st_nlocktimeouts; /* Number of lock timeouts. */
 db_timeout_t st_txntimeout; /* Transaction timeout. */
 uintmax_t st_ntxntimeouts; /* Number of transaction timeouts. */
 uintmax_t st_part_wait; /* Partition lock granted after wait. */
 uintmax_t st_part_nowait; /* Partition lock granted without wait. */
 uintmax_t st_part_max_wait; /* Max partition lock granted after wait. */
 uintmax_t st_part_max_nowait; /* Max partition lock granted without wait. */
 uintmax_t st_objs_wait; /* 	Object lock granted after wait. */
 uintmax_t st_objs_nowait; /* Object lock granted without wait. */
 uintmax_t st_lockers_wait; /* Locker lock granted after wait. */
 uintmax_t st_lockers_nowait; /* Locker lock granted without wait. */
 uintmax_t st_region_wait; /* Region lock granted after wait. */
 uintmax_t st_region_nowait; /* Region lock granted without wait. */
 u_int32_t st_hash_len; /* Max length of bucket. */
 roff_t st_regsize; /* Region size. */

};

struct __db_lock_hstat { /* SHARED */
 uintmax_t st_nrequests; /* Number of lock gets. */
 uintmax_t st_nreleases; /* Number of lock puts. */
 uintmax_t st_nupgrade; /* Number of lock upgrades. */
 uintmax_t st_ndowngrade; /* Number of lock downgrades. */
 u_int32_t st_nlocks; /* Current number of locks. */
 u_int32_t st_maxnlocks; /* Maximum number of locks so far. */
 u_int32_t st_nobjects; /* Current number of objects. */
 u_int32_t st_maxnobjects; /* Maximum number of objects so far. */
 uintmax_t st_lock_wait; /* Lock conflicts w/ subsequent wait */
 uintmax_t st_lock_nowait; /* Lock conflicts w/o subsequent wait */
 uintmax_t st_nlocktimeouts; /* Number of lock timeouts. */
 uintmax_t st_ntxntimeouts; /* Number of transaction timeouts. */
 u_int32_t st_hash_len; /* Max length of bucket. */
};

struct __db_lock_pstat { /* SHARED */
 u_int32_t st_nlocks; /* Current number of locks. */
 u_int32_t st_maxnlocks; /* Maximum number of locks so far. */
 u_int32_t st_nobjects; /* Current number of objects. */
 u_int32_t st_maxnobjects; /* Maximum number of objects so far. */
 uintmax_t st_locksteals; /* Number of lock steals so far. */
 uintmax_t st_objectsteals; /* Number of objects steals so far. */
};

/*
 * DB_LOCK_ILOCK --
 *	Internal DB access method lock.
 */
struct __db_ilock { /* SHARED */
 db_pgno_t pgno; /* Page being locked. */
 u_int8_t fileid[20];/* File id. */




 u_int32_t type; /* Type of lock. */
};

/*
 * DB_LOCK --
 *	The structure is allocated by the caller and filled in during a
 *	lock_get request (or a lock_vec/DB_LOCK_GET).
 */
struct __db_lock_u { /* SHARED */
 roff_t off; /* Offset of the lock in the region */
 u_int32_t ndx; /* Index of the object referenced by
					 * this lock; used for locking. */
 u_int32_t gen; /* Generation number of this lock. */
 db_lockmode_t mode; /* mode of this lock. */
};

/* Lock request structure. */
struct __db_lockreq {
 db_lockop_t op; /* Operation. */
 db_lockmode_t mode; /* Requested mode. */
 db_timeout_t timeout; /* Time to expire lock. */
 DBT *obj; /* Object being locked. */
 DB_LOCK lock; /* Lock returned. */
};

/*******************************************************
 * Logging.
 *******************************************************/






/*
 * A DB_LSN has two parts, a fileid which identifies a specific file, and an
 * offset within that file.  The fileid is an unsigned 4-byte quantity that
 * uniquely identifies a file within the log directory -- currently a simple
 * counter inside the log.  The offset is also an unsigned 4-byte value.  The
 * log manager guarantees the offset is never more than 4 bytes by switching
 * to a new log file before the maximum length imposed by an unsigned 4-byte
 * offset is reached.
 */
struct __db_lsn { /* SHARED */
 u_int32_t file; /* File ID. */
 u_int32_t offset; /* File offset. */
};

/*
 * Application-specified log record types start at DB_user_BEGIN, and must not
 * equal or exceed DB_debug_FLAG.
 *
 * DB_debug_FLAG is the high-bit of the u_int32_t that specifies a log record
 * type.  If the flag is set, it's a log record that was logged for debugging
 * purposes only, even if it reflects a database change -- the change was part
 * of a non-durable transaction.
 */



/*
 * DB_LOGC --
 *	Log cursor.
 */
struct __db_log_cursor {
 ENV *env; /* Environment */

 DB_FH *fhp; /* File handle. */
 DB_LSN lsn; /* Cursor: LSN */
 u_int32_t len; /* Cursor: record length */
 u_int32_t prev; /* Cursor: previous record's offset */

 DBT dbt; /* Return DBT. */
 DB_LSN p_lsn; /* Persist LSN. */
 u_int32_t p_version; /* Persist version. */

 u_int8_t *bp; /* Allocated read buffer. */
 u_int32_t bp_size; /* Read buffer length in bytes. */
 u_int32_t bp_rlen; /* Read buffer valid data length. */
 DB_LSN bp_lsn; /* Read buffer first byte LSN. */

 u_int32_t bp_maxrec; /* Max record length in the log file. */

 /* DB_LOGC PUBLIC HANDLE LIST BEGIN */
 int (*close) (DB_LOGC *, u_int32_t);
 int (*get) (DB_LOGC *, DB_LSN *, DBT *, u_int32_t);
 int (*version) (DB_LOGC *, u_int32_t *, u_int32_t);
 /* DB_LOGC PUBLIC HANDLE LIST END */




 u_int32_t flags;
};

/* Log statistics structure. */
struct __db_log_stat { /* SHARED */
 u_int32_t st_magic; /* Log file magic number. */
 u_int32_t st_version; /* Log file version number. */
 int32_t st_mode; /* Log file permissions mode. */
 u_int32_t st_lg_bsize; /* Log buffer size. */
 u_int32_t st_lg_size; /* Log file size. */
 u_int32_t st_wc_bytes; /* Bytes to log since checkpoint. */
 u_int32_t st_wc_mbytes; /* Megabytes to log since checkpoint. */
 u_int32_t st_fileid_init; /* Initial allocation for fileids. */

 u_int32_t st_nfileid; /* Current number of fileids. */
 u_int32_t st_maxnfileid; /* Maximum number of fileids used. */
 uintmax_t st_record; /* Records entered into the log. */
 u_int32_t st_w_bytes; /* Bytes to log. */
 u_int32_t st_w_mbytes; /* Megabytes to log. */
 uintmax_t st_wcount; /* Total I/O writes to the log. */
 uintmax_t st_wcount_fill; /* Overflow writes to the log. */
 uintmax_t st_rcount; /* Total I/O reads from the log. */
 uintmax_t st_scount; /* Total syncs to the log. */
 uintmax_t st_region_wait; /* Region lock granted after wait. */
 uintmax_t st_region_nowait; /* Region lock granted without wait. */
 u_int32_t st_cur_file; /* Current log file number. */
 u_int32_t st_cur_offset; /* Current log file offset. */
 u_int32_t st_disk_file; /* Known on disk log file number. */
 u_int32_t st_disk_offset; /* Known on disk log file offset. */
 u_int32_t st_maxcommitperflush; /* Max number of commits in a flush. */
 u_int32_t st_mincommitperflush; /* Min number of commits in a flush. */
 roff_t st_regsize; /* Region size. */

};

/*
 * We need to record the first log record of a transaction.  For user
 * defined logging this macro returns the place to put that information,
 * if it is need in rlsnp, otherwise it leaves it unchanged.  We also
 * need to track the last record of the transaction, this returns the
 * place to put that info.
 */



/*
 * Definition of the structure which specifies marshalling of log records.
 */
typedef enum {
 LOGREC_Done,
 LOGREC_ARG,
 LOGREC_HDR,
 LOGREC_DATA,
 LOGREC_DB,
 LOGREC_DBOP,
 LOGREC_DBT,
 LOGREC_LOCKS,
 LOGREC_OP,
 LOGREC_PGDBT,
 LOGREC_PGDDBT,
 LOGREC_PGLIST,
 LOGREC_POINTER,
 LOGREC_TIME
} log_rec_type_t;

typedef const struct __log_rec_spec {
 log_rec_type_t type;
 u_int32_t offset;
 const char *name;
 const char fmt[4];
} DB_LOG_RECSPEC;

/*
 * Size of a DBT in a log record.
 */



/*******************************************************
 * Shared buffer cache (mpool).
 *******************************************************/
/* Priority values for DB_MPOOLFILE->{put,set_priority}. */
typedef enum {
 DB_PRIORITY_UNCHANGED=0,
 DB_PRIORITY_VERY_LOW=1,
 DB_PRIORITY_LOW=2,
 DB_PRIORITY_DEFAULT=3,
 DB_PRIORITY_HIGH=4,
 DB_PRIORITY_VERY_HIGH=5
} DB_CACHE_PRIORITY;

/* Per-process DB_MPOOLFILE information. */
struct __db_mpoolfile {
 DB_FH *fhp; /* Underlying file handle. */

 /*
	 * !!!
	 * The ref, pinref and q fields are protected by the region lock.
	 */
 u_int32_t ref; /* Reference count. */

 u_int32_t pinref; /* Pinned block reference count. */

 /*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__db_mpoolfile) q;
	 */
 struct {
  struct __db_mpoolfile *tqe_next;
  struct __db_mpoolfile **tqe_prev;
 } q; /* Linked list of DB_MPOOLFILE's. */

 /*
	 * !!!
	 * The rest of the fields (with the exception of the MP_FLUSH flag)
	 * are not thread-protected, even when they may be modified at any
	 * time by the application.  The reason is the DB_MPOOLFILE handle
	 * is single-threaded from the viewpoint of the application, and so
	 * the only fields needing to be thread-protected are those accessed
	 * by checkpoint or sync threads when using DB_MPOOLFILE structures
	 * to flush buffers from the cache.
	 */
 ENV *env; /* Environment */
 MPOOLFILE *mfp; /* Underlying MPOOLFILE. */

 u_int32_t clear_len; /* Cleared length on created pages. */
 u_int8_t /* Unique file ID. */
   fileid[20];
 int ftype; /* File type. */
 int32_t lsn_offset; /* LSN offset in page. */
 u_int32_t gbytes, bytes; /* Maximum file size. */
 DBT *pgcookie; /* Byte-string passed to pgin/pgout. */
 int32_t priority; /* Cache priority. */

 void *addr; /* Address of mmap'd region. */
 size_t len; /* Length of mmap'd region. */

 u_int32_t config_flags; /* Flags to DB_MPOOLFILE->set_flags. */

 /* DB_MPOOLFILE PUBLIC HANDLE LIST BEGIN */
 int (*close) (DB_MPOOLFILE *, u_int32_t);
 int (*get)
     (DB_MPOOLFILE *, db_pgno_t *, DB_TXN *, u_int32_t, void *);
 int (*get_clear_len) (DB_MPOOLFILE *, u_int32_t *);
 int (*get_fileid) (DB_MPOOLFILE *, u_int8_t *);
 int (*get_flags) (DB_MPOOLFILE *, u_int32_t *);
 int (*get_ftype) (DB_MPOOLFILE *, int *);
 int (*get_last_pgno) (DB_MPOOLFILE *, db_pgno_t *);
 int (*get_lsn_offset) (DB_MPOOLFILE *, int32_t *);
 int (*get_maxsize) (DB_MPOOLFILE *, u_int32_t *, u_int32_t *);
 int (*get_pgcookie) (DB_MPOOLFILE *, DBT *);
 int (*get_priority) (DB_MPOOLFILE *, DB_CACHE_PRIORITY *);
 int (*open) (DB_MPOOLFILE *, const char *, u_int32_t, int, size_t);
 int (*put) (DB_MPOOLFILE *, void *, DB_CACHE_PRIORITY, u_int32_t);
 int (*set_clear_len) (DB_MPOOLFILE *, u_int32_t);
 int (*set_fileid) (DB_MPOOLFILE *, u_int8_t *);
 int (*set_flags) (DB_MPOOLFILE *, u_int32_t, int);
 int (*set_ftype) (DB_MPOOLFILE *, int);
 int (*set_lsn_offset) (DB_MPOOLFILE *, int32_t);
 int (*set_maxsize) (DB_MPOOLFILE *, u_int32_t, u_int32_t);
 int (*set_pgcookie) (DB_MPOOLFILE *, DBT *);
 int (*set_priority) (DB_MPOOLFILE *, DB_CACHE_PRIORITY);
 int (*sync) (DB_MPOOLFILE *);
 /* DB_MPOOLFILE PUBLIC HANDLE LIST END */

 /*
	 * MP_FILEID_SET, MP_OPEN_CALLED and MP_READONLY do not need to be
	 * thread protected because they are initialized before the file is
	 * linked onto the per-process lists, and never modified.
	 *
	 * MP_FLUSH is thread protected because it is potentially read/set by
	 * multiple threads of control.
	 */







 u_int32_t flags;
};

/* Mpool statistics structure. */
struct __db_mpool_stat { /* SHARED */
 u_int32_t st_gbytes; /* Total cache size: GB. */
 u_int32_t st_bytes; /* Total cache size: B. */
 u_int32_t st_ncache; /* Number of cache regions. */
 u_int32_t st_max_ncache; /* Maximum number of regions. */
 db_size_t st_mmapsize; /* Maximum file size for mmap. */
 int32_t st_maxopenfd; /* Maximum number of open fd's. */
 int32_t st_maxwrite; /* Maximum buffers to write. */
 db_timeout_t st_maxwrite_sleep; /* Sleep after writing max buffers. */
 u_int32_t st_pages; /* Total number of pages. */

 u_int32_t st_map; /* Pages from mapped files. */
 uintmax_t st_cache_hit; /* Pages found in the cache. */
 uintmax_t st_cache_miss; /* Pages not found in the cache. */
 uintmax_t st_page_create; /* Pages created in the cache. */
 uintmax_t st_page_in; /* Pages read in. */
 uintmax_t st_page_out; /* Pages written out. */
 uintmax_t st_ro_evict; /* Clean pages forced from the cache. */
 uintmax_t st_rw_evict; /* Dirty pages forced from the cache. */
 uintmax_t st_page_trickle; /* Pages written by memp_trickle. */
 u_int32_t st_page_clean; /* Clean pages. */
 u_int32_t st_page_dirty; /* Dirty pages. */
 u_int32_t st_hash_buckets; /* Number of hash buckets. */
 u_int32_t st_hash_mutexes; /* Number of hash bucket mutexes. */
 u_int32_t st_pagesize; /* Assumed page size. */
 u_int32_t st_hash_searches; /* Total hash chain searches. */
 u_int32_t st_hash_longest; /* Longest hash chain searched. */
 uintmax_t st_hash_examined; /* Total hash entries searched. */
 uintmax_t st_hash_nowait; /* Hash lock granted with nowait. */
 uintmax_t st_hash_wait; /* Hash lock granted after wait. */
 uintmax_t st_hash_max_nowait; /* Max hash lock granted with nowait. */
 uintmax_t st_hash_max_wait; /* Max hash lock granted after wait. */
 uintmax_t st_region_nowait; /* Region lock granted with nowait. */
 uintmax_t st_region_wait; /* Region lock granted after wait. */
 uintmax_t st_mvcc_frozen; /* Buffers frozen. */
 uintmax_t st_mvcc_thawed; /* Buffers thawed. */
 uintmax_t st_mvcc_freed; /* Frozen buffers freed. */
 uintmax_t st_alloc; /* Number of page allocations. */
 uintmax_t st_alloc_buckets; /* Buckets checked during allocation. */
 uintmax_t st_alloc_max_buckets;/* Max checked during allocation. */
 uintmax_t st_alloc_pages; /* Pages checked during allocation. */
 uintmax_t st_alloc_max_pages; /* Max checked during allocation. */
 uintmax_t st_io_wait; /* Thread waited on buffer I/O. */
 uintmax_t st_sync_interrupted; /* Number of times sync interrupted. */
 roff_t st_regsize; /* Region size. */
 roff_t st_regmax; /* Region max. */

};

/*
 * Mpool file statistics structure.
 * The first fields in this structure must mirror the __db_mpool_fstat_int
 * structure, since content is mem copied between the two.
 */
struct __db_mpool_fstat {
 u_int32_t st_pagesize; /* Page size. */

 u_int32_t st_map; /* Pages from mapped files. */
 uintmax_t st_cache_hit; /* Pages found in the cache. */
 uintmax_t st_cache_miss; /* Pages not found in the cache. */
 uintmax_t st_page_create; /* Pages created in the cache. */
 uintmax_t st_page_in; /* Pages read in. */
 uintmax_t st_page_out; /* Pages written out. */
 uintmax_t st_backup_spins; /* Number of spins during a copy. */

 char *file_name; /* File name. */
};

/*******************************************************
 * Transactions and recovery.
 *******************************************************/


typedef enum {
 DB_TXN_ABORT=0, /* Public. */
 DB_TXN_APPLY=1, /* Public. */
 DB_TXN_BACKWARD_ROLL=3, /* Public. */
 DB_TXN_FORWARD_ROLL=4, /* Public. */
 DB_TXN_OPENFILES=5, /* Internal. */
 DB_TXN_POPENFILES=6, /* Internal. */
 DB_TXN_PRINT=7, /* Public. */
 DB_TXN_LOG_VERIFY=8 /* Internal. */
} db_recops;

/*
 * BACKWARD_ALLOC is used during the forward pass to pick up any aborted
 * allocations for files that were created during the forward pass.
 * The main difference between _ALLOC and _ROLL is that the entry for
 * the file not exist during the rollforward pass.
 */



struct __db_txn {
 DB_TXNMGR *mgrp; /* Pointer to transaction manager. */
 DB_TXN *parent; /* Pointer to transaction's parent. */
 DB_THREAD_INFO *thread_info; /* Pointer to thread information. */

 u_int32_t txnid; /* Unique transaction id. */
 char *name; /* Transaction name. */
 DB_LOCKER *locker; /* Locker for this txn. */

 void *td; /* Detail structure within region. */
 db_timeout_t lock_timeout; /* Timeout for locks for this txn. */
 void *txn_list; /* Undo information for parent. */

 /*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__db_txn) links;
	 */
 struct {
  struct __db_txn *tqe_next;
  struct __db_txn **tqe_prev;
 } links; /* Links transactions off manager. */

 /*
	 * !!!
	 * Explicit representations of structures from shqueue.h.
	 * SH_TAILQ_ENTRY xa_links;
	 * These links link together transactions that are active in
	 * the same thread of control.
	 */
 struct {
  db_ssize_t stqe_next;
  db_ssize_t stqe_prev;
 } xa_links; /* Links XA transactions. */

 /*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_HEAD(__kids, __db_txn) kids;
	 */
 struct __kids {
  struct __db_txn *tqh_first;
  struct __db_txn **tqh_last;
 } kids;

 /*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_HEAD(__events, __txn_event) events;
	 */
 struct {
  struct __txn_event *tqh_first;
  struct __txn_event **tqh_last;
 } events; /* Links deferred events. */

 /*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * STAILQ_HEAD(__logrec, __txn_logrec) logs;
	 */
 struct {
  struct __txn_logrec *stqh_first;
  struct __txn_logrec **stqh_last;
 } logs; /* Links in memory log records. */

 /*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__db_txn) klinks;
	 */
 struct {
  struct __db_txn *tqe_next;
  struct __db_txn **tqe_prev;
 } klinks; /* Links of children in parent. */

 /*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_HEAD(__my_cursors, __dbc) my_cursors;
	 */
 struct __my_cursors {
  struct __dbc *tqh_first;
  struct __dbc **tqh_last;
 } my_cursors;

 /*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_HEAD(__femfs, MPOOLFILE) femfs;
	 *
	 * These are DBs involved in file extension in this transaction.
	 */
 struct __femfs {
  DB *tqh_first;
  DB **tqh_last;
 } femfs;

 DB_TXN_TOKEN *token_buffer; /* User's commit token buffer. */
 void *api_internal; /* C++ API private. */
 void *xml_internal; /* XML API private. */

 u_int32_t cursors; /* Number of cursors open for txn */

 /* DB_TXN PUBLIC HANDLE LIST BEGIN */
 int (*abort) (DB_TXN *);
 int (*commit) (DB_TXN *, u_int32_t);
 int (*discard) (DB_TXN *, u_int32_t);
 int (*get_name) (DB_TXN *, const char **);
 int (*get_priority) (DB_TXN *, u_int32_t *);
 u_int32_t (*id) (DB_TXN *);
 int (*prepare) (DB_TXN *, u_int8_t *);
 int (*set_commit_token) (DB_TXN *, DB_TXN_TOKEN *);
 int (*set_name) (DB_TXN *, const char *);
 int (*set_priority) (DB_TXN *, u_int32_t);
 int (*set_timeout) (DB_TXN *, db_timeout_t, u_int32_t);
 /* DB_TXN PUBLIC HANDLE LIST END */

 /* DB_TXN PRIVATE HANDLE LIST BEGIN */
 void (*set_txn_lsnp) (DB_TXN *txn, DB_LSN **, DB_LSN **);
 /* DB_TXN PRIVATE HANDLE LIST END */





 u_int32_t xa_thr_status;
# 960 "/usr/include/db.h" 3 4
 u_int32_t flags;
};



/*
 * Structure used for two phase commit interface.
 * We set the size of our global transaction id (gid) to be 128 in order
 * to match that defined by the XA X/Open standard.
 */

struct __db_preplist {
 DB_TXN *txn;
 u_int8_t gid[128];
};

/* Transaction statistics structure. */
struct __db_txn_active {
 u_int32_t txnid; /* Transaction ID */
 u_int32_t parentid; /* Transaction ID of parent */
 pid_t pid; /* Process owning txn ID */
 db_threadid_t tid; /* Thread owning txn ID */

 DB_LSN lsn; /* LSN when transaction began */

 DB_LSN read_lsn; /* Read LSN for MVCC */
 u_int32_t mvcc_ref; /* MVCC reference count */

 u_int32_t priority; /* Deadlock resolution priority */






 u_int32_t status; /* Status of the transaction */






 u_int32_t xa_status; /* XA status */

 u_int8_t gid[128]; /* Global transaction ID */
 char name[51]; /* 50 bytes of name, nul termination */
};

struct __db_txn_stat {
 u_int32_t st_nrestores; /* number of restored transactions
					   after recovery. */

 DB_LSN st_last_ckp; /* lsn of the last checkpoint */
 time_t st_time_ckp; /* time of last checkpoint */
 u_int32_t st_last_txnid; /* last transaction id given out */
 u_int32_t st_inittxns; /* inital txns allocated */
 u_int32_t st_maxtxns; /* maximum txns possible */
 uintmax_t st_naborts; /* number of aborted transactions */
 uintmax_t st_nbegins; /* number of begun transactions */
 uintmax_t st_ncommits; /* number of committed transactions */
 u_int32_t st_nactive; /* number of active transactions */
 u_int32_t st_nsnapshot; /* number of snapshot transactions */
 u_int32_t st_maxnactive; /* maximum active transactions */
 u_int32_t st_maxnsnapshot; /* maximum snapshot transactions */
 uintmax_t st_region_wait; /* Region lock granted after wait. */
 uintmax_t st_region_nowait; /* Region lock granted without wait. */
 roff_t st_regsize; /* Region size. */
 DB_TXN_ACTIVE *st_txnarray; /* array of active transactions */

};


struct __db_txn_token {
 u_int8_t buf[20];
};

/*******************************************************
 * Replication.
 *******************************************************/
/* Special, out-of-band environment IDs. */






/* Acknowledgement policies; 0 reserved as OOB. */
# 1055 "/usr/include/db.h" 3 4
/* Replication timeout configuration values. */
# 1066 "/usr/include/db.h" 3 4
/*
 * Event notification types.  (Tcl testing interface currently assumes there are
 * no more than 32 of these.)
 */
# 1094 "/usr/include/db.h" 3 4
/* Replication Manager site status. */
struct __db_repmgr_site {
 int eid;
 char *host;
 u_int port;



 u_int32_t status;


 u_int32_t flags;
};

/* Replication statistics. */
struct __db_rep_stat { /* SHARED */
 /* !!!
	 * Many replication statistics fields cannot be protected by a mutex
	 * without an unacceptable performance penalty, since most message
	 * processing is done without the need to hold a region-wide lock.
	 * Fields whose comments end with a '+' may be updated without holding
	 * the replication or log mutexes (as appropriate), and thus may be
	 * off somewhat (or, on unreasonable architectures under unlucky
	 * circumstances, garbaged).
	 */
 u_int32_t st_startup_complete; /* Site completed client sync-up. */

 uintmax_t st_log_queued; /* Log records currently queued.+ */
 u_int32_t st_status; /* Current replication status. */
 DB_LSN st_next_lsn; /* Next LSN to use or expect. */
 DB_LSN st_waiting_lsn; /* LSN we're awaiting, if any. */
 DB_LSN st_max_perm_lsn; /* Maximum permanent LSN. */
 db_pgno_t st_next_pg; /* Next pg we expect. */
 db_pgno_t st_waiting_pg; /* pg we're awaiting, if any. */

 u_int32_t st_dupmasters; /* # of times a duplicate master
					   condition was detected.+ */
 db_ssize_t st_env_id; /* Current environment ID. */
 u_int32_t st_env_priority; /* Current environment priority. */
 uintmax_t st_bulk_fills; /* Bulk buffer fills. */
 uintmax_t st_bulk_overflows; /* Bulk buffer overflows. */
 uintmax_t st_bulk_records; /* Bulk records stored. */
 uintmax_t st_bulk_transfers; /* Transfers of bulk buffers. */
 uintmax_t st_client_rerequests;/* Number of forced rerequests. */
 uintmax_t st_client_svc_req; /* Number of client service requests
					   received by this client. */
 uintmax_t st_client_svc_miss; /* Number of client service requests
					   missing on this client. */
 u_int32_t st_gen; /* Current generation number. */
 u_int32_t st_egen; /* Current election gen number. */
 uintmax_t st_lease_chk; /* Lease validity checks. */
 uintmax_t st_lease_chk_misses; /* Lease checks invalid. */
 uintmax_t st_lease_chk_refresh; /* Lease refresh attempts. */
 uintmax_t st_lease_sends; /* Lease messages sent live. */

 uintmax_t st_log_duplicated; /* Log records received multiply.+ */
 uintmax_t st_log_queued_max; /* Max. log records queued at once.+ */
 uintmax_t st_log_queued_total; /* Total # of log recs. ever queued.+ */
 uintmax_t st_log_records; /* Log records received and put.+ */
 uintmax_t st_log_requested; /* Log recs. missed and requested.+ */
 db_ssize_t st_master; /* Env. ID of the current master. */
 uintmax_t st_master_changes; /* # of times we've switched masters. */
 uintmax_t st_msgs_badgen; /* Messages with a bad generation #.+ */
 uintmax_t st_msgs_processed; /* Messages received and processed.+ */
 uintmax_t st_msgs_recover; /* Messages ignored because this site
					   was a client in recovery.+ */
 uintmax_t st_msgs_send_failures;/* # of failed message sends.+ */
 uintmax_t st_msgs_sent; /* # of successful message sends.+ */
 uintmax_t st_newsites; /* # of NEWSITE msgs. received.+ */
 u_int32_t st_nsites; /* Current number of sites we will
					   assume during elections. */
 uintmax_t st_nthrottles; /* # of times we were throttled. */
 uintmax_t st_outdated; /* # of times we detected and returned
					   an OUTDATED condition.+ */
 uintmax_t st_pg_duplicated; /* Pages received multiply.+ */
 uintmax_t st_pg_records; /* Pages received and stored.+ */
 uintmax_t st_pg_requested; /* Pages missed and requested.+ */
 uintmax_t st_txns_applied; /* # of transactions applied.+ */
 uintmax_t st_startsync_delayed;/* # of STARTSYNC msgs delayed.+ */

 /* Elections generally. */
 uintmax_t st_elections; /* # of elections held.+ */
 uintmax_t st_elections_won; /* # of elections won by this site.+ */

 /* Statistics about an in-progress election. */
 db_ssize_t st_election_cur_winner; /* Current front-runner. */
 u_int32_t st_election_gen; /* Election generation number. */
 u_int32_t st_election_datagen; /* Election data generation number. */
 DB_LSN st_election_lsn; /* Max. LSN of current winner. */
 u_int32_t st_election_nsites; /* # of "registered voters". */
 u_int32_t st_election_nvotes; /* # of "registered voters" needed. */
 u_int32_t st_election_priority; /* Current election priority. */
 int32_t st_election_status; /* Current election status. */
 u_int32_t st_election_tiebreaker;/* Election tiebreaker value. */
 u_int32_t st_election_votes; /* Votes received in this round. */
 u_int32_t st_election_sec; /* Last election time seconds. */
 u_int32_t st_election_usec; /* Last election time useconds. */
 u_int32_t st_max_lease_sec; /* Maximum lease timestamp seconds. */
 u_int32_t st_max_lease_usec; /* Maximum lease timestamp useconds. */

 /* Undocumented statistics only used by the test system. */




};

/* Replication Manager statistics. */
struct __db_repmgr_stat { /* SHARED */
 uintmax_t st_perm_failed; /* # of insufficiently ack'ed msgs. */
 uintmax_t st_msgs_queued; /* # msgs queued for network delay. */
 uintmax_t st_msgs_dropped; /* # msgs discarded due to excessive
					   queue length. */
 uintmax_t st_connection_drop; /* Existing connections dropped. */
 uintmax_t st_connect_fail; /* Failed new connection attempts. */
 uintmax_t st_elect_threads; /* # of active election threads. */
 uintmax_t st_max_elect_threads; /* Max concurrent e-threads ever. */
};

/* Replication Manager connection error. */
struct __db_repmgr_conn_err {
 int eid; /* Replication Environment ID. */
 int error; /* System networking error code. */
};

/*******************************************************
 * Sequences.
 *******************************************************/
/*
 * The storage record for a sequence.
 */
struct __db_seq_record {
 u_int32_t seq_version; /* Version size/number. */
 u_int32_t flags; /* DB_SEQ_XXX Flags. */
 db_seq_t seq_value; /* Current value. */
 db_seq_t seq_max; /* Max permitted. */
 db_seq_t seq_min; /* Min permitted. */
};

/*
 * Handle for a sequence object.
 */
struct __db_sequence {
 DB *seq_dbp; /* DB handle for this sequence. */
 db_mutex_t mtx_seq; /* Mutex if sequence is threaded. */
 DB_SEQ_RECORD *seq_rp; /* Pointer to current data. */
 DB_SEQ_RECORD seq_record; /* Data from DB_SEQUENCE. */
 int32_t seq_cache_size; /* Number of values cached. */
 db_seq_t seq_last_value; /* Last value cached. */
 db_seq_t seq_prev_value; /* Last value returned. */
 DBT seq_key; /* DBT pointing to sequence key. */
 DBT seq_data; /* DBT pointing to seq_record. */

 /* API-private structure: used by C++ and Java. */
 void *api_internal;

 /* DB_SEQUENCE PUBLIC HANDLE LIST BEGIN */
 int (*close) (DB_SEQUENCE *, u_int32_t);
 int (*get) (DB_SEQUENCE *, DB_TXN *, int32_t, db_seq_t *, u_int32_t)
                                                   ;
 int (*get_cachesize) (DB_SEQUENCE *, int32_t *);
 int (*get_db) (DB_SEQUENCE *, DB **);
 int (*get_flags) (DB_SEQUENCE *, u_int32_t *);
 int (*get_key) (DB_SEQUENCE *, DBT *);
 int (*get_range) (DB_SEQUENCE *, db_seq_t *, db_seq_t *)
                                ;
 int (*initial_value) (DB_SEQUENCE *, db_seq_t);
 int (*open) (DB_SEQUENCE *, DB_TXN *, DBT *, u_int32_t)
                                   ;
 int (*remove) (DB_SEQUENCE *, DB_TXN *, u_int32_t);
 int (*set_cachesize) (DB_SEQUENCE *, int32_t);
 int (*set_flags) (DB_SEQUENCE *, u_int32_t);
 int (*set_range) (DB_SEQUENCE *, db_seq_t, db_seq_t);
 int (*stat) (DB_SEQUENCE *, DB_SEQUENCE_STAT **, u_int32_t)
                                       ;
 int (*stat_print) (DB_SEQUENCE *, u_int32_t);
 /* DB_SEQUENCE PUBLIC HANDLE LIST END */
};

struct __db_seq_stat { /* SHARED */
 uintmax_t st_wait; /* Sequence lock granted w/o wait. */
 uintmax_t st_nowait; /* Sequence lock granted after wait. */
 db_seq_t st_current; /* Current value in db. */
 db_seq_t st_value; /* Current cached value. */
 db_seq_t st_last_value; /* Last cached value. */
 db_seq_t st_min; /* Minimum value. */
 db_seq_t st_max; /* Maximum value. */
 int32_t st_cache_size; /* Cache size. */
 u_int32_t st_flags; /* Flag value. */
};

/*******************************************************
 * Access methods.
 *******************************************************/
/*
 * Any new methods need to retain the original numbering.  The type
 * is written in a log record so must be maintained.
 */
typedef enum {
 DB_BTREE=1,
 DB_HASH=2,
 DB_HEAP=6,
 DB_RECNO=3,
 DB_QUEUE=4,
 DB_UNKNOWN=5 /* Figure it out on open. */
} DBTYPE;
# 1322 "/usr/include/db.h" 3 4
/*
 * DB access method and cursor operation values.  Each value is an operation
 * code to which additional bit flags are added.
 */
# 1358 "/usr/include/db.h" 3 4
/* This has to change when the max opcode hits 255. */


/*
 * DB (user visible) error return codes.
 *
 * !!!
 * We don't want our error returns to conflict with other packages where
 * possible, so pick a base error value that's hopefully not common.  We
 * document that we own the error name space from -30,800 to -30,999.
 */
/* DB (public) error return codes. */
# 1402 "/usr/include/db.h" 3 4
/* DB (private) error return codes. */
# 1418 "/usr/include/db.h" 3 4
/* Database handle. */
struct __db {
 /*******************************************************
	 * Public: owned by the application.
	 *******************************************************/
 u_int32_t pgsize; /* Database logical page size. */
 DB_CACHE_PRIORITY priority; /* Database priority in cache. */

     /* Callbacks. */
 int (*db_append_recno) (DB *, DBT *, db_recno_t);
 void (*db_feedback) (DB *, int, int);
 int (*dup_compare) (DB *, const DBT *, const DBT *);

 void *app_private; /* Application-private handle. */

 /*******************************************************
	 * Private: owned by DB.
	 *******************************************************/
 DB_ENV *dbenv; /* Backing public environment. */
 ENV *env; /* Backing private environment. */

 DBTYPE type; /* DB access method type. */

 DB_MPOOLFILE *mpf; /* Backing buffer pool. */

 db_mutex_t mutex; /* Synchronization for free threading */

 char *fname, *dname; /* File/database passed to DB->open. */
 const char *dirname; /* Directory of DB file. */
 u_int32_t open_flags; /* Flags passed to DB->open. */

 u_int8_t fileid[20];/* File's unique ID for locking. */

 u_int32_t adj_fileid; /* File's unique ID for curs. adj. */


 FNAME *log_filename; /* File's naming info for logging. */

 db_pgno_t meta_pgno; /* Meta page number */
 DB_LOCKER *locker; /* Locker for handle locking. */
 DB_LOCKER *cur_locker; /* Current handle lock holder. */
 DB_TXN *cur_txn; /* Opening transaction. */
 DB_LOCKER *associate_locker; /* Locker for DB->associate call. */
 DB_LOCK handle_lock; /* Lock held on this handle. */

 time_t timestamp; /* Handle timestamp for replication. */
 u_int32_t fid_gen; /* Rep generation number for fids. */

 /*
	 * Returned data memory for DB->get() and friends.
	 */
 DBT my_rskey; /* Secondary key. */
 DBT my_rkey; /* [Primary] key. */
 DBT my_rdata; /* Data. */

 /*
	 * !!!
	 * Some applications use DB but implement their own locking outside of
	 * DB.  If they're using fcntl(2) locking on the underlying database
	 * file, and we open and close a file descriptor for that file, we will
	 * discard their locks.  The DB_FCNTL_LOCKING flag to DB->open is an
	 * undocumented interface to support this usage which leaves any file
	 * descriptors we open until DB->close.  This will only work with the
	 * DB->open interface and simple caches, e.g., creating a transaction
	 * thread may open/close file descriptors this flag doesn't protect.
	 * Locking with fcntl(2) on a file that you don't own is a very, very
	 * unsafe thing to do.  'Nuff said.
	 */
 DB_FH *saved_open_fhp; /* Saved file handle. */

 /*
	 * Linked list of DBP's, linked from the ENV, used to keep track
	 * of all open db handles for cursor adjustment.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__db) dblistlinks;
	 */
 struct {
  struct __db *tqe_next;
  struct __db **tqe_prev;
 } dblistlinks;

 /*
	 * Cursor queues.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_HEAD(__cq_fq, __dbc) free_queue;
	 * TAILQ_HEAD(__cq_aq, __dbc) active_queue;
	 * TAILQ_HEAD(__cq_jq, __dbc) join_queue;
	 */
 struct __cq_fq {
  struct __dbc *tqh_first;
  struct __dbc **tqh_last;
 } free_queue;
 struct __cq_aq {
  struct __dbc *tqh_first;
  struct __dbc **tqh_last;
 } active_queue;
 struct __cq_jq {
  struct __dbc *tqh_first;
  struct __dbc **tqh_last;
 } join_queue;

 /*
	 * Secondary index support.
	 *
	 * Linked list of secondary indices -- set in the primary.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * LIST_HEAD(s_secondaries, __db);
	 */
 struct {
  struct __db *lh_first;
 } s_secondaries;

 /*
	 * List entries for secondaries, and reference count of how many
	 * threads are updating this secondary (see Dbc.put).
	 *
	 * !!!
	 * Note that these are synchronized by the primary's mutex, but
	 * filled in in the secondaries.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * LIST_ENTRY(__db) s_links;
	 */
 struct {
  struct __db *le_next;
  struct __db **le_prev;
 } s_links;
 u_int32_t s_refcnt;

 /* Secondary callback and free functions -- set in the secondary. */
 int (*s_callback) (DB *, const DBT *, const DBT *, DBT *);

 /* Reference to primary -- set in the secondary. */
 DB *s_primary;




 /* Flags passed to associate -- set in the secondary. */
 u_int32_t s_assoc_flags;

 /*
	 * Foreign key support.
	 *
	 * Linked list of primary dbs -- set in the foreign db
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * LIST_HEAD(f_primaries, __db);
	 */
 struct {
  struct __db_foreign_info *lh_first;
 } f_primaries;

 /*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__db) felink;
	 *
	 * Links in a list of DBs involved in file extension
	 * during a transaction.  These are to be used only while the
	 * metadata is locked.
	 */
 struct {
  struct __db *tqe_next;
  struct __db **tqe_prev;
 } felink;

 /* Reference to foreign -- set in the secondary. */
 DB *s_foreign;

 /* API-private structure: used by DB 1.85, C++, Java, Perl and Tcl */
 void *api_internal;

 /* Subsystem-private structure. */
 void *bt_internal; /* Btree/Recno access method. */
 void *h_internal; /* Hash access method. */
 void *heap_internal; /* Heap access method. */
 void *p_internal; /* Partition informaiton. */
 void *q_internal; /* Queue access method. */

 /* DB PUBLIC HANDLE LIST BEGIN */
 int (*associate) (DB *, DB_TXN *, DB *, int (*)(DB *, const DBT *, const DBT *, DBT *), u_int32_t)
                                                             ;
 int (*associate_foreign) (DB *, DB *, int (*)(DB *, const DBT *, DBT *, const DBT *, int *), u_int32_t)

             ;
 int (*close) (DB *, u_int32_t);
 int (*compact) (DB *, DB_TXN *, DBT *, DBT *, DB_COMPACT *, u_int32_t, DBT *)
                                                          ;
 int (*cursor) (DB *, DB_TXN *, DBC **, u_int32_t);
 int (*del) (DB *, DB_TXN *, DBT *, u_int32_t);
 void (*err) (DB *, int, const char *, ...);
 void (*errx) (DB *, const char *, ...);
 int (*exists) (DB *, DB_TXN *, DBT *, u_int32_t);
 int (*fd) (DB *, int *);
 int (*get) (DB *, DB_TXN *, DBT *, DBT *, u_int32_t);
 int (*get_alloc) (DB *, void *(**)(size_t), void *(**)(void *, size_t), void (**)(void *))
                                                 ;
 int (*get_append_recno) (DB *, int (**)(DB *, DBT *, db_recno_t));
 int (*get_assoc_flags) (DB *, u_int32_t *);
 int (*get_bt_compare)
  (DB *, int (**)(DB *, const DBT *, const DBT *));
 int (*get_bt_compress) (DB *, int (**)(DB *, const DBT *, const DBT *, const DBT *, const DBT *, DBT *), int (**)(DB *, const DBT *, const DBT *, DBT *, DBT *, DBT *))


                                                                 ;
 int (*get_bt_minkey) (DB *, u_int32_t *);
 int (*get_bt_prefix)
  (DB *, size_t (**)(DB *, const DBT *, const DBT *));
 int (*get_byteswapped) (DB *, int *);
 int (*get_cachesize) (DB *, u_int32_t *, u_int32_t *, int *);
 int (*get_create_dir) (DB *, const char **);
 int (*get_dbname) (DB *, const char **, const char **);
 int (*get_dup_compare)
  (DB *, int (**)(DB *, const DBT *, const DBT *));
 int (*get_encrypt_flags) (DB *, u_int32_t *);
 DB_ENV *(*get_env) (DB *);
 void (*get_errcall) (DB *, void (**)(const DB_ENV *, const char *, const char *))
                                                         ;
 void (*get_errfile) (DB *, FILE **);
 void (*get_errpfx) (DB *, const char **);
 int (*get_feedback) (DB *, void (**)(DB *, int, int));
 int (*get_flags) (DB *, u_int32_t *);
 int (*get_h_compare)
  (DB *, int (**)(DB *, const DBT *, const DBT *));
 int (*get_h_ffactor) (DB *, u_int32_t *);
 int (*get_h_hash)
  (DB *, u_int32_t (**)(DB *, const void *, u_int32_t));
 int (*get_h_nelem) (DB *, u_int32_t *);
 int (*get_heapsize) (DB *, u_int32_t *, u_int32_t *);
 int (*get_heap_regionsize) (DB *, u_int32_t *);
 int (*get_lk_exclusive) (DB *, int *, int *);
 int (*get_lorder) (DB *, int *);
 DB_MPOOLFILE *(*get_mpf) (DB *);
 void (*get_msgcall) (DB *, void (**)(const DB_ENV *, const char *))
                                              ;
 void (*get_msgfile) (DB *, FILE **);
 int (*get_multiple) (DB *);
 int (*get_open_flags) (DB *, u_int32_t *);
 int (*get_pagesize) (DB *, u_int32_t *);
 int (*get_partition_callback) (DB *, u_int32_t *, u_int32_t (**)(DB *, DBT *key))
                                               ;
 int (*get_partition_dirs) (DB *, const char ***);
 int (*get_partition_keys) (DB *, u_int32_t *, DBT **);
 int (*get_priority) (DB *, DB_CACHE_PRIORITY *);
 int (*get_q_extentsize) (DB *, u_int32_t *);
 int (*get_re_delim) (DB *, int *);
 int (*get_re_len) (DB *, u_int32_t *);
 int (*get_re_pad) (DB *, int *);
 int (*get_re_source) (DB *, const char **);
 int (*get_transactional) (DB *);
 int (*get_type) (DB *, DBTYPE *);
 int (*join) (DB *, DBC **, DBC **, u_int32_t);
 int (*key_range)
  (DB *, DB_TXN *, DBT *, DB_KEY_RANGE *, u_int32_t);
 int (*open) (DB *, DB_TXN *, const char *, const char *, DBTYPE, u_int32_t, int)
                                                                ;
 int (*pget) (DB *, DB_TXN *, DBT *, DBT *, DBT *, u_int32_t);
 int (*put) (DB *, DB_TXN *, DBT *, DBT *, u_int32_t);
 int (*remove) (DB *, const char *, const char *, u_int32_t);
 int (*rename) (DB *, const char *, const char *, const char *, u_int32_t)
                                                       ;
 int (*set_alloc) (DB *, void *(*)(size_t), void *(*)(void *, size_t), void (*)(void *))
                                               ;
 int (*set_append_recno) (DB *, int (*)(DB *, DBT *, db_recno_t));
 int (*set_bt_compare)
  (DB *, int (*)(DB *, const DBT *, const DBT *));
 int (*set_bt_compress) (DB *, int (*)(DB *, const DBT *, const DBT *, const DBT *, const DBT *, DBT *), int (*)(DB *, const DBT *, const DBT *, DBT *, DBT *, DBT *))

                                                                ;
 int (*set_bt_minkey) (DB *, u_int32_t);
 int (*set_bt_prefix)
  (DB *, size_t (*)(DB *, const DBT *, const DBT *));
 int (*set_cachesize) (DB *, u_int32_t, u_int32_t, int);
 int (*set_create_dir) (DB *, const char *);
 int (*set_dup_compare)
  (DB *, int (*)(DB *, const DBT *, const DBT *));
 int (*set_encrypt) (DB *, const char *, u_int32_t);
 void (*set_errcall) (DB *, void (*)(const DB_ENV *, const char *, const char *))
                                                        ;
 void (*set_errfile) (DB *, FILE *);
 void (*set_errpfx) (DB *, const char *);
 int (*set_feedback) (DB *, void (*)(DB *, int, int));
 int (*set_flags) (DB *, u_int32_t);
 int (*set_h_compare)
  (DB *, int (*)(DB *, const DBT *, const DBT *));
 int (*set_h_ffactor) (DB *, u_int32_t);
 int (*set_h_hash)
  (DB *, u_int32_t (*)(DB *, const void *, u_int32_t));
 int (*set_h_nelem) (DB *, u_int32_t);
 int (*set_heapsize) (DB *, u_int32_t, u_int32_t, u_int32_t);
 int (*set_heap_regionsize) (DB *, u_int32_t);
 int (*set_lk_exclusive) (DB *, int);
 int (*set_lorder) (DB *, int);
 void (*set_msgcall) (DB *, void (*)(const DB_ENV *, const char *));
 void (*set_msgfile) (DB *, FILE *);
 int (*set_pagesize) (DB *, u_int32_t);
 int (*set_paniccall) (DB *, void (*)(DB_ENV *, int));
 int (*set_partition) (DB *, u_int32_t, DBT *, u_int32_t (*)(DB *, DBT *key))
                                                   ;
 int (*set_partition_dirs) (DB *, const char **);
 int (*set_priority) (DB *, DB_CACHE_PRIORITY);
 int (*set_q_extentsize) (DB *, u_int32_t);
 int (*set_re_delim) (DB *, int);
 int (*set_re_len) (DB *, u_int32_t);
 int (*set_re_pad) (DB *, int);
 int (*set_re_source) (DB *, const char *);
 int (*sort_multiple) (DB *, DBT *, DBT *, u_int32_t);
 int (*stat) (DB *, DB_TXN *, void *, u_int32_t);
 int (*stat_print) (DB *, u_int32_t);
 int (*sync) (DB *, u_int32_t);
 int (*truncate) (DB *, DB_TXN *, u_int32_t *, u_int32_t);
 int (*upgrade) (DB *, const char *, u_int32_t);
 int (*verify)
  (DB *, const char *, const char *, FILE *, u_int32_t);
 /* DB PUBLIC HANDLE LIST END */

 /* DB PRIVATE HANDLE LIST BEGIN */
 int (*dump) (DB *, const char *, int (*)(void *, const void *), void *, int, int)
                                                   ;
 int (*db_am_remove) (DB *, DB_THREAD_INFO *, DB_TXN *, const char *, const char *, u_int32_t)
                                                   ;
 int (*db_am_rename) (DB *, DB_THREAD_INFO *, DB_TXN *, const char *, const char *, const char *)
                                                      ;
 /* DB PRIVATE HANDLE LIST END */

 /*
	 * Never called; these are a place to save function pointers
	 * so that we can undo an associate.
	 */
 int (*stored_get) (DB *, DB_TXN *, DBT *, DBT *, u_int32_t);
 int (*stored_close) (DB *, u_int32_t);

 /* Alternative handle close function, used by C++ API. */
 int (*alt_close) (DB *, u_int32_t);






 u_int32_t am_ok; /* Legal AM choices. */

 /*
	 * This field really ought to be an AM_FLAG, but we have
	 * have run out of bits.  If/when we decide to split up
	 * the flags, we can incorporate it.
	 */
 int preserve_fid; /* Do not free fileid on close. */
# 1808 "/usr/include/db.h" 3 4
 u_int32_t orig_flags; /* Flags at  open, for refresh */
 u_int32_t flags;




 u_int32_t orig_flags2; /* Second flags word; for refresh */
 u_int32_t flags2; /* Second flags word */
};

/*
 * Macros for bulk operations.  These are only intended for the C API.
 * For C++, use DbMultiple*Iterator or DbMultiple*Builder.
 *
 * Bulk operations store multiple entries into a single DBT structure. The
 * following macros assist with creating and reading these Multiple DBTs.
 *
 * The basic layout for single data items is:
 *
 * -------------------------------------------------------------------------
 * | data1 | ... | dataN | ..... |-1 | dNLen | dNOff | ... | d1Len | d1Off |
 * -------------------------------------------------------------------------
 *
 * For the DB_MULTIPLE_KEY* macros, the items are in key/data pairs, so data1
 * would be a key, and data2 its corresponding value (N is always even).
 *
 * For the DB_MULTIPLE_RECNO* macros, the record number is stored along with
 * the len/off pair in the "header" section, and the list is zero terminated
 * (since -1 is a valid record number):
 *
 * --------------------------------------------------------------------------
 * | d1 |..| dN |..| 0 | dNLen | dNOff | recnoN |..| d1Len | d1Off | recno1 |
 * --------------------------------------------------------------------------
 */
# 2002 "/usr/include/db.h" 3 4
struct __db_heap_rid {
 db_pgno_t pgno; /* Page number. */
 db_indx_t indx; /* Index in the offset table. */
};


/*******************************************************
 * Access method cursors.
 *******************************************************/
struct __dbc {
 DB *dbp; /* Backing database */
 DB_ENV *dbenv; /* Backing environment */
 ENV *env; /* Backing environment */

 DB_THREAD_INFO *thread_info; /* Thread that owns this cursor. */
 DB_TXN *txn; /* Associated transaction. */
 DB_CACHE_PRIORITY priority; /* Priority in cache. */

 /*
	 * Active/free cursor queues.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__dbc) links;
	 */
 struct {
  DBC *tqe_next;
  DBC **tqe_prev;
 } links;

 /*
	 * Cursor queue of the owning transaction.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__dbc) txn_cursors;
	 */
 struct {
  DBC *tqe_next; /* next element */
  DBC **tqe_prev; /* address of previous next element */
 } txn_cursors;

 /*
	 * The DBT *'s below are used by the cursor routines to return
	 * data to the user when DBT flags indicate that DB should manage
	 * the returned memory.  They point at a DBT containing the buffer
	 * and length that will be used, and "belonging" to the handle that
	 * should "own" this memory.  This may be a "my_*" field of this
	 * cursor--the default--or it may be the corresponding field of
	 * another cursor, a DB handle, a join cursor, etc.  In general, it
	 * will be whatever handle the user originally used for the current
	 * DB interface call.
	 */
 DBT *rskey; /* Returned secondary key. */
 DBT *rkey; /* Returned [primary] key. */
 DBT *rdata; /* Returned data. */

 DBT my_rskey; /* Space for returned secondary key. */
 DBT my_rkey; /* Space for returned [primary] key. */
 DBT my_rdata; /* Space for returned data. */

 DB_LOCKER *lref; /* Reference to default locker. */
 DB_LOCKER *locker; /* Locker for this operation. */
 DBT lock_dbt; /* DBT referencing lock. */
 DB_LOCK_ILOCK lock; /* Object to be locked. */
 DB_LOCK mylock; /* CDB lock held on this cursor. */

 DBTYPE dbtype; /* Cursor type. */

 DBC_INTERNAL *internal; /* Access method private. */

 /* DBC PUBLIC HANDLE LIST BEGIN */
 int (*close) (DBC *);
 int (*cmp) (DBC *, DBC *, int *, u_int32_t);
 int (*count) (DBC *, db_recno_t *, u_int32_t);
 int (*del) (DBC *, u_int32_t);
 int (*dup) (DBC *, DBC **, u_int32_t);
 int (*get) (DBC *, DBT *, DBT *, u_int32_t);
 int (*get_priority) (DBC *, DB_CACHE_PRIORITY *);
 int (*pget) (DBC *, DBT *, DBT *, DBT *, u_int32_t);
 int (*put) (DBC *, DBT *, DBT *, u_int32_t);
 int (*set_priority) (DBC *, DB_CACHE_PRIORITY);
 /* DBC PUBLIC HANDLE LIST END */

 /* The following are the method names deprecated in the 4.6 release. */
 int (*c_close) (DBC *);
 int (*c_count) (DBC *, db_recno_t *, u_int32_t);
 int (*c_del) (DBC *, u_int32_t);
 int (*c_dup) (DBC *, DBC **, u_int32_t);
 int (*c_get) (DBC *, DBT *, DBT *, u_int32_t);
 int (*c_pget) (DBC *, DBT *, DBT *, DBT *, u_int32_t);
 int (*c_put) (DBC *, DBT *, DBT *, u_int32_t);

 /* DBC PRIVATE HANDLE LIST BEGIN */
 int (*am_bulk) (DBC *, DBT *, u_int32_t);
 int (*am_close) (DBC *, db_pgno_t, int *);
 int (*am_del) (DBC *, u_int32_t);
 int (*am_destroy) (DBC *);
 int (*am_get) (DBC *, DBT *, DBT *, u_int32_t, db_pgno_t *);
 int (*am_put) (DBC *, DBT *, DBT *, u_int32_t, db_pgno_t *);
 int (*am_writelock) (DBC *);
 /* DBC PRIVATE HANDLE LIST END */

/*
 * DBC_DONTLOCK and DBC_RECOVER are used during recovery and transaction
 * abort.  If a transaction is being aborted or recovered then DBC_RECOVER
 * will be set and locking and logging will be disabled on this cursor.  If
 * we are performing a compensating transaction (e.g. free page processing)
 * then DB_DONTLOCK will be set to inhibit locking, but logging will still
 * be required. DB_DONTLOCK is also used if the whole database is locked.
 */
# 2134 "/usr/include/db.h" 3 4
 u_int32_t flags;
};

/* Key range statistics structure */
struct __key_range {
 double less;
 double equal;
 double greater;
};

/* Btree/Recno statistics structure. */
struct __db_bt_stat { /* SHARED */
 u_int32_t bt_magic; /* Magic number. */
 u_int32_t bt_version; /* Version number. */
 u_int32_t bt_metaflags; /* Metadata flags. */
 u_int32_t bt_nkeys; /* Number of unique keys. */
 u_int32_t bt_ndata; /* Number of data items. */
 u_int32_t bt_pagecnt; /* Page count. */
 u_int32_t bt_pagesize; /* Page size. */
 u_int32_t bt_minkey; /* Minkey value. */
 u_int32_t bt_re_len; /* Fixed-length record length. */
 u_int32_t bt_re_pad; /* Fixed-length record pad. */
 u_int32_t bt_levels; /* Tree levels. */
 u_int32_t bt_int_pg; /* Internal pages. */
 u_int32_t bt_leaf_pg; /* Leaf pages. */
 u_int32_t bt_dup_pg; /* Duplicate pages. */
 u_int32_t bt_over_pg; /* Overflow pages. */
 u_int32_t bt_empty_pg; /* Empty pages. */
 u_int32_t bt_free; /* Pages on the free list. */
 uintmax_t bt_int_pgfree; /* Bytes free in internal pages. */
 uintmax_t bt_leaf_pgfree; /* Bytes free in leaf pages. */
 uintmax_t bt_dup_pgfree; /* Bytes free in duplicate pages. */
 uintmax_t bt_over_pgfree; /* Bytes free in overflow pages. */
};

struct __db_compact {
 /* Input Parameters. */
 u_int32_t compact_fillpercent; /* Desired fillfactor: 1-100 */
 db_timeout_t compact_timeout; /* Lock timeout. */
 u_int32_t compact_pages; /* Max pages to process. */
 /* Output Stats. */
 u_int32_t compact_empty_buckets; /* Empty hash buckets found. */
 u_int32_t compact_pages_free; /* Number of pages freed. */
 u_int32_t compact_pages_examine; /* Number of pages examine. */
 u_int32_t compact_levels; /* Number of levels removed. */
 u_int32_t compact_deadlock; /* Number of deadlocks. */
 db_pgno_t compact_pages_truncated; /* Pages truncated to OS. */
 /* Internal. */
 db_pgno_t compact_truncate; /* Page number for truncation */
};

/* Hash statistics structure. */
struct __db_h_stat { /* SHARED */
 u_int32_t hash_magic; /* Magic number. */
 u_int32_t hash_version; /* Version number. */
 u_int32_t hash_metaflags; /* Metadata flags. */
 u_int32_t hash_nkeys; /* Number of unique keys. */
 u_int32_t hash_ndata; /* Number of data items. */
 u_int32_t hash_pagecnt; /* Page count. */
 u_int32_t hash_pagesize; /* Page size. */
 u_int32_t hash_ffactor; /* Fill factor specified at create. */
 u_int32_t hash_buckets; /* Number of hash buckets. */
 u_int32_t hash_free; /* Pages on the free list. */
 uintmax_t hash_bfree; /* Bytes free on bucket pages. */
 u_int32_t hash_bigpages; /* Number of big key/data pages. */
 uintmax_t hash_big_bfree; /* Bytes free on big item pages. */
 u_int32_t hash_overflows; /* Number of overflow pages. */
 uintmax_t hash_ovfl_free; /* Bytes free on ovfl pages. */
 u_int32_t hash_dup; /* Number of dup pages. */
 uintmax_t hash_dup_free; /* Bytes free on duplicate pages. */
};

/* Heap statistics structure. */
struct __db_heap_stat { /* SHARED */
 u_int32_t heap_magic; /* Magic number. */
 u_int32_t heap_version; /* Version number. */
 u_int32_t heap_metaflags; /* Metadata flags. */
 u_int32_t heap_nrecs; /* Number of records. */
 u_int32_t heap_pagecnt; /* Page count. */
 u_int32_t heap_pagesize; /* Page size. */
 u_int32_t heap_nregions; /* Number of regions. */
 u_int32_t heap_regionsize; /* Number of pages in a region. */
};

/* Queue statistics structure. */
struct __db_qam_stat { /* SHARED */
 u_int32_t qs_magic; /* Magic number. */
 u_int32_t qs_version; /* Version number. */
 u_int32_t qs_metaflags; /* Metadata flags. */
 u_int32_t qs_nkeys; /* Number of unique keys. */
 u_int32_t qs_ndata; /* Number of data items. */
 u_int32_t qs_pagesize; /* Page size. */
 u_int32_t qs_extentsize; /* Pages per extent. */
 u_int32_t qs_pages; /* Data pages. */
 u_int32_t qs_re_len; /* Fixed-length record length. */
 u_int32_t qs_re_pad; /* Fixed-length record pad. */
 u_int32_t qs_pgfree; /* Bytes free in data pages. */
 u_int32_t qs_first_recno; /* First not deleted record. */
 u_int32_t qs_cur_recno; /* Next available record number. */
};

/*******************************************************
 * Environment.
 *******************************************************/


/*
 * Database environment structure.
 *
 * This is the public database environment handle.  The private environment
 * handle is the ENV structure.   The user owns this structure, the library
 * owns the ENV structure.  The reason there are two structures is because
 * the user's configuration outlives any particular DB_ENV->open call, and
 * separate structures allows us to easily discard internal information without
 * discarding the user's configuration.
 *
 * Fields in the DB_ENV structure should normally be set only by application
 * DB_ENV handle methods.
 */

/*
 * Memory configuration types.
 */
typedef enum {
 DB_MEM_LOCK=1,
 DB_MEM_LOCKOBJECT=2,
 DB_MEM_LOCKER=3,
 DB_MEM_LOGID=4,
 DB_MEM_TRANSACTION=5,
 DB_MEM_THREAD=6
} DB_MEM_CONFIG;

/*
 * Backup configuration types.
 */
typedef enum {
 DB_BACKUP_READ_COUNT = 1,
 DB_BACKUP_READ_SLEEP = 2,
 DB_BACKUP_SIZE = 3,
 DB_BACKUP_WRITE_DIRECT = 4
} DB_BACKUP_CONFIG;

struct __db_env {
 ENV *env; /* Linked ENV structure */

 /*
	 * The DB_ENV structure can be used concurrently, so field access is
	 * protected.
	 */
 db_mutex_t mtx_db_env; /* DB_ENV structure mutex */

     /* Error message callback */
 void (*db_errcall) (const DB_ENV *, const char *, const char *);
 FILE *db_errfile; /* Error message file stream */
 const char *db_errpfx; /* Error message prefix */

     /* Other message callback */
 void (*db_msgcall) (const DB_ENV *, const char *);
 FILE *db_msgfile; /* Other message file stream */

 /* Other application callback functions */
 int (*app_dispatch) (DB_ENV *, DBT *, DB_LSN *, db_recops);
 void (*db_event_func) (DB_ENV *, u_int32_t, void *);
 void (*db_feedback) (DB_ENV *, int, int);
 void (*db_free) (void *);
 void (*db_paniccall) (DB_ENV *, int);
 void *(*db_malloc) (size_t);
 void *(*db_realloc) (void *, size_t);
 int (*is_alive) (DB_ENV *, pid_t, db_threadid_t, u_int32_t);
 void (*thread_id) (DB_ENV *, pid_t *, db_threadid_t *);
 char *(*thread_id_string) (DB_ENV *, pid_t, db_threadid_t, char *);

 /* Application specified paths */
 char *db_log_dir; /* Database log file directory */
 char *db_md_dir; /* Persistent metadata directory */
 char *db_tmp_dir; /* Database tmp file directory */

 char *db_create_dir; /* Create directory for data files */
 char **db_data_dir; /* Database data file directories */
 int data_cnt; /* Database data file slots */
 int data_next; /* Next database data file slot */

 char *intermediate_dir_mode; /* Intermediate directory perms */

 long shm_key; /* shmget key */

 char *passwd; /* Cryptography support */
 size_t passwd_len;

 /* Private handle references */
 void *app_private; /* Application-private handle */
 void *api1_internal; /* C++, Perl API private */
 void *api2_internal; /* Java API private */

 u_int32_t verbose; /* DB_VERB_XXX flags */

 /* Mutex configuration */
 u_int32_t mutex_align; /* Mutex alignment */
 u_int32_t mutex_cnt; /* Number of mutexes to configure */
 u_int32_t mutex_inc; /* Number of mutexes to add */
 u_int32_t mutex_max; /* Max number of mutexes */
 u_int32_t mutex_tas_spins;/* Test-and-set spin count */

 /* Locking configuration */
 u_int8_t *lk_conflicts; /* Two dimensional conflict matrix */
 int lk_modes; /* Number of lock modes in table */
 u_int32_t lk_detect; /* Deadlock detect on all conflicts */
 u_int32_t lk_max; /* Maximum number of locks */
 u_int32_t lk_max_lockers;/* Maximum number of lockers */
 u_int32_t lk_max_objects;/* Maximum number of locked objects */
 u_int32_t lk_init; /* Initial number of locks */
 u_int32_t lk_init_lockers;/* Initial number of lockers */
 u_int32_t lk_init_objects;/* Initial number of locked objects */
 u_int32_t lk_partitions ;/* Number of object partitions */
 db_timeout_t lk_timeout; /* Lock timeout period */
 /* Used during initialization */
 u_int32_t locker_t_size; /* Locker hash table size. */
 u_int32_t object_t_size; /* Object hash table size. */

 /* Logging configuration */
 u_int32_t lg_bsize; /* Buffer size */
 u_int32_t lg_fileid_init; /* Initial allocation for fname structs */
 int lg_filemode; /* Log file permission mode */
 u_int32_t lg_regionmax; /* Region size */
 u_int32_t lg_size; /* Log file size */
 u_int32_t lg_flags; /* Log configuration */

 /* Memory pool configuration */
 u_int32_t mp_gbytes; /* Cache size: GB */
 u_int32_t mp_bytes; /* Cache size: bytes */
 u_int32_t mp_max_gbytes; /* Maximum cache size: GB */
 u_int32_t mp_max_bytes; /* Maximum cache size: bytes */
 size_t mp_mmapsize; /* Maximum file size for mmap */
 int mp_maxopenfd; /* Maximum open file descriptors */
 int mp_maxwrite; /* Maximum buffers to write */
 u_int mp_ncache; /* Initial number of cache regions */
 u_int32_t mp_pagesize; /* Average page size */
 u_int32_t mp_tablesize; /* Approximate hash table size */
 u_int32_t mp_mtxcount; /* Number of mutexs */
     /* Sleep after writing max buffers */
 db_timeout_t mp_maxwrite_sleep;

 /* Transaction configuration */
 u_int32_t tx_init; /* Initial number of transactions */
 u_int32_t tx_max; /* Maximum number of transactions */
 time_t tx_timestamp; /* Recover to specific timestamp */
 db_timeout_t tx_timeout; /* Timeout for transactions */

 /* Thread tracking configuration */
 u_int32_t thr_init; /* Thread count */
 u_int32_t thr_max; /* Thread max */
 roff_t memory_max; /* Maximum region memory */

 /*
	 * The following fields are not strictly user-owned, but they outlive
	 * the ENV structure, and so are stored here.
	 */
 DB_FH *registry; /* DB_REGISTER file handle */
 u_int32_t registry_off; /*
					 * Offset of our slot.  We can't use
					 * off_t because its size depends on
					 * build settings.
					 */
        db_timeout_t envreg_timeout; /* DB_REGISTER wait timeout */
# 2419 "/usr/include/db.h" 3 4
 u_int32_t flags;

 /* DB_ENV PUBLIC HANDLE LIST BEGIN */
 int (*add_data_dir) (DB_ENV *, const char *);
 int (*backup) (DB_ENV *, const char *, u_int32_t);
 int (*cdsgroup_begin) (DB_ENV *, DB_TXN **);
 int (*close) (DB_ENV *, u_int32_t);
 int (*dbbackup) (DB_ENV *, const char *, const char *, u_int32_t);
 int (*dbremove) (DB_ENV *, DB_TXN *, const char *, const char *, u_int32_t)
                                                   ;
 int (*dbrename) (DB_ENV *, DB_TXN *, const char *, const char *, const char *, u_int32_t)
                                                                 ;
 void (*err) (const DB_ENV *, int, const char *, ...);
 void (*errx) (const DB_ENV *, const char *, ...);
 int (*failchk) (DB_ENV *, u_int32_t);
 int (*fileid_reset) (DB_ENV *, const char *, u_int32_t);
 int (*get_alloc) (DB_ENV *, void *(**)(size_t), void *(**)(void *, size_t), void (**)(void *))
                                                 ;
 int (*get_app_dispatch)
  (DB_ENV *, int (**)(DB_ENV *, DBT *, DB_LSN *, db_recops));
 int (*get_cache_max) (DB_ENV *, u_int32_t *, u_int32_t *);
 int (*get_cachesize) (DB_ENV *, u_int32_t *, u_int32_t *, int *);
 int (*get_create_dir) (DB_ENV *, const char **);
 int (*get_data_dirs) (DB_ENV *, const char ***);
 int (*get_data_len) (DB_ENV *, u_int32_t *);
 int (*get_backup_callbacks) (DB_ENV *, int (**)(DB_ENV *, const char *, const char *, void **), int (**)(DB_ENV *, u_int32_t, u_int32_t, u_int32_t, u_int8_t *, void *), int (**)(DB_ENV *, const char *, void *))


                                            ;
 int (*get_backup_config) (DB_ENV *, DB_BACKUP_CONFIG, u_int32_t *);
 int (*get_encrypt_flags) (DB_ENV *, u_int32_t *);
 void (*get_errcall) (DB_ENV *, void (**)(const DB_ENV *, const char *, const char *))
                                                         ;
 void (*get_errfile) (DB_ENV *, FILE **);
 void (*get_errpfx) (DB_ENV *, const char **);
 int (*get_flags) (DB_ENV *, u_int32_t *);
 int (*get_feedback) (DB_ENV *, void (**)(DB_ENV *, int, int));
 int (*get_home) (DB_ENV *, const char **);
 int (*get_intermediate_dir_mode) (DB_ENV *, const char **);
 int (*get_isalive) (DB_ENV *, int (**)(DB_ENV *, pid_t, db_threadid_t, u_int32_t))
                                                       ;
 int (*get_lg_bsize) (DB_ENV *, u_int32_t *);
 int (*get_lg_dir) (DB_ENV *, const char **);
 int (*get_lg_filemode) (DB_ENV *, int *);
 int (*get_lg_max) (DB_ENV *, u_int32_t *);
 int (*get_lg_regionmax) (DB_ENV *, u_int32_t *);
 int (*get_lk_conflicts) (DB_ENV *, const u_int8_t **, int *);
 int (*get_lk_detect) (DB_ENV *, u_int32_t *);
 int (*get_lk_max_lockers) (DB_ENV *, u_int32_t *);
 int (*get_lk_max_locks) (DB_ENV *, u_int32_t *);
 int (*get_lk_max_objects) (DB_ENV *, u_int32_t *);
 int (*get_lk_partitions) (DB_ENV *, u_int32_t *);
 int (*get_lk_priority) (DB_ENV *, u_int32_t, u_int32_t *);
 int (*get_lk_tablesize) (DB_ENV *, u_int32_t *);
 int (*get_memory_init) (DB_ENV *, DB_MEM_CONFIG, u_int32_t *);
 int (*get_memory_max) (DB_ENV *, u_int32_t *, u_int32_t *);
 int (*get_metadata_dir) (DB_ENV *, const char **);
 int (*get_mp_max_openfd) (DB_ENV *, int *);
 int (*get_mp_max_write) (DB_ENV *, int *, db_timeout_t *);
 int (*get_mp_mmapsize) (DB_ENV *, size_t *);
 int (*get_mp_mtxcount) (DB_ENV *, u_int32_t *);
 int (*get_mp_pagesize) (DB_ENV *, u_int32_t *);
 int (*get_mp_tablesize) (DB_ENV *, u_int32_t *);
 void (*get_msgcall)
  (DB_ENV *, void (**)(const DB_ENV *, const char *));
 void (*get_msgfile) (DB_ENV *, FILE **);
 int (*get_open_flags) (DB_ENV *, u_int32_t *);
 int (*get_shm_key) (DB_ENV *, long *);
 int (*get_thread_count) (DB_ENV *, u_int32_t *);
 int (*get_thread_id_fn)
  (DB_ENV *, void (**)(DB_ENV *, pid_t *, db_threadid_t *));
 int (*get_thread_id_string_fn) (DB_ENV *, char *(**)(DB_ENV *, pid_t, db_threadid_t, char *))
                                                      ;
 int (*get_timeout) (DB_ENV *, db_timeout_t *, u_int32_t);
 int (*get_tmp_dir) (DB_ENV *, const char **);
 int (*get_tx_max) (DB_ENV *, u_int32_t *);
 int (*get_tx_timestamp) (DB_ENV *, time_t *);
 int (*get_verbose) (DB_ENV *, u_int32_t, int *);
 int (*is_bigendian) (void);
 int (*lock_detect) (DB_ENV *, u_int32_t, u_int32_t, int *);
 int (*lock_get) (DB_ENV *, u_int32_t, u_int32_t, DBT *, db_lockmode_t, DB_LOCK *)
                                                         ;
 int (*lock_id) (DB_ENV *, u_int32_t *);
 int (*lock_id_free) (DB_ENV *, u_int32_t);
 int (*lock_put) (DB_ENV *, DB_LOCK *);
 int (*lock_stat) (DB_ENV *, DB_LOCK_STAT **, u_int32_t);
 int (*lock_stat_print) (DB_ENV *, u_int32_t);
 int (*lock_vec) (DB_ENV *, u_int32_t, u_int32_t, DB_LOCKREQ *, int, DB_LOCKREQ **)
                                                          ;
 int (*log_archive) (DB_ENV *, char **[], u_int32_t);
 int (*log_cursor) (DB_ENV *, DB_LOGC **, u_int32_t);
 int (*log_file) (DB_ENV *, const DB_LSN *, char *, size_t);
 int (*log_flush) (DB_ENV *, const DB_LSN *);
 int (*log_get_config) (DB_ENV *, u_int32_t, int *);
 int (*log_printf) (DB_ENV *, DB_TXN *, const char *, ...);
 int (*log_put) (DB_ENV *, DB_LSN *, const DBT *, u_int32_t);
 int (*log_put_record) (DB_ENV *, DB *, DB_TXN *, DB_LSN *, u_int32_t, u_int32_t, u_int32_t, u_int32_t, DB_LOG_RECSPEC *, ...)

                         ;
 int (*log_read_record) (DB_ENV *, DB **, void *, void *, DB_LOG_RECSPEC *, u_int32_t, void **)
                                                        ;
 int (*log_set_config) (DB_ENV *, u_int32_t, int);
 int (*log_stat) (DB_ENV *, DB_LOG_STAT **, u_int32_t);
 int (*log_stat_print) (DB_ENV *, u_int32_t);
 int (*log_verify) (DB_ENV *, const DB_LOG_VERIFY_CONFIG *);
 int (*lsn_reset) (DB_ENV *, const char *, u_int32_t);
 int (*memp_fcreate) (DB_ENV *, DB_MPOOLFILE **, u_int32_t);
 int (*memp_register) (DB_ENV *, int, int (*)(DB_ENV *, db_pgno_t, void *, DBT *), int (*)(DB_ENV *, db_pgno_t, void *, DBT *))
                                                               ;
 int (*memp_stat) (DB_ENV *, DB_MPOOL_STAT **, DB_MPOOL_FSTAT ***, u_int32_t)
                                                   ;
 int (*memp_stat_print) (DB_ENV *, u_int32_t);
 int (*memp_sync) (DB_ENV *, DB_LSN *);
 int (*memp_trickle) (DB_ENV *, int, int *);
 int (*mutex_alloc) (DB_ENV *, u_int32_t, db_mutex_t *);
 int (*mutex_free) (DB_ENV *, db_mutex_t);
 int (*mutex_get_align) (DB_ENV *, u_int32_t *);
 int (*mutex_get_increment) (DB_ENV *, u_int32_t *);
 int (*mutex_get_init) (DB_ENV *, u_int32_t *);
 int (*mutex_get_max) (DB_ENV *, u_int32_t *);
 int (*mutex_get_tas_spins) (DB_ENV *, u_int32_t *);
 int (*mutex_lock) (DB_ENV *, db_mutex_t);
 int (*mutex_set_align) (DB_ENV *, u_int32_t);
 int (*mutex_set_increment) (DB_ENV *, u_int32_t);
 int (*mutex_set_init) (DB_ENV *, u_int32_t);
 int (*mutex_set_max) (DB_ENV *, u_int32_t);
 int (*mutex_set_tas_spins) (DB_ENV *, u_int32_t);
 int (*mutex_stat) (DB_ENV *, DB_MUTEX_STAT **, u_int32_t);
 int (*mutex_stat_print) (DB_ENV *, u_int32_t);
 int (*mutex_unlock) (DB_ENV *, db_mutex_t);
 int (*open) (DB_ENV *, const char *, u_int32_t, int);
 int (*remove) (DB_ENV *, const char *, u_int32_t);
 int (*rep_elect) (DB_ENV *, u_int32_t, u_int32_t, u_int32_t);
 int (*rep_flush) (DB_ENV *);
 int (*rep_get_clockskew) (DB_ENV *, u_int32_t *, u_int32_t *);
 int (*rep_get_config) (DB_ENV *, u_int32_t, int *);
 int (*rep_get_limit) (DB_ENV *, u_int32_t *, u_int32_t *);
 int (*rep_get_nsites) (DB_ENV *, u_int32_t *);
 int (*rep_get_priority) (DB_ENV *, u_int32_t *);
 int (*rep_get_request) (DB_ENV *, u_int32_t *, u_int32_t *);
 int (*rep_get_timeout) (DB_ENV *, int, u_int32_t *);
 int (*rep_process_message)
  (DB_ENV *, DBT *, DBT *, int, DB_LSN *);
 int (*rep_set_clockskew) (DB_ENV *, u_int32_t, u_int32_t);
 int (*rep_set_config) (DB_ENV *, u_int32_t, int);
 int (*rep_set_limit) (DB_ENV *, u_int32_t, u_int32_t);
 int (*rep_set_nsites) (DB_ENV *, u_int32_t);
 int (*rep_set_priority) (DB_ENV *, u_int32_t);
 int (*rep_set_request) (DB_ENV *, u_int32_t, u_int32_t);
 int (*rep_set_timeout) (DB_ENV *, int, db_timeout_t);
 int (*rep_set_transport) (DB_ENV *, int, int (*)(DB_ENV *, const DBT *, const DBT *, const DB_LSN *, int, u_int32_t))
                                                             ;
 int (*rep_start) (DB_ENV *, DBT *, u_int32_t);
 int (*rep_stat) (DB_ENV *, DB_REP_STAT **, u_int32_t);
 int (*rep_stat_print) (DB_ENV *, u_int32_t);
 int (*rep_sync) (DB_ENV *, u_int32_t);
 int (*repmgr_channel) (DB_ENV *, int, DB_CHANNEL **, u_int32_t);
 int (*repmgr_get_ack_policy) (DB_ENV *, int *);
 int (*repmgr_local_site) (DB_ENV *, DB_SITE **);
 int (*repmgr_msg_dispatch) (DB_ENV *, void (*)(DB_ENV *, DB_CHANNEL *, DBT *, u_int32_t, u_int32_t), u_int32_t)

             ;
 int (*repmgr_set_ack_policy) (DB_ENV *, int);
 int (*repmgr_site)
  (DB_ENV *, const char *, u_int, DB_SITE**, u_int32_t);
 int (*repmgr_site_by_eid) (DB_ENV *, int, DB_SITE**);
 int (*repmgr_site_list) (DB_ENV *, u_int *, DB_REPMGR_SITE **);
 int (*repmgr_start) (DB_ENV *, int, u_int32_t);
 int (*repmgr_stat) (DB_ENV *, DB_REPMGR_STAT **, u_int32_t);
 int (*repmgr_stat_print) (DB_ENV *, u_int32_t);
 int (*set_alloc) (DB_ENV *, void *(*)(size_t), void *(*)(void *, size_t), void (*)(void *))
                                               ;
 int (*set_app_dispatch)
  (DB_ENV *, int (*)(DB_ENV *, DBT *, DB_LSN *, db_recops));
 int (*set_cache_max) (DB_ENV *, u_int32_t, u_int32_t);
 int (*set_cachesize) (DB_ENV *, u_int32_t, u_int32_t, int);
 int (*set_create_dir) (DB_ENV *, const char *);
 int (*set_data_dir) (DB_ENV *, const char *);
 int (*set_data_len) (DB_ENV *, u_int32_t);
 int (*set_backup_callbacks) (DB_ENV *, int (*)(DB_ENV *, const char *, const char *, void **), int (*)(DB_ENV *, u_int32_t, u_int32_t, u_int32_t, u_int8_t *, void *), int (*)(DB_ENV *, const char *, void *))



                                           ;
 int (*set_backup_config) (DB_ENV *, DB_BACKUP_CONFIG, u_int32_t);
 int (*set_encrypt) (DB_ENV *, const char *, u_int32_t);
 void (*set_errcall) (DB_ENV *, void (*)(const DB_ENV *, const char *, const char *))
                                                        ;
 void (*set_errfile) (DB_ENV *, FILE *);
 void (*set_errpfx) (DB_ENV *, const char *);
 int (*set_event_notify)
  (DB_ENV *, void (*)(DB_ENV *, u_int32_t, void *));
 int (*set_feedback) (DB_ENV *, void (*)(DB_ENV *, int, int));
 int (*set_flags) (DB_ENV *, u_int32_t, int);
 int (*set_intermediate_dir_mode) (DB_ENV *, const char *);
 int (*set_isalive) (DB_ENV *, int (*)(DB_ENV *, pid_t, db_threadid_t, u_int32_t))
                                                      ;
 int (*set_lg_bsize) (DB_ENV *, u_int32_t);
 int (*set_lg_dir) (DB_ENV *, const char *);
 int (*set_lg_filemode) (DB_ENV *, int);
 int (*set_lg_max) (DB_ENV *, u_int32_t);
 int (*set_lg_regionmax) (DB_ENV *, u_int32_t);
 int (*set_lk_conflicts) (DB_ENV *, u_int8_t *, int);
 int (*set_lk_detect) (DB_ENV *, u_int32_t);
 int (*set_lk_max_lockers) (DB_ENV *, u_int32_t);
 int (*set_lk_max_locks) (DB_ENV *, u_int32_t);
 int (*set_lk_max_objects) (DB_ENV *, u_int32_t);
 int (*set_lk_partitions) (DB_ENV *, u_int32_t);
 int (*set_lk_priority) (DB_ENV *, u_int32_t, u_int32_t);
 int (*set_lk_tablesize) (DB_ENV *, u_int32_t);
 int (*set_memory_init) (DB_ENV *, DB_MEM_CONFIG, u_int32_t);
 int (*set_memory_max) (DB_ENV *, u_int32_t, u_int32_t);
 int (*set_metadata_dir) (DB_ENV *, const char *);
 int (*set_mp_max_openfd) (DB_ENV *, int);
 int (*set_mp_max_write) (DB_ENV *, int, db_timeout_t);
 int (*set_mp_mmapsize) (DB_ENV *, size_t);
 int (*set_mp_mtxcount) (DB_ENV *, u_int32_t);
 int (*set_mp_pagesize) (DB_ENV *, u_int32_t);
 int (*set_mp_tablesize) (DB_ENV *, u_int32_t);
 void (*set_msgcall)
  (DB_ENV *, void (*)(const DB_ENV *, const char *));
 void (*set_msgfile) (DB_ENV *, FILE *);
 int (*set_paniccall) (DB_ENV *, void (*)(DB_ENV *, int));
 int (*set_shm_key) (DB_ENV *, long);
 int (*set_thread_count) (DB_ENV *, u_int32_t);
 int (*set_thread_id)
  (DB_ENV *, void (*)(DB_ENV *, pid_t *, db_threadid_t *));
 int (*set_thread_id_string) (DB_ENV *, char *(*)(DB_ENV *, pid_t, db_threadid_t, char *))
                                                     ;
 int (*set_timeout) (DB_ENV *, db_timeout_t, u_int32_t);
 int (*set_tmp_dir) (DB_ENV *, const char *);
 int (*set_tx_max) (DB_ENV *, u_int32_t);
 int (*set_tx_timestamp) (DB_ENV *, time_t *);
 int (*set_verbose) (DB_ENV *, u_int32_t, int);
 int (*txn_applied) (DB_ENV *, DB_TXN_TOKEN *, db_timeout_t, u_int32_t)
                                           ;
 int (*stat_print) (DB_ENV *, u_int32_t);
 int (*txn_begin) (DB_ENV *, DB_TXN *, DB_TXN **, u_int32_t);
 int (*txn_checkpoint) (DB_ENV *, u_int32_t, u_int32_t, u_int32_t);
 int (*txn_recover) (DB_ENV *, DB_PREPLIST *, long, long *, u_int32_t)
                                          ;
 int (*txn_stat) (DB_ENV *, DB_TXN_STAT **, u_int32_t);
 int (*txn_stat_print) (DB_ENV *, u_int32_t);
 /* DB_ENV PUBLIC HANDLE LIST END */

 /* DB_ENV PRIVATE HANDLE LIST BEGIN */
 int (*prdbt) (DBT *, int, const char *, void *, int (*)(void *, const void *), int, int)
                                                                 ;
 /* DB_ENV PRIVATE HANDLE LIST END */
};

/*
 * Dispatch structure for recovery, log verification and print routines. Since
 * internal and external routines take different arguments (ENV versus DB_ENV),
 * we need something more elaborate than a single pointer and size.
 */
struct __db_distab {
 int (**int_dispatch) (ENV *, DBT *, DB_LSN *, db_recops, void *);
 size_t int_size;
 int (**ext_dispatch) (DB_ENV *, DBT *, DB_LSN *, db_recops);
 size_t ext_size;
};

/*
 * Log verification configuration structure.
 */
struct __db_logvrfy_config {
 int continue_after_fail, verbose;
 u_int32_t cachesize;
 const char *temp_envhome;
 const char *dbfile, *dbname;
 DB_LSN start_lsn, end_lsn;
 time_t start_time, end_time;
};

struct __db_channel {
 CHANNEL *channel; /* Pointer to internal state details. */
 int eid; /* Env. ID passed in constructor. */
 db_timeout_t timeout;

 /* DB_CHANNEL PUBLIC HANDLE LIST BEGIN */
 int (*close) (DB_CHANNEL *, u_int32_t);
 int (*send_msg) (DB_CHANNEL *, DBT *, u_int32_t, u_int32_t);
 int (*send_request) (DB_CHANNEL *, DBT *, u_int32_t, DBT *, db_timeout_t, u_int32_t)
                                                    ;
 int (*set_timeout) (DB_CHANNEL *, db_timeout_t);
 /* DB_CHANNEL PUBLIC HANDLE LIST END */
};

struct __db_site {
 ENV *env;
 int eid;
 const char *host;
 u_int port;
 u_int32_t flags;

 /* DB_SITE PUBLIC HANDLE LIST BEGIN */
 int (*get_address) (DB_SITE *, const char **, u_int *);
 int (*get_config) (DB_SITE *, u_int32_t, u_int32_t *);
 int (*get_eid) (DB_SITE *, int *);
 int (*set_config) (DB_SITE *, u_int32_t, u_int32_t);
 int (*remove) (DB_SITE *);
 int (*close) (DB_SITE *);
 /* DB_SITE PUBLIC HANDLE LIST END */
};
# 2811 "/usr/include/db.h" 3 4
/* DO NOT EDIT: automatically built by dist/s_apiflags. */
# 3040 "/usr/include/db.h" 3 4
/* DO NOT EDIT: automatically built by dist/s_include. */







int db_copy (DB_ENV *, const char *, const char *, const char *);
int db_create (DB **, DB_ENV *, u_int32_t);
char *db_strerror (int);
int db_env_set_func_assert (void (*)(const char *, const char *, int));
int db_env_set_func_close (int (*)(int));
int db_env_set_func_dirfree (void (*)(char **, int));
int db_env_set_func_dirlist (int (*)(const char *, char ***, int *));
int db_env_set_func_exists (int (*)(const char *, int *));
int db_env_set_func_free (void (*)(void *));
int db_env_set_func_fsync (int (*)(int));
int db_env_set_func_ftruncate (int (*)(int, off_t));
int db_env_set_func_ioinfo (int (*)(const char *, int, u_int32_t *, u_int32_t *, u_int32_t *));
int db_env_set_func_malloc (void *(*)(size_t));
int db_env_set_func_file_map (int (*)(DB_ENV *, char *, size_t, int, void **), int (*)(DB_ENV *, void *));
int db_env_set_func_region_map (int (*)(DB_ENV *, char *, size_t, int *, void **), int (*)(DB_ENV *, void *));
int db_env_set_func_pread (ssize_t (*)(int, void *, size_t, off_t));
int db_env_set_func_pwrite (ssize_t (*)(int, const void *, size_t, off_t));
int db_env_set_func_open (int (*)(const char *, int, ...));
int db_env_set_func_read (ssize_t (*)(int, void *, size_t));
int db_env_set_func_realloc (void *(*)(void *, size_t));
int db_env_set_func_rename (int (*)(const char *, const char *));
int db_env_set_func_seek (int (*)(int, off_t, int));
int db_env_set_func_unlink (int (*)(const char *));
int db_env_set_func_write (ssize_t (*)(int, const void *, size_t));
int db_env_set_func_yield (int (*)(u_long, u_long));
int db_env_create (DB_ENV **, u_int32_t);
char *db_version (int *, int *, int *);
char *db_full_version (int *, int *, int *, int *, int *);
int log_compare (const DB_LSN *, const DB_LSN *);



int db_sequence_create (DB_SEQUENCE **, DB *, u_int32_t);
# 102 "src/dbstuff.h" 2


/* We can distinguish between versions 1.x and 2.x/3.x by looking for a
definition of DB_VERSION_STRING, which is present in versions 2.x onwards. */



/* The API changed (again!) between the 2.x and 3.x versions */



/***************** Berkeley db 3.x/4.x native definitions ******************/

/* Basic DB type */


/* Cursor type, for scanning */


/* The datum type used for queries */


/* Some text for messages */


/* Access functions */

/* EXIM_DBOPEN - sets *dbpp to point to an EXIM_DB, NULL if failed. The
API changed for DB 4.1. */
# 150 "src/dbstuff.h"
/* EXIM_DBGET - returns TRUE if successful, FALSE otherwise */



/* EXIM_DBPUT - returns nothing useful, assumes replace mode */



/* EXIM_DBPUTB - non-overwriting for use by dbmbuild */



/* Return values from EXIM_DBPUTB */




/* EXIM_DBDEL */


/* EXIM_DBCREATE_CURSOR - initialize for scanning operation */




/* EXIM_DBSCAN - returns TRUE if data is returned, FALSE at end */




/* EXIM_DBDELETE_CURSOR - terminate scanning operation */



/* EXIM_DBCLOSE */


/* Datum access types - these are intended to be assignable. */




/* The whole datum structure contains other fields that must be cleared
before use, but we don't have to free anything after reading data. */
# 283 "src/dbstuff.h"
/* If DB_VERSION_TYPE is not defined, we have version 1.x */
# 367 "src/dbstuff.h"
/********************* gdbm interface definitions **********************/
# 531 "src/dbstuff.h"
/********************* End of dbm library definitions **********************/


/* Structure for carrying around an open DBM file, and an open locking file
that relates to it. */

typedef struct {
  DB *dbptr;
  int lockfd;
} open_db;


/* Structures for records stored in exim database dbm files. They all
start with the same fields, described in the generic type. */


typedef struct {
  time_t time_stamp; /* Timestamp of writing */
} dbdata_generic;


/* This structure keeps track of retry information for a host or a local
address. */

typedef struct {
  time_t time_stamp;
  /*************/
  time_t first_failed; /* Time of first failure */
  time_t last_try; /* Time of last try */
  time_t next_try; /* Time of next try */
  BOOL expired; /* Retry time has expired */
  int basic_errno; /* Errno of last failure */
  int more_errno; /* Additional information */
  uschar text[1]; /* Text message for last failure */
} dbdata_retry;

/* These structures keep track of addresses that have had callout verification
performed on them. There are two groups of records:

1. keyed by localpart@domain -
     Full address was tested and record holds result

2. keyed by domain -
     Domain response upto MAIL FROM:<>, postmaster, random local part;

If a record exists, the result field is either ccache_accept or ccache_reject,
or, for a domain record only, ccache_reject_mfnull when MAIL FROM:<> was
rejected. The other fields, however, (which are only relevant to domain
records) may also contain ccache_unknown if that particular test has not been
done.

Originally, there was only one structure, used for both types. However, it got
expanded for domain records, so it got split. To make it possible for Exim to
handle the old type of record, we retain the old definition. The different
kinds of record can be distinguised by their different lengths. */

typedef struct {
  time_t time_stamp;
  /*************/
  int result;
  int postmaster_result; /* Postmaster is accepted */
  int random_result; /* Random local part was accepted */
} dbdata_callout_cache_obs;

typedef struct {
  time_t time_stamp; /* Timestamp of last address check */
  /*************/
  int result; /* accept or reject */
} dbdata_callout_cache_address;

/* For this new layout, we put the additional fields (the timestamps)
last so that if somebody reverts to an older Exim, the new records will
still make sense because they match the old layout. */

typedef struct {
  time_t time_stamp; /* Time stamp of last connection */
  /*************/
  int result; /* Domain reject or accept */
  int postmaster_result; /* Postmaster result */
  int random_result; /* Random result */
  time_t postmaster_stamp; /* Timestamp of postmaster check */
  time_t random_stamp; /* Timestamp of random check */
} dbdata_callout_cache;

/* This structure keeps track of messages that are waiting for a particular
host for a particular transport. */

typedef struct {
  time_t time_stamp;
  /*************/
  int count; /* Count of message ids */
  int sequence; /* Sequence for continued records */
  uschar text[1]; /* One long character string */
} dbdata_wait;


/* The contents of the "misc" database are a mixture of different kinds of
record, as defined below. The keys used for a specific type all start with a
given string such as "etrn-" or "host-serialize-". */


/* This structure records a connection to a particular host, for the
purpose of serializing access to certain hosts. For possible future extension,
a field is defined for holding the count of connections, but it is not
at present in use. The same structure is used for recording a running ETRN
process. */

typedef struct {
  time_t time_stamp;
  /*************/
  int count; /* Reserved for possible connection count */
} dbdata_serialize;


/* This structure records the information required for the ratelimit
ACL condition. */

typedef struct {
  time_t time_stamp;
  /*************/
  int time_usec; /* Fractional part of time, from gettimeofday() */
  double rate; /* Smoothed sending rate at that time */
} dbdata_ratelimit;

/* Same as above, plus a Bloom filter for uniquifying events. */

typedef struct {
  dbdata_ratelimit dbd;
  time_t bloom_epoch; /* When the Bloom filter was last reset */
  unsigned bloom_size; /* Number of bytes in the Bloom filter */
  uschar bloom[40]; /* Bloom filter which may be larger than this */
} dbdata_ratelimit_unique;


/* End of dbstuff.h */
# 470 "src/exim.h" 2
# 1 "src/structs.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2012 */
/* See the file NOTICE for conditions of use and distribution. */


/* Definitions of various structures. In addition, those that are visible for
the compilation of local_scan() are defined in local_scan.h. These are

  header_line
  optionlist
  recipient_item

For those declared here, we have to pre-declare some because of mutually
recursive definitions in the auths, routers, and transports blocks. */

struct address_item;
struct auth_info;
struct driver_info;
struct director_info;
struct smtp_inblock;
struct smtp_outblock;
struct transport_info;
struct router_info;

typedef int BOOL;
typedef unsigned char uschar;

/* Structure for remembering macros for the configuration file */

typedef struct macro_item {
  struct macro_item *next;
  BOOL command_line;
  uschar *replacement;
  uschar name[1];
} macro_item;

/* Structure for bit tables for debugging and logging */

typedef struct bit_table {
  uschar *name;
  unsigned int bit;
} bit_table;

/* Block for holding a uid and gid, possibly unset, and an initgroups flag. */

typedef struct ugid_block {
  uid_t uid;
  gid_t gid;
  BOOL uid_set;
  BOOL gid_set;
  BOOL initgroups;
} ugid_block;

/* Structure for holding information about a host for use mainly by routers,
but also used when checking lists of hosts and when transporting. Looking up
host addresses is done using this structure. */

typedef struct host_item {
  struct host_item *next;
  uschar *name; /* Host name */
  uschar *address; /* IP address in text form */
  int port; /* port value in host order (if SRV lookup) */
  int mx; /* MX value if found via MX records */
  int sort_key; /* MX*1000 plus random "fraction" */
  int status; /* Usable, unusable, or unknown */
  int why; /* Why host is unusable */
  int last_try; /* Time of last try if known */
} host_item;

/* Chain of rewrite rules, read from the rewrite config, or parsed from the
rewrite_headers field of a transport. */

typedef struct rewrite_rule {
  struct rewrite_rule *next;
  int flags;
  uschar *key;
  uschar *replacement;
} rewrite_rule;

/* This structure is used to pass back configuration data from the smtp
transport to the outside world. It is used during callback processing. If ever
another remote transport were implemented, it could use the same structure. */

typedef struct transport_feedback {
  uschar *interface;
  uschar *port;
  uschar *protocol;
  uschar *hosts;
  uschar *helo_data;
  BOOL hosts_override;
  BOOL hosts_randomize;
  BOOL gethostbyname;
  BOOL qualify_single;
  BOOL search_parents;
} transport_feedback;

/* Routers, transports, and authenticators have similar data blocks. Each
driver that is compiled into the code is represented by a xxx_info block; the
active drivers are represented by a chain of xxx_instance blocks. To make it
possible to use the same code for reading the configuration files for all
three, the layout of the start of the blocks is kept the same, and represented
by the generic structures driver_info and driver_instance. */

typedef struct driver_instance {
  struct driver_instance *next;
  uschar *name; /* Instance name */
  struct driver_info *info; /* Points to info for this driver */
  void *options_block; /* Pointer to private options */
  uschar *driver_name; /* All start with this generic option */
} driver_instance;

typedef struct driver_info {
  uschar *driver_name; /* Name of driver */
  optionlist *options; /* Table of private options names */
  int *options_count; /* -> Number of entries in table */
  void *options_block; /* Points to default private block */
  int options_len; /* Length of same in bytes */
  void (*init)( /* Initialization entry point */
    struct driver_instance *);
} driver_info;


/* Structure for holding information about the configured transports. Some
of the generally accessible options are set from the configuration file; others
are set by transport initialization, since they can only be set for certain
transports. They need to be generally accessible, however, as they are used by
the main transport code. */

typedef struct transport_instance {
  struct transport_instance *next;
  uschar *name; /* Instance name */
  struct transport_info *info; /* Info for this driver */
  void *options_block; /* Pointer to private options */
  uschar *driver_name; /* Must be first */
  int (*setup)( /* Setup entry point */
    struct transport_instance *,
    struct address_item *,
    struct transport_feedback *, /* For passing back config data */
    uid_t, /* The uid that will be used */
    gid_t, /* The gid that will be used */
    uschar **); /* For an error message */
                                  /**************************************/
  int batch_max; /* )                                  */
  uschar *batch_id; /* )                                  */
  uschar *home_dir; /* ) Used only for local transports   */
  uschar *current_dir; /* )                                  */
                                  /**************************************/
  BOOL multi_domain; /* )                                  */
  BOOL overrides_hosts; /* ) Used only for remote transports  */
  int max_addresses; /* )                                  */
  int connection_max_messages;/* )                                  */
                                  /**************************************/
  BOOL deliver_as_creator; /* Used only by pipe at present */
  BOOL disable_logging; /* For very weird requirements */
  BOOL initgroups; /* Initialize groups when setting uid */
  BOOL uid_set; /* uid is set */
  BOOL gid_set; /* gid is set */
  uid_t uid;
  gid_t gid;
  uschar *expand_uid; /* Variable uid */
  uschar *expand_gid; /* Variable gid */
  uschar *warn_message; /* Used only by appendfile at present */
  uschar *shadow; /* Name of shadow transport */
  uschar *shadow_condition; /* Condition for running it */
  uschar *filter_command; /* For on-the-fly-filtering */
  uschar *add_headers; /* Add these headers */
  uschar *remove_headers; /* Remove these headers */
  uschar *return_path; /* Overriding (rewriting) return path */
  uschar *debug_string; /* Debugging output */
  uschar *message_size_limit; /* Biggest message this transport handles */
  uschar *headers_rewrite; /* Rules for rewriting headers */
  rewrite_rule *rewrite_rules; /* Parsed rewriting rules */
  int rewrite_existflags; /* Bits showing which headers are rewritten */
  int filter_timeout; /* For transport filter timing */
  BOOL body_only; /* Deliver only the body */
  BOOL delivery_date_add; /* Add Delivery-Date header */
  BOOL envelope_to_add; /* Add Envelope-To header */
  BOOL headers_only; /* Deliver only the headers */
  BOOL rcpt_include_affixes; /* TRUE to retain affixes in RCPT commands */
  BOOL return_path_add; /* Add Return-Path header */
  BOOL return_output; /* TRUE if output should always be returned */
  BOOL return_fail_output; /* ditto, but only on failure */
  BOOL log_output; /* Similarly for logging */
  BOOL log_fail_output;
  BOOL log_defer_output;
  BOOL retry_use_local_part; /* Defaults true for local, false for remote */
} transport_instance;


/* Structure for holding information about a type of transport. The first six
fields must match driver_info above. */

typedef struct transport_info {
  uschar *driver_name; /* Driver name */
  optionlist *options; /* Table of private options names */
  int *options_count; /* -> Number of entries in table */
  void *options_block; /* Points to default private block */
  int options_len; /* Length of same in bytes */
  void (*init)( /* Initialization function */
    struct transport_instance *);
/****/
  BOOL (*code)( /* Main entry point */
    transport_instance *,
    struct address_item *);
  void (*tidyup)( /* Tidyup function */
    struct transport_instance *);
  void (*closedown)( /* For closing down a passed channel */
    struct transport_instance *);
  BOOL local; /* TRUE for local transports */
} transport_info;



/* Structure for holding information about the configured routers. */

typedef struct router_instance {
  struct router_instance *next;
  uschar *name;
  struct router_info *info;
  void *options_block; /* Pointer to private options */
  uschar *driver_name; /* Must be first */

  uschar *address_data; /* Arbitrary data */



  uschar *cannot_route_message; /* Used when routing fails */
  uschar *condition; /* General condition */
  uschar *current_directory; /* For use during delivery */
  uschar *debug_string; /* Debugging output */
  uschar *domains; /* Specific domains */
  uschar *errors_to; /* Errors address */
  uschar *expand_gid; /* Expanded gid string */
  uschar *expand_uid; /* Expanded uid string */
  uschar *expand_more; /* Expanded more string */
  uschar *expand_unseen; /* Expanded unseen string */
  uschar *extra_headers; /* Additional headers */
  uschar *fallback_hosts; /* For remote transports (text list) */
  uschar *home_directory; /* For use during delivery */
  uschar *ignore_target_hosts; /* Target hosts to ignore */
  uschar *local_parts; /* Specific local parts */
  uschar *pass_router_name; /* Router for passed address */
  uschar *prefix; /* Address prefix */
  uschar *redirect_router_name; /* Router for generated address */
  uschar *remove_headers; /* Removed headers */
  uschar *require_files; /* File checks before router is run */
  uschar *router_home_directory; /* For use while routing */
  uschar *self; /* Text option for handling self reference */
  uschar *senders; /* Specific senders */
  uschar *suffix; /* Address suffix */
  uschar *translate_ip_address; /* IP address translation fudgery */
  uschar *transport_name; /* Transport name */

  BOOL address_test; /* Use this router when testing addresses */





  BOOL expn; /* Use this router when processing EXPN */
  BOOL caseful_local_part; /* TRUE => don't lowercase */
  BOOL check_local_user; /* TRUE => check local user */
  BOOL disable_logging; /* For very weird requirements */
  BOOL fail_verify_recipient; /* Fail verify if recipient match this router */
  BOOL fail_verify_sender; /* Fail verify if sender match this router */
  BOOL gid_set; /* Flag to indicate gid is set */
  BOOL initgroups; /* TRUE if initgroups is required */
  BOOL log_as_local; /* TRUE logs as a local delivery */
  BOOL more; /* If FALSE, do no more if this one fails */
  BOOL pass_on_timeout; /* Treat timeout DEFERs as fails */
  BOOL prefix_optional; /* Just what it says */
  BOOL repeat_use; /* If FALSE, skip if ancestor used it */
  BOOL retry_use_local_part; /* Just what it says */
  BOOL same_domain_copy_routing; /* TRUE => copy routing for same domain */
  BOOL self_rewrite; /* TRUE to rewrite headers if making local */
  BOOL suffix_optional; /* As it says */
  BOOL verify_only; /* Skip this router if not verifying */
  BOOL verify_recipient; /* Use this router when verifying a recipient*/
  BOOL verify_sender; /* Use this router when verifying a sender */
  BOOL uid_set; /* Flag to indicate uid is set */
  BOOL unseen; /* If TRUE carry on, even after success */

  int self_code; /* Encoded version of "self" */
  uid_t uid; /* Fixed uid value */
  gid_t gid; /* Fixed gid value */

  host_item *fallback_hostlist; /* For remote transport (block chain) */
  transport_instance *transport; /* Transport block (when found) */
  struct router_instance *pass_router; /* Actual router for passed address */
  struct router_instance *redirect_router; /* Actual router for generated address */
} router_instance;


/* Structure for holding information about a type of router. The first six
fields must match driver_info above. */

typedef struct router_info {
  uschar *driver_name;
  optionlist *options; /* Table of private options names */
  int *options_count; /* -> Number of entries in table */
  void *options_block; /* Points to default private block */
  int options_len; /* Length of same in bytes */
  void (*init)( /* Initialization function */
    struct router_instance *);
/****/
  int (*code)( /* Main entry point */
    router_instance *,
    struct address_item *,
    struct passwd *,
    int,
    struct address_item **,
    struct address_item **,
    struct address_item **,
    struct address_item **);
  void (*tidyup)( /* Tidyup function */
    struct router_instance *);
  int ri_flags; /* Descriptive flags */
} router_info;


/* Structure for holding information about a lookup type. */

# 1 "src/lookupapi.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2009 */
/* See the file NOTICE for conditions of use and distribution. */


/* The "type" field in each item is a set of bit flags:

  lookup_querystyle     => this is a query-style lookup,
                             else single-key (+ file) style
  lookup_absfile        => an absolute file name is required,
                             (for single-key style only)
*/

typedef struct lookup_info {
  uschar *name; /* e.g. "lsearch" */
  int type; /* query/singlekey/abs-file */
  void *(*open)( /* open function */
    uschar *, /* file name for those that have one */
    uschar **); /* for error message */
  BOOL (*check)( /* file checking function */
    void *, /* handle */
    uschar *, /* file name */
    int, /* modemask for file checking */
    uid_t *, /* owners for file checking */
    gid_t *, /* owngroups for file checking */
    uschar **); /* for error messages */
  int (*find)( /* find function */
    void *, /* handle */
    uschar *, /* file name or NULL */
    uschar *, /* key or query */
    int, /* length of key or query */
    uschar **, /* for returning answer */
    uschar **, /* for error message */
    BOOL *); /* to request cache cleanup */
  void (*close)( /* close function */
    void *); /* handle */
  void (*tidy)(void); /* tidy function */
  uschar *(*quote)( /* quoting function */
    uschar *, /* string to quote */
    uschar *); /* additional data from quote name */
  void (*version_report)( /* diagnostic function */
    FILE *); /* fh to write to */
} lookup_info;

/* This magic number is used by the following lookup_module_info structure
   for checking API compatibility. It's equivalent to the string"LMM2" */

/* Version 2 adds: version_report */

typedef struct lookup_module_info {
  uint magic;
  lookup_info **lookups;
  uint lookupcount;
} lookup_module_info;

/* End of lookupapi.h */
# 327 "src/structs.h" 2


/* Structure for holding information about the configured authentication
mechanisms */

typedef struct auth_instance {
  struct auth_instance *next;
  uschar *name; /* Exim instance name */
  struct auth_info *info; /* Pointer to driver info block */
  void *options_block; /* Pointer to private options */
  uschar *driver_name; /* Must be first */
  uschar *advertise_condition; /* Are we going to advertise this?*/
  uschar *client_condition; /* Should the client try this? */
  uschar *public_name; /* Advertised name */
  uschar *set_id; /* String to set as authenticated id */
  uschar *mail_auth_condition; /* Condition for AUTH on MAIL command */
  uschar *server_debug_string; /* Debugging output */
  uschar *server_condition; /* Authorization condition */
  BOOL client; /* TRUE if client option(s) set */
  BOOL server; /* TRUE if server options(s) set */
  BOOL advertised; /* Set TRUE when advertised */
} auth_instance;


/* Structure for holding information about an authentication mechanism. The
first six fields must match driver_info above. */

typedef struct auth_info {
  uschar *driver_name; /* e.g. "condition" */
  optionlist *options; /* Table of private options names */
  int *options_count; /* -> Number of entries in table */
  void *options_block; /* Points to default private block */
  int options_len; /* Length of same in bytes */
  void (*init)( /* initialization function */
    struct auth_instance *);
/****/
  int (*servercode)( /* server function */
    auth_instance *, /* the instance data */
    uschar *); /* rest of AUTH command */
  int (*clientcode)( /* client function */
    struct auth_instance *,
    struct smtp_inblock *, /* socket and input buffer */
    struct smtp_outblock *, /* socket and output buffer */
    int, /* command timeout */
    uschar *, /* buffer for reading response */
    int); /* sizeof buffer */
  void (*version_report)( /* diagnostic version reporting */
    FILE *); /* I/O stream to print to */
} auth_info;


/* Structure for holding a single IP address and port; used for the chain of
addresses and ports for the local host. Make the char string large enough to
hold an IPv6 address. */

typedef struct ip_address_item {
  struct ip_address_item *next;
  int port;
  BOOL v6_include_v4; /* Used in the daemon */
  uschar address[46];
} ip_address_item;

/* Structure for chaining together arbitrary strings. */

typedef struct string_item {
  struct string_item *next;
  uschar *text;
} string_item;

/* Information about a soft delivery failure, for use when calculating
retry information. It's separate from the address block, because there
can be a chain of them for SMTP deliveries where multiple IP addresses
can be tried. */

typedef struct retry_item {
  struct retry_item *next; /* for chaining */
  uschar *key; /* string identifying host/address/message */
  int basic_errno; /* error code for this destination */
  int more_errno; /* additional error information */
  uschar *message; /* local error message */
  int flags; /* see below */
} retry_item;

/* Retry data flags */





/* Information about a constructed message that is to be sent using the
autoreply transport. This is pointed to from the address block. */

typedef struct reply_item {
  uschar *from; /* ) */
  uschar *reply_to; /* ) */
  uschar *to; /* ) */
  uschar *cc; /* ) specific header fields */
  uschar *bcc; /* ) */
  uschar *subject; /* ) */
  uschar *headers; /* misc other headers, concatenated */
  uschar *text; /* text string body */
  uschar *file; /* file body */
  BOOL file_expand; /* expand the body */
  int expand_forbid; /* expansion lockout flags */
  uschar *logfile; /* file to keep a log in */
  uschar *oncelog; /* file to keep records in for once only */
  time_t once_repeat; /* time to repeat "once only" */
  BOOL return_message; /* send back the original message */
} reply_item;


/* The address_item structure contains many fields which are used at various
times while delivering a message. Some are used only for remote deliveries;
some only for local. A particular set of fields is copied whenever a child
address is created. For convenience, we keep those fields in a separate
sub-structure so they can be copied in one go. This also means I won't forget
to edit the various copying places when new to-be-copied fields are added. */

typedef struct address_item_propagated {
  uschar *address_data; /* arbitrary data to keep with the address */
  uschar *domain_data; /* from "domains" lookup */
  uschar *localpart_data; /* from "local_parts" lookup */
  uschar *errors_address; /* where to send errors (NULL => sender) */
  header_line *extra_headers; /* additional headers */
  uschar *remove_headers; /* list of those to remove */




} address_item_propagated;

/* Bits for the flags field below */
# 488 "src/structs.h"
/* These flags must be propagated when a child is created */



/* The main address structure. Note that fields that are to be copied to
generated addresses should be put in the address_item_propagated structure (see
above) rather than directly into the address_item structure. */

typedef struct address_item {
  struct address_item *next; /* for chaining addresses */
  struct address_item *parent; /* parent address */
  struct address_item *first; /* points to first after group delivery */
  struct address_item *dupof; /* points to address this is a duplicate of */

  router_instance *start_router; /* generated address starts here */
  router_instance *router; /* the router that routed */
  transport_instance *transport; /* the transport to use */

  host_item *host_list; /* host data for the transport */
  host_item *host_used; /* host that took delivery or failed hard */
  host_item *fallback_hosts; /* to try if delivery defers */

  reply_item *reply; /* data for autoreply */
  retry_item *retries; /* chain of retry information */

  uschar *address; /* address being delivered or routed */
  uschar *unique; /* used for disambiguating */
  uschar *cc_local_part; /* caseful local part */
  uschar *lc_local_part; /* lowercased local part */
  uschar *local_part; /* points to cc or lc version */
  uschar *prefix; /* stripped prefix of local part */
  uschar *suffix; /* stripped suffix of local part */
  uschar *domain; /* working domain (lower cased) */

  uschar *address_retry_key; /* retry key including full address */
  uschar *domain_retry_key; /* retry key for domain only */

  uschar *current_dir; /* current directory for transporting */
  uschar *home_dir; /* home directory for transporting */
  uschar *message; /* error message */
  uschar *user_message; /* error message that can be sent over SMTP
                                     or quoted in bounce message */
  uschar *onetime_parent; /* saved original parent for onetime */
  uschar **pipe_expandn; /* numeric expansions for pipe from filter */
  uschar *return_filename; /* name of return file */
  uschar *self_hostname; /* after self=pass */
  uschar *shadow_message; /* info about shadow transporting */






  uid_t uid; /* uid for transporting */
  gid_t gid; /* gid for transporting */

  unsigned int flags; /* a row of bits, defined above */
  unsigned int domain_cache[(16 * 2)/32];
  unsigned int localpart_cache[(16 * 2)/32];
  int mode; /* mode for local transporting to a file */
  int more_errno; /* additional error information */
                                  /* (may need to hold a timestamp) */

  short int basic_errno; /* status after failure */
  short int child_count; /* number of child addresses */
  short int return_file; /* fileno of return data file */
  short int special_action; /* ( used when when deferred or failed */
                                  /* (  also  */
                                  /* ( contains = or - when successful SMTP delivered */
                                  /* (  also  */
                                  /* ( contains verify rc in sender verify cache */
  short int transport_return; /* result of delivery attempt */
  address_item_propagated p; /* fields that are propagated to children */
} address_item;

/* The table of header names consists of items of this type */

typedef struct {
  uschar *name;
  int len;
  BOOL allow_resent;
  int htype;
} header_name;

/* Chain of information about errors (e.g. bad addresses) */

typedef struct error_block {
  struct error_block *next;
  uschar *text1;
  uschar *text2;
} error_block;

/* Chain of file names when processing the queue */

typedef struct queue_filename {
  struct queue_filename *next;
  uschar dir_uschar;
  uschar text[1];
} queue_filename;

/* Chain of items of retry information, read from the retry config. */

typedef struct retry_rule {
  struct retry_rule *next;
  int rule;
  int timeout;
  int p1;
  int p2;
} retry_rule;

typedef struct retry_config {
  struct retry_config *next;
  uschar *pattern;
  int basic_errno;
  int more_errno;
  uschar *senders;
  retry_rule *rules;
} retry_config;

/* Structure for each node in a tree, of which there are various kinds */

typedef struct tree_node {
  struct tree_node *left; /* pointer to left child */
  struct tree_node *right; /* pointer to right child */
  union
    {
    void *ptr; /* pointer to data */
    int val; /* or integer data */
    } data;
  uschar balance; /* balancing factor */
  uschar name[1]; /* node name - variable length */
} tree_node;

/* Structure for holding the handle and the cached last lookup for searches.
This block is pointed to by the tree entry for the file. The file can get
closed if too many are opened at once. There is a LRU chain for deciding which
to close. */

typedef struct search_cache {
  void *handle; /* lookup handle, or NULL if closed */
  int search_type; /* search type */
  tree_node *up; /* LRU up pointer */
  tree_node *down; /* LRU down pointer */
  tree_node *item_cache; /* tree of cached results */
} search_cache;

/* Structure for holding a partially decoded DNS record; the name has been
uncompressed, but the data pointer is into the raw data. */

typedef struct {
  uschar name[1024]; /* domain name */
  int type; /* record type */
  int size; /* size of data */
  uschar *data; /* pointer to data */
} dns_record;

/* Structure for holding the result of a DNS query. */

typedef struct {
  int answerlen; /* length of the answer */
  uschar answer[2048]; /* the answer itself */
} dns_answer;

/* Structure for holding the intermediate data while scanning a DNS answer
block. */

typedef struct {
  int rrcount; /* count of RRs in the answer */
  uschar *aptr; /* pointer in the answer while scanning */
  dns_record srr; /* data from current record in scan */
} dns_scan;

/* Structure for holding a chain of IP addresses that are extracted from
an A, AAAA, or A6 record. For the first two, there is only ever one address,
but the chaining feature of A6 allows for several addresses to be realized from
a single initial A6 record. The structure defines the address field of length
1. In use, a suitable sized block is obtained to hold the complete textual
address. */

typedef struct dns_address {
  struct dns_address *next;
  uschar address[1];
} dns_address;

/* Structure used for holding intermediate data during MD5 computations. */

typedef struct md5 {
  unsigned int length;
  unsigned int abcd[4];
  }
md5;

/* Structure used for holding intermediate data during SHA-1 computations. */

typedef struct sha1 {
  unsigned int H[5];
  unsigned int length;
  }
sha1;

/* Structure used to hold incoming packets of SMTP responses for a specific
socket. The packets which may contain multiple lines (and in some cases,
multiple responses). */

typedef struct smtp_inblock {
  int sock; /* the socket */
  int buffersize; /* the size of the buffer */
  uschar *ptr; /* current position in the buffer */
  uschar *ptrend; /* end of data in the buffer */
  uschar *buffer; /* the buffer itself */
} smtp_inblock;

/* Structure used to hold buffered outgoing packets of SMTP commands for a
specific socket. The packets which may contain multiple lines when pipelining
is in use. */

typedef struct smtp_outblock {
  int sock; /* the socket */
  int cmd_count; /* count of buffered commands */
  int buffersize; /* the size of the buffer */
  BOOL authenticating; /* TRUE when authenticating */
  uschar *ptr; /* current position in the buffer */
  uschar *buffer; /* the buffer itself */
} smtp_outblock;

/* Structure to hold information about the source of redirection information */

typedef struct redirect_block {
  uschar *string; /* file name or string */
  uid_t *owners; /* allowed file owners */
  gid_t *owngroups; /* allowed file groups */
  struct passwd *pw; /* possible owner if not NULL */
  int modemask; /* forbidden bits */
  BOOL isfile; /* TRUE if string is a file name */
  BOOL check_owner; /* TRUE, FALSE, or TRUE_UNSET */
  BOOL check_group; /* TRUE, FALSE, or TRUE_UNSET */
} redirect_block;

/* Structure for passing arguments to check_host() */

typedef struct check_host_block {
  uschar *host_name;
  uschar *host_address;
  uschar *host_ipv4;
  BOOL negative;
} check_host_block;

/* Structure for remembering lookup data when caching the result of
a lookup in a named list. */

typedef struct namedlist_cacheblock {
  struct namedlist_cacheblock *next;
  uschar *key;
  uschar *data;
} namedlist_cacheblock;

/* Structure for holding data for an entry in a named list */

typedef struct namedlist_block {
  uschar *string; /* the list string */
  namedlist_cacheblock *cache_data; /* cached domain_data or localpart_data */
  int number; /* the number of the list for caching */
} namedlist_block;

/* Structures for Access Control Lists */

typedef struct acl_condition_block {
  struct acl_condition_block *next;
  uschar *arg;
  int type;
  union {
    BOOL negated;
    uschar *varname;
  } u;
} acl_condition_block;

typedef struct acl_block {
  struct acl_block *next;
  acl_condition_block *condition;
  int verb;
} acl_block;

/* End of structs.h */
# 471 "src/exim.h" 2
# 1 "src/globals.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2012 */
/* See the file NOTICE for conditions of use and distribution. */

/* Almost all the global variables are defined together in this one header, so
that they are easy to find. However, those that are visible during the
compilation of the local_scan() function are defined separately in the
local_scan.h header file. */

/* First put any specials that are required for some operating systems. */





/* We need to be careful about width of int and atomicity in signal handlers,
especially with the rise of 64-bit systems breaking older assumptions.  But
sig_atomic_t comes from signal.h so can't go into mytypes.h without including
signal support in local_scan, which seems precipitous. */
typedef volatile sig_atomic_t SIGNAL_BOOL;

/* Now things that are present only when configured. */
# 73 "src/globals.h"
/* These variables are outside the #ifdef because it keeps the code less
cluttered in several places (e.g. during logging) if we can always refer to
them. Also, the tls_ variables are now always visible. */

extern int tls_active; /* fd/socket when in a TLS session */
extern int tls_bits; /* bits used in TLS session */
extern BOOL tls_certificate_verified; /* Client certificate verified */
extern uschar *tls_cipher; /* Cipher used */
extern BOOL tls_on_connect; /* For older MTAs that don't STARTTLS */
extern uschar *tls_on_connect_ports; /* Ports always tls-on-connect */
extern uschar *tls_peerdn; /* DN from peer */
# 112 "src/globals.h"
/* Input-reading functions for messages, so we can use special ones for
incoming TCP/IP. */

extern int (*receive_getc)(void);
extern int (*receive_ungetc)(int);
extern int (*receive_feof)(void);
extern int (*receive_ferror)(void);
extern BOOL (*receive_smtp_buffered)(void);


/* For clearing, saving, restoring address expansion variables. We have to have
the size of this vector set explicitly, because it is referenced from more than
one module. */

extern uschar **address_expansions[18];

/* General global variables */

extern BOOL accept_8bitmime; /* Allow *BITMIME incoming */
extern header_line *acl_added_headers; /* Headers added by an ACL */
extern tree_node *acl_anchor; /* Tree of named ACLs */
extern uschar *acl_not_smtp; /* ACL run for non-SMTP messages */



extern uschar *acl_not_smtp_start; /* ACL run at the beginning of a non-SMTP session */
extern uschar *acl_smtp_auth; /* ACL run for AUTH */
extern uschar *acl_smtp_connect; /* ACL run on SMTP connection */
extern uschar *acl_smtp_data; /* ACL run after DATA received */

extern uschar *acl_smtp_dkim; /* ACL run for DKIM signatures / domains */

extern uschar *acl_smtp_etrn; /* ACL run for ETRN */
extern uschar *acl_smtp_expn; /* ACL run for EXPN */
extern uschar *acl_smtp_helo; /* ACL run for HELO/EHLO */
extern uschar *acl_smtp_mail; /* ACL run for MAIL */
extern uschar *acl_smtp_mailauth; /* ACL run for MAIL AUTH */



extern uschar *acl_smtp_notquit; /* ACL run for disconnects */
extern uschar *acl_smtp_predata; /* ACL run for DATA command */
extern uschar *acl_smtp_quit; /* ACL run for QUIT */
extern uschar *acl_smtp_rcpt; /* ACL run for RCPT */
extern uschar *acl_smtp_starttls; /* ACL run for STARTTLS */
extern uschar *acl_smtp_vrfy; /* ACL run for VRFY */
extern BOOL acl_temp_details; /* TRUE to give details for 4xx error */
extern tree_node *acl_var_c; /* ACL connection variables */
extern tree_node *acl_var_m; /* ACL messsage variables */
extern uschar *acl_verify_message; /* User message for verify failure */
extern string_item *acl_warn_logged; /* Logged lines */
extern uschar *acl_wherecodes[]; /* Response codes for ACL fails */
extern uschar *acl_wherenames[]; /* Names for messages */
extern BOOL active_local_from_check;/* For adding Sender: (switchable) */
extern BOOL active_local_sender_retain; /* For keeping Sender: (switchable) */
extern address_item *addr_duplicate; /* Duplicate address list */
extern address_item address_defaults; /* Default data for address item */
extern uschar *address_file; /* Name of file when delivering to one */
extern uschar *address_pipe; /* Pipe command when delivering to one */
extern BOOL address_test_mode; /* True for -bt */
extern tree_node *addresslist_anchor; /* Tree of defined address lists */
extern int addresslist_count; /* Number defined */
extern gid_t *admin_groups; /* List of admin groups */
extern BOOL admin_user; /* True if caller can do admin */
extern BOOL allow_auth_unadvertised;/* As it says */
extern BOOL allow_domain_literals; /* As it says */
extern BOOL allow_mx_to_ip; /* Allow MX records to -> ip address */
extern BOOL allow_unqualified_recipient; /* As it says */
extern BOOL allow_unqualified_sender; /* Ditto */
extern BOOL allow_utf8_domains; /* For experimenting */
extern uschar *authenticated_id; /* ID that was authenticated */
extern uschar *authenticated_sender; /* From AUTH on MAIL */
extern BOOL authentication_failed; /* TRUE if AUTH was tried and failed */
extern uschar *auth_advertise_hosts; /* Only advertise to these */
extern auth_info auths_available[]; /* Vector of available auth mechanisms */
extern auth_instance *auths; /* Chain of instantiated auths */
extern auth_instance auth_defaults; /* Default values */
extern uschar *auth_defer_msg; /* Error message for log */
extern uschar *auth_defer_user_msg; /* Error message for user */
extern uschar *auth_vars[]; /* $authn variables */
extern int auto_thaw; /* Auto-thaw interval */





extern BOOL background_daemon; /* Set FALSE to keep in foreground */
extern uschar *base62_chars; /* Table of base-62 characters */
extern uschar *bi_command; /* Command for -bi option */
extern uschar *big_buffer; /* Used for various temp things */
extern int big_buffer_size; /* Current size (can expand) */
# 212 "src/globals.h"
extern uschar *bounce_message_file; /* Template file */
extern uschar *bounce_message_text; /* One-liner */
extern uschar *bounce_recipient; /* When writing an errmsg */
extern BOOL bounce_return_body; /* Include body in returned message */
extern BOOL bounce_return_message; /* Include message in bounce */
extern int bounce_return_size_limit; /* Max amount to return */
extern uschar *bounce_sender_authentication; /* AUTH address for bounces */
extern int bsmtp_transaction_linecount; /* Start of last transaction */

extern int callout_cache_domain_positive_expire; /* Time for positive domain callout cache records to expire */
extern int callout_cache_domain_negative_expire; /* Time for negative domain callout cache records to expire */
extern int callout_cache_positive_expire; /* Time for positive callout cache records to expire */
extern int callout_cache_negative_expire; /* Time for negative callout cache records to expire */
extern uschar *callout_random_local_part; /* Local part to be used to check if server called will accept any local part */
extern uschar *check_dns_names_pattern;/* Regex for syntax check */
extern int check_log_inodes; /* Minimum for message acceptance */
extern int check_log_space; /* Minimum for message acceptance */
extern BOOL check_rfc2047_length; /* Check RFC 2047 encoded string length */
extern int check_spool_inodes; /* Minimum for message acceptance */
extern int check_spool_space; /* Minimum for message acceptance */
extern int clmacro_count; /* Number of command line macros */
extern uschar *clmacros[]; /* Copy of them, for re-exec */
extern int connection_max_messages;/* Max down one SMTP connection */
extern BOOL config_changed; /* True if -C used */
extern FILE *config_file; /* Configuration file */
extern uschar *config_filename; /* Configuration file name */



extern int config_lineno; /* Line number */
extern uschar *config_main_filelist; /* List of possible config files */
extern uschar *config_main_filename; /* File name actually used */



extern uschar *continue_hostname; /* Host for continued delivery */
extern uschar *continue_host_address; /* IP address for ditto */
extern BOOL continue_more; /* Flag more addresses waiting */
extern int continue_sequence; /* Sequence num for continued delivery */
extern uschar *continue_transport; /* Transport for continued delivery */

extern uschar *csa_status; /* Client SMTP Authorization result */

extern BOOL daemon_listen; /* True if listening required */
extern uschar *daemon_smtp_port; /* Can be a list of ports */
extern int daemon_startup_retries; /* Number of times to retry */
extern int daemon_startup_sleep; /* Sleep between retries */
# 268 "src/globals.h"
extern BOOL debug_daemon; /* Debug the daemon process only */
extern int debug_fd; /* The fd for debug_file */
extern FILE *debug_file; /* Where to write debugging info */
extern bit_table debug_options[]; /* Table of debug options */
extern int debug_options_count; /* Size of table */
extern int delay_warning[]; /* Times between warnings */
extern uschar *delay_warning_condition; /* Condition string for warnings */
extern BOOL delivery_date_remove; /* Remove delivery-date headers */

extern uschar *deliver_address_data; /* Arbitrary data for an address */
extern int deliver_datafile; /* FD for data part of message */
extern uschar *deliver_domain; /* The local domain for delivery */
extern uschar *deliver_domain_data; /* From domain lookup */
extern uschar *deliver_domain_orig; /* The original local domain for delivery */
extern uschar *deliver_domain_parent; /* The parent domain for delivery */
extern BOOL deliver_drop_privilege; /* TRUE for unprivileged delivery */
extern BOOL deliver_firsttime; /* True for first delivery attempt */
extern BOOL deliver_force; /* TRUE if delivery was forced */
extern BOOL deliver_freeze; /* TRUE if delivery is frozen */
extern int deliver_frozen_at; /* Time of freezing */
extern uschar *deliver_home; /* Home directory for pipes */
extern uschar *deliver_host; /* (First) host for routed local deliveries */
                                       /* Remote host for filter */
extern uschar *deliver_host_address; /* Address for remote delivery filter */
extern uschar *deliver_in_buffer; /* Buffer for copying file */
extern ino_t deliver_inode; /* Inode for appendfile */
extern uschar *deliver_localpart; /* The local part for delivery */
extern uschar *deliver_localpart_data; /* From local part lookup */
extern uschar *deliver_localpart_orig; /* The original local part for delivery */
extern uschar *deliver_localpart_parent; /* The parent local part for delivery */
extern uschar *deliver_localpart_prefix; /* The stripped prefix, if any */
extern uschar *deliver_localpart_suffix; /* The stripped suffix, if any */
extern BOOL deliver_force_thaw; /* TRUE to force thaw in queue run */
extern BOOL deliver_manual_thaw; /* TRUE if manually thawed */
extern uschar *deliver_out_buffer; /* Buffer for copying file */
extern int deliver_queue_load_max; /* Different value for queue running */
extern address_item *deliver_recipients; /* Current set of addresses */
extern uschar *deliver_selectstring; /* For selecting by recipient */
extern BOOL deliver_selectstring_regex; /* String is regex */
extern uschar *deliver_selectstring_sender; /* For selecting by sender */
extern BOOL deliver_selectstring_sender_regex; /* String is regex */





extern BOOL disable_callout_flush; /* Don't flush before callouts */
extern BOOL disable_delay_flush; /* Don't flush before "delay" in ACL */



extern BOOL disable_ipv6; /* Don't do any IPv6 things */
extern BOOL disable_logging; /* Disables log writing when TRUE */


extern uschar *dkim_cur_signer; /* Expansion variable, holds the current "signer" domain or identity during a acl_smtp_dkim run */
extern uschar *dkim_signers; /* Expansion variable, holds colon-separated list of domains and identities that have signed a message */
extern uschar *dkim_signing_domain; /* Expansion variable, domain used for signing a message. */
extern uschar *dkim_signing_selector; /* Expansion variable, selector used for signing a message. */
extern uschar *dkim_verify_signers; /* Colon-separated list of domains for each of which we call the DKIM ACL */
extern BOOL dkim_collect_input; /* Runtime flag that tracks wether SMTP input is fed to DKIM validation */
extern BOOL dkim_disable_verify; /* Set via ACL control statement. When set, DKIM verification is disabled for the current message */


extern uschar *dns_again_means_nonexist; /* Domains that are badly set up */
extern int dns_csa_search_limit; /* How deep to search for CSA SRV records */
extern BOOL dns_csa_use_reverse; /* Check CSA in reverse DNS? (non-standard) */
extern uschar *dns_ipv4_lookup; /* For these domains, don't look for AAAA (or A6) */
extern int dns_retrans; /* Retransmission time setting */
extern int dns_retry; /* Number of retries */
extern int dns_use_edns0; /* Coerce EDNS0 support on/off in resolver. */
extern uschar *dnslist_domain; /* DNS (black) list domain */
extern uschar *dnslist_matched; /* DNS (black) list matched key */
extern uschar *dnslist_text; /* DNS (black) list text message */
extern uschar *dnslist_value; /* DNS (black) list IP address */
extern tree_node *domainlist_anchor; /* Tree of defined domain lists */
extern int domainlist_count; /* Number defined */
extern BOOL dont_deliver; /* TRUE for -N option */
extern BOOL dot_ends; /* TRUE if "." ends non-SMTP input */

/* This option is now a no-opt, retained for compatibility */
extern BOOL drop_cr; /* For broken local MUAs */

extern uschar *dsn_from; /* From: string for DSNs */

extern BOOL enable_dollar_recipients; /* Make $recipients available */
extern int envelope_to_remove; /* Remove envelope_to_headers */
extern int errno_quota; /* Quota errno in this OS */
extern int error_handling; /* Error handling style */
extern uschar *errors_copy; /* For taking copies of errors */
extern uschar *errors_reply_to; /* Reply-to for error messages */
extern int errors_sender_rc; /* Return after message to sender*/
extern gid_t exim_gid; /* To be used with exim_uid */
extern BOOL exim_gid_set; /* TRUE if exim_gid set */
extern uschar *exim_path; /* Path to exec exim */
extern uid_t exim_uid; /* Non-root uid for exim */
extern BOOL exim_uid_set; /* TRUE if exim_uid set */
extern int expand_forbid; /* RDO flags for forbidding things */
extern int expand_nlength[]; /* Lengths of numbered strings */
extern int expand_nmax; /* Max numerical value */
extern uschar *expand_nstring[]; /* Numbered strings */
extern BOOL expand_string_forcedfail; /* TRUE if failure was "expected" */
extern BOOL extract_addresses_remove_arguments; /* Controls -t behaviour */
extern uschar *extra_local_interfaces; /* Local, non-listen interfaces */

extern int fake_response; /* Fake FAIL or DEFER response to data */
extern uschar *fake_response_text; /* User defined message for the above. Default is in globals.c. */
extern int filter_n[10]; /* filter variables */
extern BOOL filter_running; /* TRUE while running a filter */
extern int filter_sn[10]; /* variables set by system filter */
extern int filter_test; /* Filter test type */
extern uschar *filter_test_sfile; /* System filter test file */
extern uschar *filter_test_ufile; /* User filter test file */
extern uschar *filter_thisaddress; /* For address looping */
extern int finduser_retries; /* Retry count for getpwnam() */
extern uid_t fixed_never_users[]; /* Can't be overridden */



extern uschar *freeze_tell; /* Message on (some) freezings */
extern uschar *freeze_tell_config; /* The configured setting */
extern uschar *fudged_queue_times; /* For use in test harness */

extern uschar *gecos_name; /* To be expanded when pattern matches */
extern uschar *gecos_pattern; /* Pattern to match */
extern rewrite_rule *global_rewrite_rules; /* Chain of rewriting rules */

extern int header_insert_maxlen; /* Max for inserting headers */
extern int header_maxsize; /* Max total length for header */
extern int header_line_maxsize; /* Max for an individual line */
extern header_name header_names[]; /* Table of header names */
extern int header_names_size; /* Number of entries */
extern BOOL header_rewritten; /* TRUE if header changed by router */
extern uschar *helo_accept_junk_hosts; /* Allowed to use junk arg */
extern uschar *helo_allow_chars; /* Rogue chars to allow in HELO/EHLO */
extern uschar *helo_lookup_domains; /* If these given, lookup host name */
extern uschar *helo_try_verify_hosts; /* Soft check HELO argument for these */
extern BOOL helo_verified; /* True if HELO verified */
extern BOOL helo_verify_failed; /* True if attempt failed */
extern uschar *helo_verify_hosts; /* Hard check HELO argument for these */
extern const uschar *hex_digits; /* Used in several places */
extern uschar *hold_domains; /* Hold up deliveries to these */
extern BOOL host_find_failed_syntax;/* DNS syntax check failure */
extern BOOL host_checking_callout; /* TRUE if real callout wanted */
extern uschar *host_data; /* Obtained from lookup in ACL */
extern uschar *host_lookup; /* For which IP addresses are always looked up */
extern BOOL host_lookup_deferred; /* TRUE if lookup deferred */
extern BOOL host_lookup_failed; /* TRUE if lookup failed */
extern uschar *host_lookup_order; /* Order of host lookup types */
extern uschar *host_lookup_msg; /* Text for why it failed */
extern int host_number; /* For sharing spools */
extern uschar *host_number_string; /* For expanding */
extern uschar *host_reject_connection; /* Reject these hosts */
extern tree_node *hostlist_anchor; /* Tree of defined host lists */
extern int hostlist_count; /* Number defined */
extern uschar *hosts_connection_nolog; /* Limits the logging option */
extern uschar *hosts_treat_as_local; /* For routing */

extern int ignore_bounce_errors_after; /* Keep them for this time. */
extern BOOL ignore_fromline_local; /* Local SMTP ignore fromline */
extern uschar *ignore_fromline_hosts; /* Hosts permitted to send "From " */
extern BOOL inetd_wait_mode; /* Whether running in inetd wait mode */
extern int inetd_wait_timeout; /* Timeout for inetd wait mode */
extern BOOL is_inetd; /* True for inetd calls */
extern uschar *iterate_item; /* Item from iterate list */

extern int journal_fd; /* Fd for journal file */

extern int keep_malformed; /* Time to keep malformed messages */

extern uschar *eldap_dn; /* Where LDAP DNs are left */
extern int load_average; /* Most recently read load average */
extern BOOL local_error_message; /* True if handling one of these */
extern BOOL local_from_check; /* For adding Sender: (global value) */
extern uschar *local_from_prefix; /* Permitted prefixes */
extern uschar *local_from_suffix; /* Permitted suffixes */
extern uschar *local_interfaces; /* For forcing specific interfaces */
extern uschar *local_scan_data; /* Text returned by local_scan() */
extern optionlist local_scan_options[];/* Option list for local_scan() */
extern int local_scan_options_count; /* Size of the list */
extern int local_scan_timeout; /* Timeout for local_scan() */
extern BOOL local_sender_retain; /* Retain Sender: (with no From: check) */
extern gid_t local_user_gid; /* As it says; may be set in routers */
extern uid_t local_user_uid; /* As it says; may be set in routers */
extern tree_node *localpartlist_anchor;/* Tree of defined localpart lists */
extern int localpartlist_count; /* Number defined */
extern uschar *log_buffer; /* For constructing log entries */
extern unsigned int log_extra_selector;/* Bit map of logging options other than used by log_write() */
extern uschar *log_file_path; /* If unset, use default */
extern bit_table log_options[]; /* Table of options */
extern int log_options_count; /* Size of table */
extern int log_reject_target; /* Target log for ACL rejections */
extern uschar *log_selector_string; /* As supplied in the config */
extern FILE *log_stderr; /* Copy of stderr for log use, or NULL */
extern BOOL log_testing_mode; /* TRUE in various testing modes */
extern BOOL log_timezone; /* TRUE to include the timezone in log lines */
extern unsigned int log_write_selector;/* Bit map of logging options for log_write() */
extern uschar *login_sender_address; /* The actual sender address */
extern lookup_info **lookup_list; /* Array of pointers to available lookups */
extern int lookup_list_count; /* Number of entries in the list */
extern int lookup_open_max; /* Max lookup files to cache */
extern uschar *lookup_value; /* Value looked up from file */

extern macro_item *macros; /* Configuration macros */
extern uschar *mailstore_basename; /* For mailstore deliveries */



extern int max_received_linelength;/* What it says */
extern int max_username_length; /* For systems with broken getpwnam() */
extern int message_age; /* In seconds */
extern uschar *message_body; /* Start of message body for filter */
extern uschar *message_body_end; /* End of message body for filter */
extern BOOL message_body_newlines; /* FALSE => remove newlines */
extern int message_body_size; /* Sic */
extern int message_body_visible; /* Amount visible in message_body */
extern int message_ended; /* State of message reading and how ended */
extern uschar *message_headers; /* When built */
extern uschar message_id_option[]; /* -E<message-id> for use as option */
extern uschar *message_id_external; /* External form of following */
extern uschar *message_id_domain; /* Expanded to form domain-part of message_id */
extern uschar *message_id_text; /* Expanded to form message_id */
extern struct timeval message_id_tv; /* Time used to create last message_id */
extern int message_linecount; /* As it says */
extern BOOL message_logs; /* TRUE to write message logs */
extern int message_size; /* Size of message */
extern uschar *message_size_limit; /* As it says */
extern uschar message_subdir[]; /* Subdirectory for messages */
extern uschar *message_reference; /* Reference for error messages */

/* MIME ACL expandables */
# 518 "src/globals.h"
extern BOOL mua_wrapper; /* TRUE when Exim is wrapping an MUA */

extern uid_t *never_users; /* List of uids never to be used */



extern BOOL no_multiline_responses; /* For broken clients */

extern optionlist optionlist_auths[]; /* These option lists are made */
extern int optionlist_auths_size; /* global so that readconf can */
extern optionlist optionlist_routers[]; /* see them for printing out   */
extern int optionlist_routers_size; /* the options.                */
extern optionlist optionlist_transports[];
extern int optionlist_transports_size;

extern uid_t original_euid; /* Original effective uid */
extern gid_t originator_gid; /* Gid of whoever wrote spool file */
extern uschar *originator_login; /* Login of same */
extern uschar *originator_name; /* Full name of same */
extern uid_t originator_uid; /* Uid of ditto */
extern uschar *override_local_interfaces; /* Value of -oX argument */
extern uschar *override_pid_file_path; /* Value of -oP argument */

extern BOOL parse_allow_group; /* Allow group syntax */
extern BOOL parse_found_group; /* In the middle of a group */
extern uschar *percent_hack_domains; /* Local domains for which '% operates */
extern uschar *pid_file_path; /* For writing daemon pids */
extern uschar *pipelining_advertise_hosts; /* As it says */
extern BOOL pipelining_enable; /* As it says */
extern BOOL preserve_message_logs; /* Save msglog files */
extern uschar *primary_hostname; /* Primary name of this computer */
extern BOOL print_topbitchars; /* Topbit chars are printing chars */
extern uschar process_info[]; /* For SIGUSR1 output */
extern int process_info_len;
extern uschar *process_log_path; /* Alternate path */
extern BOOL prod_requires_admin; /* TRUE if prodding requires admin */
extern uschar *prvscheck_address; /* Set during prvscheck expansion item */
extern uschar *prvscheck_keynum; /* Set during prvscheck expansion item */
extern uschar *prvscheck_result; /* Set during prvscheck expansion item */

extern uschar *qualify_domain_recipient; /* Domain to qualify recipients with */
extern uschar *qualify_domain_sender; /* Domain to qualify senders with */
extern BOOL queue_2stage; /* Run queue in 2-stage manner */
extern uschar *queue_domains; /* Queue these domains */
extern BOOL queue_list_requires_admin; /* TRUE if -bp requires admin */
extern BOOL queue_run_first_delivery; /* If TRUE, first deliveries only */
extern BOOL queue_run_force; /* TRUE to force during queue run */
extern BOOL queue_run_local; /* Local deliveries only in queue run */
extern BOOL queue_running; /* TRUE for queue running process and */
                                       /*   immediate children */
extern pid_t queue_run_pid; /* PID of the queue running process or 0 */
extern int queue_run_pipe; /* Pipe for synchronizing */
extern int queue_interval; /* Queue running interval */
extern BOOL queue_only; /* TRUE to disable immediate delivery */
extern int queue_only_load; /* Max load before auto-queue */
extern BOOL queue_only_load_latch; /* Latch queue_only_load TRUE */
extern uschar *queue_only_file; /* Queue if file exists/not-exists */
extern BOOL queue_only_override; /* Allow override from command line */
extern BOOL queue_only_policy; /* ACL or local_scan wants queue_only */
extern BOOL queue_run_in_order; /* As opposed to random */
extern int queue_run_max; /* Max queue runners */
extern BOOL queue_smtp; /* Disable all immediate STMP (-odqs)*/
extern uschar *queue_smtp_domains; /* Ditto, for these domains */

extern unsigned int random_seed; /* Seed for random numbers */
extern tree_node *ratelimiters_cmd; /* Results of command ratelimit checks */
extern tree_node *ratelimiters_conn; /* Results of connection ratelimit checks */
extern tree_node *ratelimiters_mail; /* Results of per-mail ratelimit checks */
extern uschar *raw_active_hostname; /* Pre-expansion */
extern uschar *raw_sender; /* Before rewriting */
extern uschar **raw_recipients; /* Before rewriting */
extern int raw_recipients_count;
extern int rcpt_count; /* Count of RCPT commands in a message */
extern int rcpt_fail_count; /* Those that got 5xx */
extern int rcpt_defer_count; /* Those that got 4xx */
extern gid_t real_gid; /* Real gid */
extern uid_t real_uid; /* Real user running program */
extern BOOL really_exim; /* FALSE in utilities */
extern BOOL receive_call_bombout; /* Flag for crashing log */
extern int receive_linecount; /* Mainly for BSMTP errors */
extern int receive_messagecount; /* Mainly for BSMTP errors */
extern int receive_timeout; /* For non-SMTP acceptance */
extern int received_count; /* Count of Received: headers */
extern uschar *received_for; /* For "for" field */
extern uschar *received_header_text; /* Definition of Received: header */
extern int received_headers_max; /* Max count of Received: headers */
extern int received_time; /* Time the message was received */
extern uschar *recipient_data; /* lookup data for recipients */
extern uschar *recipient_unqualified_hosts; /* Permitted unqualified recipients */
extern uschar *recipient_verify_failure; /* What went wrong */
extern BOOL recipients_discarded; /* By an ACL */
extern int recipients_list_max; /* Maximum number fitting in list */
extern int recipients_max; /* Max permitted */
extern int recipients_max_reject; /* If TRUE, reject whole message */
extern const pcre *regex_AUTH; /* For recognizing AUTH settings */
extern const pcre *regex_check_dns_names; /* For DNS name checking */
extern const pcre *regex_From; /* For recognizing "From_" lines */
extern const pcre *regex_IGNOREQUOTA; /* For recognizing IGNOREQUOTA (LMTP) */
extern const pcre *regex_PIPELINING; /* For recognizing PIPELINING */
extern const pcre *regex_SIZE; /* For recognizing SIZE settings */
extern const pcre *regex_smtp_code; /* For recognizing SMTP codes */
extern const pcre *regex_ismsgid; /* Compiled r.e. for message it */






extern int remote_delivery_count; /* Number of remote addresses */
extern int remote_max_parallel; /* Maximum parallel delivery */
extern uschar *remote_sort_domains; /* Remote domain sorting order */
extern retry_config *retries; /* Chain of retry config information */
extern int retry_data_expire; /* When to expire retry data */
extern int retry_interval_max; /* Absolute maximum */
extern int retry_maximum_timeout; /* The maximum timeout */
extern uschar *return_path; /* Return path for a message */
extern BOOL return_path_remove; /* Remove return-path headers */
extern int rewrite_existflags; /* Indicate which headers have rewrites */
extern uschar *rfc1413_hosts; /* RFC hosts */
extern int rfc1413_query_timeout; /* Timeout on RFC 1413 calls */
/* extern BOOL    rfc821_domains;  */ /* If set, syntax is 821, not 822 => being abolished */
extern uid_t root_gid; /* The gid for root */
extern uid_t root_uid; /* The uid for root */
extern router_info routers_available[];/* Vector of available routers */
extern router_instance *routers; /* Chain of instantiated routers */
extern router_instance router_defaults;/* Default values */
extern BOOL running_in_test_harness; /*TRUE when running_status is patched */
extern ip_address_item *running_interfaces; /* Host's running interfaces */
extern uschar *running_status; /* Flag string for testing */
extern int runrc; /* rc from ${run} */

extern uschar *search_error_message; /* Details of lookup problem */
extern BOOL search_find_defer; /* Set TRUE if lookup deferred */
extern uschar *self_hostname; /* Self host after routing->directors */
extern unsigned int sender_address_cache[(16 * 2)/32]; /* Cache bits for sender */
extern uschar *sender_address_data; /* address_data from sender verify */
extern BOOL sender_address_forced; /* Set by -f */
extern uschar *sender_address_unrewritten; /* Set if rewritten by verify */
extern uschar *sender_data; /* lookup result for senders */
extern unsigned int sender_domain_cache[(16 * 2)/32]; /* Cache bits for sender domain */
extern uschar *sender_fullhost; /* Sender host name + address */
extern uschar *sender_helo_name; /* Host name from HELO/EHLO */
extern uschar **sender_host_aliases; /* Points to list of alias names */
extern unsigned int sender_host_cache[(16 * 2)/32]; /* Cache bits for incoming host */
extern BOOL sender_host_notsocket; /* Set for -bs and -bS */
extern BOOL sender_host_unknown; /* TRUE for -bs and -bS except inetd */
extern uschar *sender_ident; /* Sender identity via RFC 1413 */
extern BOOL sender_local; /* TRUE for local senders */
extern BOOL sender_name_forced; /* Set by -F */
extern uschar *sender_rate; /* Sender rate computed by ACL */
extern uschar *sender_rate_limit; /* Configured rate limit */
extern uschar *sender_rate_period; /* Configured smoothing period */
extern uschar *sender_rcvhost; /* Host data for Received: */
extern BOOL sender_set_untrusted; /* Sender set by untrusted caller */
extern uschar *sender_unqualified_hosts; /* Permitted unqualified senders */
extern uschar *sender_verify_failure; /* What went wrong */
extern address_item *sender_verified_list; /* Saved chain of sender verifies */
extern address_item *sender_verified_failed; /* The one that caused denial */
extern uschar *sending_ip_address; /* Address of outgoing (SMTP) interface */
extern int sending_port; /* Port of outgoing interface */
extern SIGNAL_BOOL sigalrm_seen; /* Flag for sigalrm_handler */
extern uschar **sighup_argv; /* Args for re-execing after SIGHUP */
extern int smtp_accept_count; /* Count of connections */
extern BOOL smtp_accept_keepalive; /* Set keepalive on incoming */
extern int smtp_accept_max; /* Max SMTP connections */
extern int smtp_accept_max_nonmail;/* Max non-mail commands in one con */
extern uschar *smtp_accept_max_nonmail_hosts; /* Limit non-mail cmds from these hosts */
extern int smtp_accept_max_per_connection; /* Max msgs per connection */
extern uschar *smtp_accept_max_per_host; /* Max SMTP cons from one IP addr */
extern int smtp_accept_queue; /* Queue after so many connections */
extern int smtp_accept_queue_per_connection; /* Queue after so many msgs */
extern int smtp_accept_reserve; /* Reserve these SMTP connections */
extern uschar *smtp_active_hostname; /* Hostname for this message */
extern BOOL smtp_authenticated; /* Sending client has authenticated */
extern uschar *smtp_banner; /* Banner string (to be expanded) */
extern BOOL smtp_check_spool_space; /* TRUE to check SMTP SIZE value */
extern int smtp_ch_index; /* Index in smtp_connection_had */
extern uschar *smtp_cmd_argument; /* For all SMTP commands */
extern uschar *smtp_cmd_buffer; /* SMTP command buffer */
extern time_t smtp_connection_start; /* Start time of SMTP connection */
extern uschar smtp_connection_had[]; /* Recent SMTP commands */
extern int smtp_connect_backlog; /* Max backlog permitted */
extern double smtp_delay_mail; /* Current MAIL delay */
extern double smtp_delay_rcpt; /* Current RCPT delay */
extern BOOL smtp_enforce_sync; /* Enforce sync rules */
extern uschar *smtp_etrn_command; /* Command to run */
extern BOOL smtp_etrn_serialize; /* Only one at once */
extern FILE *smtp_in; /* Incoming SMTP input file */
extern int smtp_load_reserve; /* Only from reserved if load > this */
extern int smtp_mailcmd_count; /* Count of MAIL commands */
extern int smtp_max_synprot_errors;/* Max syntax/protocol errors */
extern int smtp_max_unknown_commands; /* As it says */
extern uschar *smtp_notquit_reason; /* Global for disconnect reason */
extern FILE *smtp_out; /* Incoming SMTP output file */
extern uschar *smtp_ratelimit_hosts; /* Rate limit these hosts */
extern uschar *smtp_ratelimit_mail; /* Parameters for MAIL limiting */
extern uschar *smtp_ratelimit_rcpt; /* Parameters for RCPT limiting */
extern uschar *smtp_read_error; /* Message for SMTP input error */
extern int smtp_receive_timeout; /* Applies to each received line */
extern uschar *smtp_reserve_hosts; /* Hosts for reserved slots */
extern BOOL smtp_return_error_details; /* TRUE to return full info */
extern int smtp_rlm_base; /* Base interval for MAIL rate limit */
extern double smtp_rlm_factor; /* Factor for MAIL rate limit */
extern int smtp_rlm_limit; /* Max delay */
extern int smtp_rlm_threshold; /* Threshold for RCPT rate limit */
extern int smtp_rlr_base; /* Base interval for RCPT rate limit */
extern double smtp_rlr_factor; /* Factor for RCPT rate limit */
extern int smtp_rlr_limit; /* Max delay */
extern int smtp_rlr_threshold; /* Threshold for RCPT rate limit */
extern BOOL smtp_use_pipelining; /* Global for passed connections */
extern BOOL smtp_use_size; /* Global for passed connections */
# 744 "src/globals.h"
extern BOOL split_spool_directory; /* TRUE to use multiple subdirs */
extern uschar *spool_directory; /* Name of spool directory */
# 761 "src/globals.h"
extern BOOL strict_acl_vars; /* ACL variables have to be set before being used */
extern int string_datestamp_offset;/* After insertion by string_format */
extern int string_datestamp_length;/* After insertion by string_format */
extern int string_datestamp_type; /* After insertion by string_format */
extern BOOL strip_excess_angle_brackets; /* Surrounding route-addrs */
extern BOOL strip_trailing_dot; /* Remove dots at ends of domains */
extern uschar *submission_domain; /* Domain for submission mode */
extern BOOL submission_mode; /* Can be forced from ACL */
extern uschar *submission_name; /* User name set from ACL */
extern BOOL suppress_local_fixups; /* Can be forced from ACL */
extern BOOL synchronous_delivery; /* TRUE if -odi is set */
extern BOOL syslog_duplication; /* FALSE => no duplicate logging */
extern int syslog_facility; /* As defined by Syslog.h */
extern uschar *syslog_processname; /* 'ident' param to openlog() */
extern BOOL syslog_timestamp; /* TRUE if time on syslogs */
extern uschar *system_filter; /* Name of system filter file */

extern uschar *system_filter_directory_transport; /* Transports for the */
extern uschar *system_filter_file_transport; /* system filter */
extern uschar *system_filter_pipe_transport;
extern uschar *system_filter_reply_transport;

extern gid_t system_filter_gid; /* Gid for running system filter */
extern BOOL system_filter_gid_set; /* TRUE if gid set */
extern uid_t system_filter_uid; /* Uid for running system filter */
extern BOOL system_filter_uid_set; /* TRUE if uid set */
extern BOOL system_filtering; /* TRUE when running system filter */

extern BOOL tcp_nodelay; /* Controls TCP_NODELAY on daemon */



extern int test_harness_load_avg; /* For use when testing */
extern int thismessage_size_limit; /* Limit for this message */
extern int timeout_frozen_after; /* Max time to keep frozen messages */
extern BOOL timestamps_utc; /* Use UTC for all times */
extern int transport_count; /* Count of bytes transported */
extern int transport_newlines; /* Accurate count of number of newline chars transported */
extern uschar **transport_filter_argv; /* For on-the-fly filtering */
extern int transport_filter_timeout; /* Timeout for same */
extern BOOL transport_filter_timed_out; /* True if it did */

extern transport_info transports_available[]; /* Vector of available transports */
extern transport_instance *transports; /* Chain of instantiated transports */
extern transport_instance transport_defaults; /* Default values */

extern int transport_write_timeout;/* Set to time out individual writes */

extern tree_node *tree_dns_fails; /* Tree of DNS lookup failures */
extern tree_node *tree_duplicates; /* Tree of duplicate addresses */
extern tree_node *tree_nonrecipients; /* Tree of nonrecipient addresses */
extern tree_node *tree_unusable; /* Tree of unusable addresses */

extern BOOL trusted_caller; /* Caller is trusted */
extern BOOL trusted_config; /* Configuration file is trusted */
extern gid_t *trusted_groups; /* List of trusted groups */
extern uid_t *trusted_users; /* List of trusted users */
extern uschar *timezone_string; /* Required timezone setting */

extern uschar *unknown_login; /* To use when login id unknown */
extern uschar *unknown_username; /* Ditto */
extern uschar *untrusted_set_sender; /* Let untrusted users set these senders */
extern uschar *uucp_from_pattern; /* For recognizing "From " lines */
extern uschar *uucp_from_sender; /* For building the sender */

extern uschar *warn_message_file; /* Template for warning messages */
extern uschar *warnmsg_delay; /* String form of delay time */
extern uschar *warnmsg_recipients; /* Recipients of warning message */
extern BOOL write_rejectlog; /* Control of reject logging */

extern uschar *version_copyright; /* Copyright notice */
extern uschar *version_date; /* Date of compilation */
extern uschar *version_cnumber; /* Compile number */
extern uschar *version_string; /* Version string */

extern int warning_count; /* Delay warnings sent for this msg */

/* End of globals.h */
# 472 "src/exim.h" 2
# 1 "src/functions.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2012 */
/* See the file NOTICE for conditions of use and distribution. */


/* Prototypes for functions that appear in various modules. Gathered together
to avoid having a lot of tiddly little headers with only a couple of lines in
them. However, some functions that are used (or not used) by utility programs
are in in fact in separate headers. */
# 48 "src/functions.h"
/* Everything else... */

extern acl_block *acl_read(uschar *(*)(void), uschar **);
extern int acl_check(int, uschar *, uschar *, uschar **, uschar **);
extern tree_node *acl_var_create(uschar *);
extern void acl_var_write(uschar *, uschar *, void *);
extern uschar *auth_b64encode(uschar *, int);
extern int auth_b64decode(uschar *, uschar **);
extern int auth_call_pam(uschar *, uschar **);
extern int auth_call_pwcheck(uschar *, uschar **);
extern int auth_call_radius(uschar *, uschar **);
extern int auth_call_saslauthd(uschar *, uschar *, uschar *, uschar *,
                 uschar **);
extern int auth_check_serv_cond(auth_instance *);
extern int auth_check_some_cond(auth_instance *, uschar *, uschar *, int);

extern int auth_get_data(uschar **, uschar *, int);
extern int auth_get_no64_data(uschar **, uschar *);
extern uschar *auth_xtextencode(uschar *, int);
extern int auth_xtextdecode(uschar *, uschar **);

extern int check_host(void *, uschar *, uschar **, uschar **);
extern uschar **child_exec_exim(int, BOOL, int *, BOOL, int, ...);
extern pid_t child_open_uid(uschar **, uschar **, int, uid_t *, gid_t *,
                 int *, int *, uschar *, BOOL);

extern void daemon_go(void);





extern void debug_logging_activate(uschar *, uschar *);
extern void debug_print_argv(uschar **);
extern void debug_print_ids(uschar *);
extern void debug_print_string(uschar *);
extern void debug_print_tree(tree_node *);
extern void debug_vprintf(const char *, va_list);
extern void decode_bits(unsigned int *, unsigned int *,
                  int, int, uschar *, bit_table *, int, uschar *, int);
extern address_item *deliver_make_addr(uschar *, BOOL);
extern int deliver_message(uschar *, BOOL, BOOL);
extern void deliver_msglog(const char *, ...) __attribute__((format(printf,1,2)));
extern void deliver_set_expansions(address_item *);
extern int deliver_split_address(address_item *);
extern void deliver_succeeded(address_item *);



extern BOOL directory_make(const uschar *, const uschar *, int, BOOL);

extern BOOL dkim_transport_write_message(address_item *, int, int,
                   int, uschar *, uschar *, uschar *, uschar *, rewrite_rule *,
                   int, uschar *, uschar *, uschar *, uschar *, uschar *, uschar *);

extern dns_address *dns_address_from_rr(dns_answer *, dns_record *);
extern void dns_build_reverse(uschar *, uschar *);
extern void dns_init(BOOL, BOOL);
extern int dns_basic_lookup(dns_answer *, uschar *, int);
extern int dns_lookup(dns_answer *, uschar *, int, uschar **);
extern int dns_special_lookup(dns_answer *, uschar *, int, uschar **);
extern dns_record *dns_next_rr(dns_answer *, dns_scan *, int);
extern uschar *dns_text_type(int);

extern void enq_end(uschar *);
extern BOOL enq_start(uschar *);
extern void exim_exit(int);
extern void exim_nullstd(void);
extern void exim_setugid(uid_t, gid_t, BOOL, uschar *);
extern int exim_tvcmp(struct timeval *, struct timeval *);
extern void exim_wait_tick(struct timeval *, int);
extern BOOL expand_check_condition(uschar *, uschar *, uschar *);
extern uschar *expand_string(uschar *);
extern uschar *expand_string_copy(uschar *);
extern int64_t expand_string_integer(uschar *, BOOL);

extern int filter_interpret(uschar *, int, address_item **, uschar **);
extern BOOL filter_personal(string_item *, BOOL);
extern BOOL filter_runtest(int, uschar *, BOOL, BOOL);
extern BOOL filter_system_interpret(address_item **, uschar **);

extern void header_add(int, const char *, ...);
extern int header_checkname(header_line *, BOOL);
extern BOOL header_match(uschar *, BOOL, BOOL, string_item *, int, ...);
extern int host_address_extract_port(uschar *);
extern uschar *host_and_ident(BOOL);
extern int host_aton(uschar *, int *);
extern void host_build_hostlist(host_item **, uschar *, BOOL);
extern ip_address_item *host_build_ifacelist(uschar *, uschar *);
extern void host_build_log_info(void);
extern void host_build_sender_fullhost(void);
extern BOOL host_find_byname(host_item *, uschar *, int, uschar **, BOOL);
extern int host_find_bydns(host_item *, uschar *, int, uschar *, uschar *,
                 uschar *,uschar **, BOOL *);
extern ip_address_item *host_find_interfaces(void);
extern BOOL host_is_in_net(uschar *, uschar *, int);
extern BOOL host_is_tls_on_connect_port(int);
extern int host_item_get_port(host_item *);
extern void host_mask(int, int *, int);
extern int host_name_lookup(void);
extern int host_nmtoa(int, int *, int, uschar *, int);
extern uschar *host_ntoa(int, const void *, uschar *, int *);
extern int host_scan_for_local_hosts(host_item *, host_item **, BOOL *);

extern void invert_address(uschar *, uschar *);
extern int ip_bind(int, int, uschar *, int);
extern int ip_connect(int, int, uschar *, int, int);
extern void ip_keepalive(int, uschar *, BOOL);
extern int ip_recv(int, uschar *, int, int);
extern int ip_socket(int, int);

extern uschar *local_part_quote(uschar *);
extern int log_create_as_exim(uschar *);
extern void log_close_all(void);





extern int match_address_list(uschar *, BOOL, BOOL, uschar **,
                 unsigned int *, int, int, uschar **);
extern int match_check_list(uschar **, int, tree_node **, unsigned int **,
                 int(*)(void *, uschar *, uschar **, uschar **), void *, int,
                 uschar *, uschar **);
extern int match_isinlist(uschar *, uschar **, int, tree_node **,
                 unsigned int *, int, BOOL, uschar **);
extern int match_check_string(uschar *, uschar *, int, BOOL, BOOL, BOOL,
                 uschar **);
extern void md5_end(md5 *, const uschar *, int, uschar *);
extern void md5_mid(md5 *, const uschar *);
extern void md5_start(md5 *);
extern void millisleep(int);







extern uschar *moan_check_errorcopy(uschar *);
extern BOOL moan_skipped_syntax_errors(uschar *, error_block *, uschar *,
                 BOOL, uschar *);
extern void moan_smtp_batch(uschar *, const char *, ...) __attribute__((format(printf,2,3)));
extern void moan_tell_someone(uschar *, address_item *,
                 const uschar *, const char *, ...) __attribute__((format(printf,4,5)));
extern BOOL moan_to_sender(int, error_block *, header_line *, FILE *, BOOL);
extern void moan_write_from(FILE *);
extern FILE *modefopen(const uschar *, const char *, mode_t);

extern uschar *parse_extract_address(uschar *, uschar **, int *, int *, int *,
                 BOOL);
extern int parse_forward_list(uschar *, int, address_item **, uschar **,
                 uschar *, uschar *, error_block **);
extern uschar *parse_find_address_end(uschar *, BOOL);
extern uschar *parse_find_at(uschar *);
extern uschar *parse_fix_phrase(uschar *, int, uschar *, int);
extern uschar *parse_message_id(uschar *, uschar **, uschar **);
extern uschar *parse_quote_2047(uschar *, int, uschar *, uschar *, int, BOOL);
extern uschar *parse_date_time(uschar *str, time_t *t);
extern int vaguely_random_number(int);




extern BOOL queue_action(uschar *, int, uschar **, int, int);
extern void queue_check_only(void);
extern void queue_list(int, uschar **, int);
extern void queue_count(void);
extern void queue_run(uschar *, uschar *, BOOL);

extern int random_number(int);



extern int rda_interpret(redirect_block *, int, uschar *, uschar *,
                 uschar *, uschar *, uschar *, ugid_block *, address_item **,
                 uschar **, error_block **, int *, uschar *);
extern int rda_is_filter(const uschar *);
extern BOOL readconf_depends(driver_instance *, uschar *);
extern void readconf_driver_init(uschar *, driver_instance **,
                 driver_info *, int, void *, int, optionlist *, int);
extern uschar *readconf_find_option(void *);
extern void readconf_main(void);
extern void readconf_print(uschar *, uschar *);
extern uschar *readconf_printtime(int);
extern uschar *readconf_readname(uschar *, int, uschar *);
extern int readconf_readtime(uschar *, int, BOOL);
extern void readconf_rest(BOOL);
extern uschar *readconf_retry_error(uschar *, uschar *, int *, int *);
extern void read_message_body(BOOL);
extern void receive_bomb_out(uschar *, uschar *);
extern BOOL receive_check_fs(int);
extern BOOL receive_check_set_sender(uschar *);
extern BOOL receive_msg(BOOL);
extern int receive_statvfs(BOOL, int *);
extern void receive_swallow_smtp(void);



extern BOOL regex_match_and_setup(const pcre *, uschar *, int, int);
extern const pcre *regex_must_compile(uschar *, BOOL, BOOL);
extern void retry_add_item(address_item *, uschar *, int);
extern BOOL retry_check_address(uschar *, host_item *, uschar *, BOOL,
                 uschar **, uschar **);
extern retry_config *retry_find_config(uschar *, uschar *, int, int);
extern void retry_update(address_item **, address_item **, address_item **);
extern uschar *rewrite_address(uschar *, BOOL, BOOL, rewrite_rule *, int);
extern uschar *rewrite_address_qualify(uschar *, BOOL);
extern header_line *rewrite_header(header_line *, uschar *, uschar *,
               rewrite_rule *, int, BOOL);
extern uschar *rewrite_one(uschar *, int, BOOL *, BOOL, uschar *,
                 rewrite_rule *);
extern void rewrite_test(uschar *);
extern uschar *rfc2047_decode2(uschar *, BOOL, uschar *, int, int *, int *,
                 uschar **);
extern int route_address(address_item *, address_item **, address_item **,
                 address_item **, address_item **, int);
extern int route_check_prefix(uschar *, uschar *);
extern int route_check_suffix(uschar *, uschar *);
extern BOOL route_findgroup(uschar *, gid_t *);
extern BOOL route_finduser(uschar *, struct passwd **, uid_t *);
extern BOOL route_find_expanded_group(uschar *, uschar *, uschar *, gid_t *,
                 uschar **);
extern BOOL route_find_expanded_user(uschar *, uschar *, uschar *,
                 struct passwd **, uid_t *, uschar **);
extern void route_init(void);
extern void route_tidyup(void);

extern uschar *search_find(void *, uschar *, uschar *, int, uschar *, int,
                 int, int *);
extern int search_findtype(uschar *, int);
extern int search_findtype_partial(uschar *, int *, uschar **, int *,
                 int *);
extern void *search_open(uschar *, int, int, uid_t *, gid_t *);
extern void search_tidyup(void);
extern void set_process_info(const char *, ...) __attribute__((format(printf,1,2)));
extern void sha1_end(sha1 *, const uschar *, int, uschar *);
extern void sha1_mid(sha1 *, const uschar *);
extern void sha1_start(sha1 *);
extern int sieve_interpret(uschar *, int, uschar *, uschar *, uschar *,
                 uschar *, address_item **, uschar **);
extern void sigalrm_handler(int);
extern BOOL smtp_buffered(void);
extern void smtp_closedown(uschar *);
extern int smtp_connect(host_item *, int, int, uschar *, int, BOOL);
extern int smtp_feof(void);
extern int smtp_ferror(void);
extern uschar *smtp_get_connection_info(void);
extern BOOL smtp_get_interface(uschar *, int, address_item *, BOOL *,
                 uschar **, uschar *);
extern BOOL smtp_get_port(uschar *, address_item *, int *, uschar *);
extern int smtp_getc(void);
extern int smtp_handle_acl_fail(int, int, uschar *, uschar *);
extern void smtp_log_no_mail(void);
extern void smtp_message_code(uschar **, int *, uschar **, uschar **);
extern BOOL smtp_read_response(smtp_inblock *, uschar *, int, int, int);
extern void smtp_respond(uschar *, int, BOOL, uschar *);
extern void smtp_notquit_exit(uschar *, uschar *, uschar *, ...);
extern void smtp_send_prohibition_message(int, uschar *);
extern int smtp_setup_msg(void);
extern BOOL smtp_start_session(void);
extern int smtp_ungetc(int);
extern BOOL smtp_verify_helo(void);
extern int smtp_write_command(smtp_outblock *, BOOL, const char *, ...) __attribute__((format(printf,3,4)));




extern BOOL spool_move_message(uschar *, uschar *, uschar *, uschar *);
extern BOOL spool_open_datafile(uschar *);
extern int spool_open_temp(uschar *);
extern int spool_read_header(uschar *, BOOL, BOOL);
extern int spool_write_header(uschar *, int, uschar **);
extern int stdin_getc(void);
extern int stdin_feof(void);
extern int stdin_ferror(void);
extern int stdin_ungetc(int);
extern uschar *string_append(uschar *, int *, int *, int, ...);
extern uschar *string_base62(unsigned long int);
extern uschar *string_cat(uschar *, int *, int *, const uschar *, int);
extern uschar *string_copy_dnsdomain(uschar *);
extern uschar *string_copy_malloc(uschar *);
extern uschar *string_copylc(uschar *);
extern uschar *string_copynlc(uschar *, int);
extern uschar *string_dequote(uschar **);
extern BOOL string_format(uschar *, int, const char *, ...) ;
extern uschar *string_format_size(int, uschar *);
extern int string_interpret_escape(uschar **);
extern int string_is_ip_address(uschar *, int *);
extern uschar *string_log_address(address_item *, BOOL, BOOL);
extern uschar *string_nextinlist(uschar **, int *, uschar *, int);
extern uschar *string_open_failed(int, const char *, ...) __attribute__((format(printf,2,3)));
extern uschar *string_printing2(uschar *, BOOL);
extern uschar *string_split_message(uschar *);
extern uschar *string_unprinting(uschar *);
extern BOOL string_vformat(uschar *, int, const char *, va_list);
extern int strcmpic(const uschar *, const uschar *);
extern int strncmpic(const uschar *, const uschar *, int);
extern uschar *strstric(uschar *, uschar *, BOOL);

extern uschar *tod_stamp(int);
extern BOOL transport_check_waiting(uschar *, uschar *, int, uschar *,
                 BOOL *);
extern void transport_init(void);
extern BOOL transport_pass_socket(uschar *, uschar *, uschar *, uschar *,
                 int);
extern uschar *transport_rcpt_address(address_item *, BOOL);
extern BOOL transport_set_up_command(uschar ***, uschar *, BOOL, int,
                 address_item *, uschar *, uschar **);
extern void transport_update_waiting(host_item *, uschar *);
extern BOOL transport_write_block(int, uschar *, int);
extern BOOL transport_write_string(int, const char *, ...);
extern BOOL transport_write_message(address_item *, int, int, int, uschar *,
                 uschar *, uschar *, uschar *, rewrite_rule *, int);
extern void tree_add_duplicate(uschar *, address_item *);
extern void tree_add_nonrecipient(uschar *);
extern void tree_add_unusable(host_item *);
extern int tree_insertnode(tree_node **, tree_node *);
extern tree_node *tree_search(tree_node *, uschar *);
extern void tree_write(tree_node *, FILE *);
extern void tree_walk(tree_node *, void (*)(uschar*, uschar*, void*), void *);





extern int verify_address(address_item *, FILE *, int, int, int, int,
                 uschar *, uschar *, BOOL *);
extern int verify_check_dnsbl(uschar **);
extern int verify_check_header_address(uschar **, uschar **, int, int, int,
                 uschar *, uschar *, int, int *);
extern int verify_check_headers(uschar **);
extern int verify_check_host(uschar **);
extern int verify_check_notblind(void);
extern int verify_check_this_host(uschar **, unsigned int *, uschar*,
                 uschar *, uschar **);
extern address_item *verify_checked_sender(uschar *);
extern void verify_get_ident(int);
extern BOOL verify_sender(int *, uschar **);
extern BOOL verify_sender_preliminary(int *, uschar **);
extern void version_init(void);

extern ssize_t write_to_fd_buf(int, const uschar *, size_t);

/* End of functions.h */
# 473 "src/exim.h" 2
# 1 "src/dbfunctions.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2009 */
/* See the file NOTICE for conditions of use and distribution. */


/* Functions for reading/writing exim database files */

void dbfn_close(open_db *);
int dbfn_delete(open_db *, uschar *);
open_db *dbfn_open(uschar *, int, open_db *, BOOL);
void *dbfn_read_with_length(open_db *, uschar *, int *);
uschar *dbfn_scan(open_db *, BOOL, DBC **);
int dbfn_write(open_db *, uschar *, void *, int);

/* Macro for the common call to read without wanting to know the length. */



/* Berkeley DB uses a callback function to pass back error details. Its API
changed at release 4.3. */



void dbfn_bdb_error_callback(const DB_ENV *, const char *, const char *);





/* End of dbfunctions.h */
# 474 "src/exim.h" 2
# 1 "src/osfunctions.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2009 */
/* See the file NOTICE for conditions of use and distribution. */

/* Prototypes for os-specific functions. For utilities, we don't need the one
that uses a type that isn't defined for them. */


extern ip_address_item *os_common_find_running_interfaces(void);


/* If these exist as a macro, then they're overridden away from us and we
rely upon the system headers to provide prototype declarations for us.
Notably, strsignal() is not in the Single Unix Specification (v3) and
predicting constness is awkward. */


extern int os_getloadavg(void);


extern void os_restarting_signal(int, void (*)(int));


extern void os_non_restarting_signal(int, void (*)(int));


extern const char *os_strexit(int); /* char to match os_strsignal */





/* End of osfunctions.h */
# 475 "src/exim.h" 2
# 486 "src/exim.h"
# 1 "src/dkim.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge, 1995 - 2007 */
/* See the file NOTICE for conditions of use and distribution. */

uschar *dkim_exim_sign(int,uschar *,uschar *,uschar *,uschar *,uschar *);
void dkim_exim_verify_init(void);
void dkim_exim_verify_feed(uschar *, int);
void dkim_exim_verify_finish(void);
void dkim_exim_acl_setup(uschar *);
uschar *dkim_exim_expand_query(int);
uschar *dkim_exim_expand_defaults(int);
# 487 "src/exim.h" 2


/* The following stuff must follow the inclusion of config.h because it
requires various things that are set therein. */


# 1 "/usr/include/iconv.h" 1 3 4
/* Copyright (C) 1997-2000, 2003, 2011, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/iconv.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 24 "/usr/include/iconv.h" 2 3 4




/* Identifier for conversion method from one codeset to another.  */
typedef void *iconv_t;


/* Allocate descriptor for code conversion from codeset FROMCODE to
   codeset TOCODE.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern iconv_t iconv_open (const char *__tocode, const char *__fromcode);

/* Convert at most *INBYTESLEFT bytes from *INBUF according to the
   code conversion algorithm specified by CD and place up to
   *OUTBYTESLEFT bytes in buffer at *OUTBUF.  */
extern size_t iconv (iconv_t __cd, char **__restrict __inbuf,
       size_t *__restrict __inbytesleft,
       char **__restrict __outbuf,
       size_t *__restrict __outbytesleft);

/* Free resources allocated for descriptor CD for code conversion.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int iconv_close (iconv_t __cd);


# 494 "src/exim.h" 2
# 506 "src/exim.h"
/* Backward compatibility; LOOKUP_LSEARCH now includes all three */





/* Define a union to hold either an IPv4 or an IPv6 sockaddr structure; this
simplifies some of the coding.  We include the sockaddr to reduce type-punning
issues in C99. */

union sockaddr_46 {
  struct sockaddr_in v4;



  struct sockaddr v0;
};

/* If SUPPORT_TLS is not defined, ensure that USE_GNUTLS is also not defined
so that if USE_GNUTLS *is* set, we can assume SUPPORT_TLS is also set. */





/* If SPOOL_DIRECTORY, LOG_FILE_PATH or PID_FILE_PATH have not been defined,
set them to the null string. */
# 544 "src/exim.h"
/* The EDQUOT error code isn't universally available, though it is widespread.
There is a particular shambles in SunOS5, where it did not exist originally,
but got installed with a particular patch for Solaris 2.4. There is a
configuration variable for specifying what the system's "over quota" error is,
which will end up in config.h if supplied in OS/Makefile-xxx. If it is not set,
default to EDQUOT if it exists, otherwise ENOSPC. */
# 559 "src/exim.h"
/* Ensure PATH_MAX is defined */
# 569 "src/exim.h"
/* End of exim.h */
# 12 "src/smtp_in.c" 2


/* Initialize for TCP wrappers if so configured. It appears that the macro
HAVE_IPV6 is used in some versions of the tcpd.h header, so we unset it before
including that header, and restore its value afterwards. */
# 36 "src/smtp_in.c"
/* Size of buffer for reading SMTP commands. We used to use 512, as defined
by RFC 821. However, RFC 1869 specifies that this must be increased for SMTP
commands that accept arguments, and this in particular applies to AUTH, where
the data can be quite long.  More recently this value was 2048 in Exim; 
however, RFC 4954 (circa 2007) recommends 12288 bytes to handle AUTH.  Clients
such as Thunderbird will send an AUTH with an initial-response for GSSAPI. 
The maximum size of a Kerberos ticket under Windows 2003 is 12000 bytes, and 
we need room to handle large base64-encoded AUTHs for GSSAPI.
*/



/* Size of buffer for reading SMTP incoming packets */



/* Structure for SMTP command list */

typedef struct {
  const char *name;
  int len;
  short int cmd;
  short int has_arg;
  short int is_mail_cmd;
} smtp_cmd_list;

/* Codes for identifying commands. We order them so that those that come first
are those for which synchronization is always required. Checking this can help
block some spam.  */

enum {
  /* These commands are required to be synchronized, i.e. to be the last in a
  block of commands when pipelining. */

  HELO_CMD, EHLO_CMD, DATA_CMD, /* These are listed in the pipelining */
  VRFY_CMD, EXPN_CMD, NOOP_CMD, /* RFC as requiring synchronization */
  ETRN_CMD, /* This by analogy with TURN from the RFC */
  STARTTLS_CMD, /* Required by the STARTTLS RFC */

  /* This is a dummy to identify the non-sync commands when pipelining */

  NON_SYNC_CMD_PIPELINING,

  /* These commands need not be synchronized when pipelining */

  MAIL_CMD, RCPT_CMD, RSET_CMD,

  /* This is a dummy to identify the non-sync commands when not pipelining */

  NON_SYNC_CMD_NON_PIPELINING,

  /* I have been unable to find a statement about the use of pipelining
  with AUTH, so to be on the safe side it is here, though I kind of feel
  it should be up there with the synchronized commands. */

  AUTH_CMD,

  /* I'm not sure about these, but I don't think they matter. */

  QUIT_CMD, HELP_CMD,

  /* These are specials that don't correspond to actual commands */

  EOF_CMD, OTHER_CMD, BADARG_CMD, BADCHAR_CMD, BADSYN_CMD,
  TOO_MANY_NONMAIL_CMD };


/* This is a convenience macro for adding the identity of an SMTP command
to the circular buffer that holds a list of the last n received. */






/*************************************************
*                Local static variables          *
*************************************************/

static auth_instance *authenticated_by;
static BOOL auth_advertised;



static BOOL esmtp;
static BOOL helo_required = 0;
static BOOL helo_verify = 0;
static BOOL helo_seen;
static BOOL helo_accept_junk;
static BOOL count_nonmail;
static BOOL pipelining_advertised;
static BOOL rcpt_smtp_response_same;
static BOOL rcpt_in_progress;
static int nonmail_command_count;
static BOOL smtp_exit_function_called = 0;
static int synprot_error_count;
static int unknown_command_count;
static int sync_cmd_limit;
static int smtp_write_error = 0;

static uschar *rcpt_smtp_response;
static uschar *smtp_data_buffer;
static uschar *smtp_cmd_data;

/* We need to know the position of RSET, HELO, EHLO, AUTH, and STARTTLS. Their
final fields of all except AUTH are forced TRUE at the start of a new message
setup, to allow one of each between messages that is not counted as a nonmail
command. (In fact, only one of HELO/EHLO is not counted.) Also, we have to
allow a new EHLO after starting up TLS.

AUTH is "falsely" labelled as a mail command initially, so that it doesn't get
counted. However, the flag is changed when AUTH is received, so that multiple
failing AUTHs will eventually hit the limit. After a successful AUTH, another
AUTH is already forbidden. After a TLS session is started, AUTH's flag is again
forced TRUE, to allow for the re-authentication that can happen at that point.

QUIT is also "falsely" labelled as a mail command so that it doesn't up the
count of non-mail commands and possibly provoke an error. */

static smtp_cmd_list cmd_list[] = {
  { "rset", sizeof("rset")-1, RSET_CMD, 0, 0 }, /* First */
  { "helo", sizeof("helo")-1, HELO_CMD, 1, 0 },
  { "ehlo", sizeof("ehlo")-1, EHLO_CMD, 1, 0 },
  { "auth", sizeof("auth")-1, AUTH_CMD, 1, 1 },




/* If you change anything above here, also fix the definitions below. */

  { "mail from:", sizeof("mail from:")-1, MAIL_CMD, 1, 1 },
  { "rcpt to:", sizeof("rcpt to:")-1, RCPT_CMD, 1, 1 },
  { "data", sizeof("data")-1, DATA_CMD, 0, 1 },
  { "quit", sizeof("quit")-1, QUIT_CMD, 0, 1 },
  { "noop", sizeof("noop")-1, NOOP_CMD, 1, 0 },
  { "etrn", sizeof("etrn")-1, ETRN_CMD, 1, 0 },
  { "vrfy", sizeof("vrfy")-1, VRFY_CMD, 1, 0 },
  { "expn", sizeof("expn")-1, EXPN_CMD, 1, 0 },
  { "help", sizeof("help")-1, HELP_CMD, 1, 0 }
};

static smtp_cmd_list *cmd_list_end =
  cmd_list + sizeof(cmd_list)/sizeof(smtp_cmd_list);







/* This list of names is used for performing the smtp_no_mail logging action.
It must be kept in step with the SCH_xxx enumerations. */

static uschar *smtp_names[] =
  {
  (unsigned char *)"NONE", (unsigned char *)"AUTH", (unsigned char *)"DATA", (unsigned char *)"EHLO", (unsigned char *)"ETRN", (unsigned char *)"EXPN", (unsigned char *)"HELO",
  (unsigned char *)"HELP", (unsigned char *)"MAIL", (unsigned char *)"NOOP", (unsigned char *)"QUIT", (unsigned char *)"RCPT", (unsigned char *)"RSET", (unsigned char *)"STARTTLS",
  (unsigned char *)"VRFY" };

static uschar *protocols[] = {
  (unsigned char *)"local-smtp", /* HELO */
  (unsigned char *)"local-smtps", /* The rare case EHLO->STARTTLS->HELO */
  (unsigned char *)"local-esmtp", /* EHLO */
  (unsigned char *)"local-esmtps", /* EHLO->STARTTLS->EHLO */
  (unsigned char *)"local-esmtpa", /* EHLO->AUTH */
  (unsigned char *)"local-esmtpsa" /* EHLO->STARTTLS->EHLO->AUTH */
  };







/* When reading SMTP from a remote host, we have to use our own versions of the
C input-reading functions, in order to be able to flush the SMTP output only
when about to read more data from the socket. This is the only way to get
optimal performance when the client is using pipelining. Flushing for every
command causes a separate packet and reply packet each time; saving all the
responses up (when pipelining) combines them into one packet and one response.

For simplicity, these functions are used for *all* SMTP input, not only when
receiving over a socket. However, after setting up a secure socket (SSL), input
is read via the OpenSSL library, and another set of functions is used instead
(see tls.c).

These functions are set in the receive_getc etc. variables and called with the
same interface as the C functions. However, since there can only ever be
one incoming SMTP call, we just use a single buffer and flags. There is no need
to implement a complicated private FILE-like structure.*/

static uschar *smtp_inbuffer;
static uschar *smtp_inptr;
static uschar *smtp_inend;
static int smtp_had_eof;
static int smtp_had_error;


/*************************************************
*          SMTP version of getc()                *
*************************************************/

/* This gets the next byte from the SMTP input buffer. If the buffer is empty,
it flushes the output, and refills the buffer, with a timeout. The signal
handler is set appropriately by the calling function. This function is not used
after a connection has negotated itself into an TLS/SSL state.

Arguments:  none
Returns:    the next character or EOF
*/

int
smtp_getc(void)
{
if (smtp_inptr >= smtp_inend)
  {
  int rc, save_errno;
  fflush(smtp_out);
  if (smtp_receive_timeout > 0) alarm(smtp_receive_timeout);
  rc = read(fileno(smtp_in), smtp_inbuffer, 8192);
  save_errno = (*__errno_location ());
  alarm(0);
  if (rc <= 0)
    {
    /* Must put the error text in fixed store, because this might be during
    header reading, where it releases unused store above the header. */
    if (rc < 0)
      {
      smtp_had_error = save_errno;
      smtp_read_error = string_copy_malloc(
        string_sprintf(" (error: %s)", strerror(save_errno)));
      }
    else smtp_had_eof = 1;
    return (-1);
    }

  dkim_exim_verify_feed(smtp_inbuffer, rc);

  smtp_inend = smtp_inbuffer + rc;
  smtp_inptr = smtp_inbuffer;
  }
return *smtp_inptr++;
}



/*************************************************
*          SMTP version of ungetc()              *
*************************************************/

/* Puts a character back in the input buffer. Only ever
called once.

Arguments:
  ch           the character

Returns:       the character
*/

int
smtp_ungetc(int ch)
{
*(--smtp_inptr) = ch;
return ch;
}




/*************************************************
*          SMTP version of feof()                *
*************************************************/

/* Tests for a previous EOF

Arguments:     none
Returns:       non-zero if the eof flag is set
*/

int
smtp_feof(void)
{
return smtp_had_eof;
}




/*************************************************
*          SMTP version of ferror()              *
*************************************************/

/* Tests for a previous read error, and returns with errno
restored to what it was when the error was detected.

Arguments:     none
Returns:       non-zero if the error flag is set
*/

int
smtp_ferror(void)
{
(*__errno_location ()) = smtp_had_error;
return smtp_had_error;
}



/*************************************************
*      Test for characters in the SMTP buffer    *
*************************************************/

/* Used at the end of a message

Arguments:     none
Returns:       TRUE/FALSE
*/

BOOL
smtp_buffered(void)
{
return smtp_inptr < smtp_inend;
}



/*************************************************
*     Write formatted string to SMTP channel     *
*************************************************/

/* This is a separate function so that we don't have to repeat everything for
TLS support or debugging. It is global so that the daemon and the
authentication functions can use it. It does not return any error indication,
because major problems such as dropped connections won't show up till an output
flush for non-TLS connections. The smtp_fflush() function is available for
checking that: for convenience, TLS output errors are remembered here so that
they are also picked up later by smtp_fflush().

Arguments:
  format      format string
  ...         optional arguments

Returns:      nothing
*/

void
smtp_printf(const char *format, ...)
{
va_list ap;

__builtin_va_start(ap,format);
smtp_vprintf(format, ap);
__builtin_va_end(ap);
}

/* This is split off so that verify.c:respond_printf() can, in effect, call
smtp_printf(), bearing in mind that in C a vararg function can't directly
call another vararg function, only a function which accepts a va_list. */

void
smtp_vprintf(const char *format, va_list ap)
{
BOOL yield;

yield = string_vformat(big_buffer, big_buffer_size, format, ap);

if ((debug_selector & (0x00200000)) != 0)
  {
  void *reset_point = store_get_3(0, "src/smtp_in.c", 404);
  uschar *msg_copy, *cr, *end;
  msg_copy = string_copy(big_buffer);
  end = msg_copy + (int)strlen((const char *)(msg_copy));
  while ((cr = (unsigned char *) strchr((const char *)(msg_copy),'\r')) != ((void *)0)) /* lose CRs */
  memmove(cr, cr + 1, (end--) - cr);
  debug_printf("SMTP>> %s", msg_copy);
  store_reset_3(reset_point, "src/smtp_in.c", 411);
  }

if (!yield)
  {
  log_write(0, 1|2, "string too large in smtp_printf()");
  smtp_closedown((unsigned char *)"Unexpected error");
  exim_exit(1);
  }

/* If this is the first output for a (non-batch) RCPT command, see if all RCPTs
have had the same. Note: this code is also present in smtp_respond(). It would
be tidier to have it only in one place, but when it was added, it was easier to
do it that way, so as not to have to mess with the code for the RCPT command,
which sometimes uses smtp_printf() and sometimes smtp_respond(). */

if (rcpt_in_progress)
  {
  if (rcpt_smtp_response == ((void *)0))
    rcpt_smtp_response = string_copy(big_buffer);
  else if (rcpt_smtp_response_same &&
           strcmp((const char *)(rcpt_smtp_response),(const char *)(big_buffer)) != 0)
    rcpt_smtp_response_same = 0;
  rcpt_in_progress = 0;
  }

/* Now write the string */
# 447 "src/smtp_in.c"
if (fprintf(smtp_out, "%s", big_buffer) < 0) smtp_write_error = -1;
}



/*************************************************
*        Flush SMTP out and check for error      *
*************************************************/

/* This function isn't currently used within Exim (it detects errors when it
tries to read the next SMTP input), but is available for use in local_scan().
For non-TLS connections, it flushes the output and checks for errors. For
TLS-connections, it checks for a previously-detected TLS write error.

Arguments:  none
Returns:    0 for no error; -1 after an error
*/

int
smtp_fflush(void)
{
if (tls_active < 0 && fflush(smtp_out) != 0) smtp_write_error = -1;
return smtp_write_error;
}



/*************************************************
*          SMTP command read timeout             *
*************************************************/

/* Signal handler for timing out incoming SMTP commands. This attempts to
finish off tidily.

Argument: signal number (SIGALRM)
Returns:  nothing
*/

static void
command_timeout_handler(int sig)
{
sig = sig; /* Keep picky compilers happy */
log_write(0x00000080,
          1, "SMTP command timeout on%s connection from %s",
          (tls_active >= 0)? " TLS" : "",
          host_and_ident(0));
if (smtp_batched_input)
  moan_smtp_batch(((void *)0), "421 SMTP command timeout"); /* Does not return */
smtp_notquit_exit((unsigned char *)"command-timeout", (unsigned char *)"421",
  (unsigned char *)"%s: SMTP command timeout - closing connection", smtp_active_hostname);
exim_exit(1);
}



/*************************************************
*               SIGTERM received                 *
*************************************************/

/* Signal handler for handling SIGTERM. Again, try to finish tidily.

Argument: signal number (SIGTERM)
Returns:  nothing
*/

static void
command_sigterm_handler(int sig)
{
sig = sig; /* Keep picky compilers happy */
log_write(0, 1, "%s closed after SIGTERM", smtp_get_connection_info());
if (smtp_batched_input)
  moan_smtp_batch(((void *)0), "421 SIGTERM received"); /* Does not return */
smtp_notquit_exit((unsigned char *)"signal-exit", (unsigned char *)"421",
  (unsigned char *)"%s: Service not available - closing connection", smtp_active_hostname);
exim_exit(1);
}




/*************************************************
*           Read one command line                *
*************************************************/

/* Strictly, SMTP commands coming over the net are supposed to end with CRLF.
There are sites that don't do this, and in any case internal SMTP probably
should check only for LF. Consequently, we check here for LF only. The line
ends up with [CR]LF removed from its end. If we get an overlong line, treat as
an unknown command. The command is read into the global smtp_cmd_buffer so that
it is available via $smtp_command.

The character reading routine sets up a timeout for each block actually read
from the input (which may contain more than one command). We set up a special
signal handler that closes down the session on a timeout. Control does not
return when it runs.

Arguments:
  check_sync   if TRUE, check synchronization rules if global option is TRUE

Returns:       a code identifying the command (enumerated above)
*/

static int
smtp_read_command(BOOL check_sync)
{
int c;
int ptr = 0;
smtp_cmd_list *p;
BOOL hadnull = 0;

os_non_restarting_signal(14, command_timeout_handler);

while ((c = (receive_getc)()) != '\n' && c != (-1))
  {
  if (ptr >= 16384)
    {
    os_non_restarting_signal(14, sigalrm_handler);
    return OTHER_CMD;
    }
  if (c == 0)
    {
    hadnull = 1;
    c = '?';
    }
  smtp_cmd_buffer[ptr++] = c;
  }

receive_linecount++; /* For BSMTP errors */
os_non_restarting_signal(14, sigalrm_handler);

/* If hit end of file, return pseudo EOF command. Whether we have a
part-line already read doesn't matter, since this is an error state. */

if (c == (-1)) return EOF_CMD;

/* Remove any CR and white space at the end of the line, and terminate the
string. */

while (ptr > 0 && ((*__ctype_b_loc ())[(int) ((smtp_cmd_buffer[ptr-1]))] & (unsigned short int) _ISspace)) ptr--;
smtp_cmd_buffer[ptr] = 0;

if ((debug_selector & (0x00200000)) != 0) debug_printf("SMTP<< %s\n", smtp_cmd_buffer);

/* NULLs are not allowed in SMTP commands */

if (hadnull) return BADCHAR_CMD;

/* Scan command list and return identity, having set the data pointer
to the start of the actual data characters. Check for SMTP synchronization
if required. */

for (p = cmd_list; p < cmd_list_end; p++)
  {
  if (strncmpic(smtp_cmd_buffer, (unsigned char *) p->name, p->len) == 0 &&
       (smtp_cmd_buffer[p->len-1] == ':' || /* "mail from:" or "rcpt to:" */
        smtp_cmd_buffer[p->len] == 0 ||
        smtp_cmd_buffer[p->len] == ' '))
    {
    if (smtp_inptr < smtp_inend && /* Outstanding input */
        p->cmd < sync_cmd_limit && /* Command should sync */
        check_sync && /* Local flag set */
        smtp_enforce_sync && /* Global flag set */
        sender_host_address != ((void *)0) && /* Not local input */
        !sender_host_notsocket) /* Really is a socket */
      return BADSYN_CMD;

    /* The variables $smtp_command and $smtp_command_argument point into the
    unmodified input buffer. A copy of the latter is taken for actual
    processing, so that it can be chopped up into separate parts if necessary,
    for example, when processing a MAIL command options such as SIZE that can
    follow the sender address. */

    smtp_cmd_argument = smtp_cmd_buffer + p->len;
    while (((*__ctype_b_loc ())[(int) ((*smtp_cmd_argument))] & (unsigned short int) _ISspace)) smtp_cmd_argument++;
    strcpy((char *)(smtp_data_buffer),(const char *)(smtp_cmd_argument));
    smtp_cmd_data = smtp_data_buffer;

    /* Count non-mail commands from those hosts that are controlled in this
    way. The default is all hosts. We don't waste effort checking the list
    until we get a non-mail command, but then cache the result to save checking
    again. If there's a DEFER while checking the host, assume it's in the list.

    Note that one instance of RSET, EHLO/HELO, and STARTTLS is allowed at the
    start of each incoming message by fiddling with the value in the table. */

    if (!p->is_mail_cmd)
      {
      if (count_nonmail == 2) count_nonmail =
        verify_check_host(&smtp_accept_max_nonmail_hosts) != 2;
      if (count_nonmail && ++nonmail_command_count > smtp_accept_max_nonmail)
        return TOO_MANY_NONMAIL_CMD;
      }

    /* If there is data for a command that does not expect it, generate the
    error here. */

    return (p->has_arg || *smtp_cmd_data == 0)? p->cmd : BADARG_CMD;
    }
  }

/* Enforce synchronization for unknown commands */

if (smtp_inptr < smtp_inend && /* Outstanding input */
    check_sync && /* Local flag set */
    smtp_enforce_sync && /* Global flag set */
    sender_host_address != ((void *)0) && /* Not local input */
    !sender_host_notsocket) /* Really is a socket */
  return BADSYN_CMD;

return OTHER_CMD;
}



/*************************************************
*          Recheck synchronization               *
*************************************************/

/* Synchronization checks can never be perfect because a packet may be on its
way but not arrived when the check is done. Such checks can in any case only be
done when TLS is not in use. Normally, the checks happen when commands are
read: Exim ensures that there is no more input in the input buffer. In normal
cases, the response to the command will be fast, and there is no further check.

However, for some commands an ACL is run, and that can include delays. In those
cases, it is useful to do another check on the input just before sending the
response. This also applies at the start of a connection. This function does
that check by means of the select() function, as long as the facility is not
disabled or inappropriate. A failure of select() is ignored.

When there is unwanted input, we read it so that it appears in the log of the
error.

Arguments: none
Returns:   TRUE if all is well; FALSE if there is input pending
*/

static BOOL
check_sync(void)
{
int fd, rc;
fd_set fds;
struct timeval tzero;

if (!smtp_enforce_sync || sender_host_address == ((void *)0) ||
    sender_host_notsocket || tls_active >= 0)
  return 1;

fd = fileno(smtp_in);
do { int __d0, __d1; __asm__ __volatile__ ("cld; rep; " "stosq" : "=c" (__d0), "=D" (__d1) : "a" (0), "0" (sizeof (fd_set) / sizeof (__fd_mask)), "1" (&((&fds)->fds_bits)[0]) : "memory"); } while (0);
((void) (((&fds)->fds_bits)[((fd) / (8 * (int) sizeof (__fd_mask)))] |= ((__fd_mask) 1 << ((fd) % (8 * (int) sizeof (__fd_mask))))));
tzero.tv_sec = 0;
tzero.tv_usec = 0;
rc = select(fd + 1, (fd_set *)&fds, ((void *)0), ((void *)0), &tzero);

if (rc <= 0) return 1; /* Not ready to read */
rc = smtp_getc();
if (rc < 0) return 1; /* End of file or error */

smtp_ungetc(rc);
rc = smtp_inend - smtp_inptr;
if (rc > 150) rc = 150;
smtp_inptr[rc] = 0;
return 0;
}



/*************************************************
*          Forced closedown of call              *
*************************************************/

/* This function is called from log.c when Exim is dying because of a serious
disaster, and also from some other places. If an incoming non-batched SMTP
channel is open, it swallows the rest of the incoming message if in the DATA
phase, sends the reply string, and gives an error to all subsequent commands
except QUIT. The existence of an SMTP call is detected by the non-NULLness of
smtp_in.

Arguments:
  message   SMTP reply string to send, excluding the code

Returns:    nothing
*/

void
smtp_closedown(uschar *message)
{
if (smtp_in == ((void *)0) || smtp_batched_input) return;
receive_swallow_smtp();
smtp_printf("421 %s\r\n", message);

for (;;)
  {
  switch(smtp_read_command(0))
    {
    case EOF_CMD:
    return;

    case QUIT_CMD:
    smtp_printf("221 %s closing connection\r\n", smtp_active_hostname);
    fflush(smtp_out);;
    return;

    case RSET_CMD:
    smtp_printf("250 Reset OK\r\n");
    break;

    default:
    smtp_printf("421 %s\r\n", message);
    break;
    }
  }
}




/*************************************************
*        Set up connection info for logging      *
*************************************************/

/* This function is called when logging information about an SMTP connection.
It sets up appropriate source information, depending on the type of connection.
If sender_fullhost is NULL, we are at a very early stage of the connection;
just use the IP address.

Argument:    none
Returns:     a string describing the connection
*/

uschar *
smtp_get_connection_info(void)
{
uschar *hostname = (sender_fullhost == ((void *)0))?
  sender_host_address : sender_fullhost;

if (host_checking)
  return string_sprintf("SMTP connection from %s", hostname);

if (sender_host_unknown || sender_host_notsocket)
  return string_sprintf("SMTP connection from %s", sender_ident);

if (is_inetd)
  return string_sprintf("SMTP connection from %s (via inetd)", hostname);

if ((log_extra_selector & 0x80000020) != 0 &&
     interface_address != ((void *)0))
  return string_sprintf("SMTP connection from %s I=[%s]:%d", hostname,
    interface_address, interface_port);

return string_sprintf("SMTP connection from %s", hostname);
}



/*************************************************
*      Log lack of MAIL if so configured         *
*************************************************/

/* This function is called when an SMTP session ends. If the log selector
smtp_no_mail is set, write a log line giving some details of what has happened
in the SMTP session.

Arguments:   none
Returns:     nothing
*/

void
smtp_log_no_mail(void)
{
int size, ptr, i;
uschar *s, *sep;

if (smtp_mailcmd_count > 0 || (log_extra_selector & 0x80040000) == 0)
  return;

s = ((void *)0);
size = ptr = 0;

if (sender_host_authenticated != ((void *)0))
  {
  s = string_append(s, &size, &ptr, 2, (unsigned char *)" A=", sender_host_authenticated);
  if (authenticated_id != ((void *)0))
    s = string_append(s, &size, &ptr, 2, (unsigned char *)":", authenticated_id);
  }
# 849 "src/smtp_in.c"
sep = (smtp_connection_had[20 -1] != SCH_NONE)?
  (unsigned char *)" C=..." : (unsigned char *)" C=";
for (i = smtp_ch_index; i < 20; i++)
  {
  if (smtp_connection_had[i] != SCH_NONE)
    {
    s = string_append(s, &size, &ptr, 2, sep,
      smtp_names[smtp_connection_had[i]]);
    sep = (unsigned char *)",";
    }
  }

for (i = 0; i < smtp_ch_index; i++)
  {
  s = string_append(s, &size, &ptr, 2, sep, smtp_names[smtp_connection_had[i]]);
  sep = (unsigned char *)",";
  }

if (s != ((void *)0)) s[ptr] = 0; else s = (unsigned char *)"";
log_write(0, 1, "no MAIL in SMTP connection from %s D=%s%s",
  host_and_ident(0),
  readconf_printtime(time(((void *)0)) - smtp_connection_start), s);
}



/*************************************************
*   Check HELO line and set sender_helo_name     *
*************************************************/

/* Check the format of a HELO line. The data for HELO/EHLO is supposed to be
the domain name of the sending host, or an ip literal in square brackets. The
arrgument is placed in sender_helo_name, which is in malloc store, because it
must persist over multiple incoming messages. If helo_accept_junk is set, this
host is permitted to send any old junk (needed for some broken hosts).
Otherwise, helo_allow_chars can be used for rogue characters in general
(typically people want to let in underscores).

Argument:
  s       the data portion of the line (already past any white space)

Returns:  TRUE or FALSE
*/

static BOOL
check_helo(uschar *s)
{
uschar *start = s;
uschar *end = s + (int)strlen((const char *)(s));
BOOL yield = helo_accept_junk;

/* Discard any previous helo name */

if (sender_helo_name != ((void *)0))
  {
  store_free_3(sender_helo_name, "src/smtp_in.c", 904);
  sender_helo_name = ((void *)0);
  }

/* Skip tests if junk is permitted. */

if (!yield)
  {
  /* Allow the new standard form for IPv6 address literals, namely,
  [IPv6:....], and because someone is bound to use it, allow an equivalent
  IPv4 form. Allow plain addresses as well. */

  if (*s == '[')
    {
    if (end[-1] == ']')
      {
      end[-1] = 0;
      if (strncmpic(s, (unsigned char *)"[IPv6:", 6) == 0)
        yield = (string_is_ip_address(s+6, ((void *)0)) == 6);
      else if (strncmpic(s, (unsigned char *)"[IPv4:", 6) == 0)
        yield = (string_is_ip_address(s+6, ((void *)0)) == 4);
      else
        yield = (string_is_ip_address(s+1, ((void *)0)) != 0);
      end[-1] = ']';
      }
    }

  /* Non-literals must be alpha, dot, hyphen, plus any non-valid chars
  that have been configured (usually underscore - sigh). */

  else if (*s != 0)
    {
    yield = 1;
    while (*s != 0)
      {
      if (!((*__ctype_b_loc ())[(int) ((*s))] & (unsigned short int) _ISalnum) && *s != '.' && *s != '-' &&
          (unsigned char *) strchr((const char *)(helo_allow_chars),*s) == ((void *)0))
        {
        yield = 0;
        break;
        }
      s++;
      }
    }
  }

/* Save argument if OK */

if (yield) sender_helo_name = string_copy_malloc(start);
return yield;
}





/*************************************************
*         Extract SMTP command option            *
*************************************************/

/* This function picks the next option setting off the end of smtp_cmd_data. It
is called for MAIL FROM and RCPT TO commands, to pick off the optional ESMTP
things that can appear there.

Arguments:
   name           point this at the name
   value          point this at the data string

Returns:          TRUE if found an option
*/

static BOOL
extract_option(uschar **name, uschar **value)
{
uschar *n;
uschar *v = smtp_cmd_data + (int)strlen((const char *)(smtp_cmd_data)) - 1;
while (((*__ctype_b_loc ())[(int) ((*v))] & (unsigned short int) _ISspace)) v--;
v[1] = 0;

while (v > smtp_cmd_data && *v != '=' && !((*__ctype_b_loc ())[(int) ((*v))] & (unsigned short int) _ISspace)) v--;
if (*v != '=') return 0;

n = v;
while(((*__ctype_b_loc ())[(int) ((n[-1]))] & (unsigned short int) _ISalpha)) n--;

/* RFC says SP, but TAB seen in wild and other major MTAs accept it */
if (!((*__ctype_b_loc ())[(int) ((n[-1]))] & (unsigned short int) _ISspace)) return 0;

n[-1] = 0;
*name = n;
*v++ = 0;
*value = v;
return 1;
}





/*************************************************
*         Reset for new message                  *
*************************************************/

/* This function is called whenever the SMTP session is reset from
within either of the setup functions.

Argument:   the stacking pool storage reset point
Returns:    nothing
*/

static void
smtp_reset(void *reset_point)
{
store_reset_3(reset_point, "src/smtp_in.c", 1017);
recipients_list = ((void *)0);
rcpt_count = rcpt_defer_count = rcpt_fail_count =
  raw_recipients_count = recipients_count = recipients_list_max = 0;
message_linecount = 0;
message_size = -1;
acl_added_headers = ((void *)0);
queue_only_policy = 0;
rcpt_smtp_response = ((void *)0);
rcpt_smtp_response_same = 1;
rcpt_in_progress = 0;
deliver_freeze = 0; /* Can be set by ACL */
freeze_tell = freeze_tell_config; /* Can be set by ACL */
fake_response = 0; /* Can be set by ACL */



submission_mode = 0; /* Can be set by ACL */
suppress_local_fixups = 0; /* Can be set by ACL */
active_local_from_check = local_from_check; /* Can be set by ACL */
active_local_sender_retain = local_sender_retain; /* Can be set by ACL */
sender_address = ((void *)0);
submission_name = ((void *)0); /* Can be set by ACL */
raw_sender = ((void *)0); /* After SMTP rewrite, before qualifying */
sender_address_unrewritten = ((void *)0); /* Set only after verify rewrite */
sender_verified_list = ((void *)0); /* No senders verified */
memset(sender_address_cache, 0, sizeof(sender_address_cache));
memset(sender_domain_cache, 0, sizeof(sender_domain_cache));
authenticated_sender = ((void *)0);





dkim_signers = ((void *)0);
dkim_disable_verify = 0;
dkim_collect_input = 0;







body_linecount = body_zerocount = 0;

sender_rate = sender_rate_limit = sender_rate_period = ((void *)0);
ratelimiters_mail = ((void *)0); /* Updated by ratelimit ACL condition */
                   /* Note that ratelimiters_conn persists across resets. */

/* Reset message ACL variables */

acl_var_m = ((void *)0);

/* The message body variables use malloc store. They may be set if this is
not the first message in an SMTP session and the previous message caused them
to be referenced in an ACL. */

if (message_body != ((void *)0))
  {
  store_free_3(message_body, "src/smtp_in.c", 1077);
  message_body = ((void *)0);
  }

if (message_body_end != ((void *)0))
  {
  store_free_3(message_body_end, "src/smtp_in.c", 1083);
  message_body_end = ((void *)0);
  }

/* Warning log messages are also saved in malloc store. They are saved to avoid
repetition in the same message, but it seems right to repeat them for different
messages. */

while (acl_warn_logged != ((void *)0))
  {
  string_item *this = acl_warn_logged;
  acl_warn_logged = acl_warn_logged->next;
  store_free_3(this, "src/smtp_in.c", 1095);
  }
}





/*************************************************
*  Initialize for incoming batched SMTP message  *
*************************************************/

/* This function is called from smtp_setup_msg() in the case when
smtp_batched_input is true. This happens when -bS is used to pass a whole batch
of messages in one file with SMTP commands between them. All errors must be
reported by sending a message, and only MAIL FROM, RCPT TO, and DATA are
relevant. After an error on a sender, or an invalid recipient, the remainder
of the message is skipped. The value of received_protocol is already set.

Argument: none
Returns:  > 0 message successfully started (reached DATA)
          = 0 QUIT read or end of file reached
          < 0 should not occur
*/

static int
smtp_setup_batch_msg(void)
{
int done = 0;
void *reset_point = store_get_3(0, "src/smtp_in.c", 1124);

/* Save the line count at the start of each transaction - single commands
like HELO and RSET count as whole transactions. */

bsmtp_transaction_linecount = receive_linecount;

if ((receive_feof)()) return 0; /* Treat EOF as QUIT */

smtp_reset(reset_point); /* Reset for start of message */

/* Deal with SMTP commands. This loop is exited by setting done to a POSITIVE
value. The values are 2 larger than the required yield of the function. */

while (done <= 0)
  {
  uschar *errmess;
  uschar *recipient = ((void *)0);
  int start, end, sender_domain, recipient_domain;

  switch(smtp_read_command(0))
    {
    /* The HELO/EHLO commands set sender_address_helo if they have
    valid data; otherwise they are ignored, except that they do
    a reset of the state. */

    case HELO_CMD:
    case EHLO_CMD:

    check_helo(smtp_cmd_data);
    /* Fall through */

    case RSET_CMD:
    smtp_reset(reset_point);
    bsmtp_transaction_linecount = receive_linecount;
    break;


    /* The MAIL FROM command requires an address as an operand. All we
    do here is to parse it for syntactic correctness. The form "<>" is
    a special case which converts into an empty string. The start/end
    pointers in the original are not used further for this address, as
    it is the canonical extracted address which is all that is kept. */

    case MAIL_CMD:
    if (sender_address != ((void *)0))
      /* The function moan_smtp_batch() does not return. */
      moan_smtp_batch(smtp_cmd_buffer, "503 Sender already given");

    if (smtp_cmd_data[0] == 0)
      /* The function moan_smtp_batch() does not return. */
      moan_smtp_batch(smtp_cmd_buffer, "501 MAIL FROM must have an address operand");

    /* Reset to start of message */

    smtp_reset(reset_point);

    /* Apply SMTP rewrite */

    raw_sender = ((rewrite_existflags & 0x0100) != 0)?
      rewrite_one(smtp_cmd_data, 0x0100|0x0200, ((void *)0), 0,
        (unsigned char *)"", global_rewrite_rules) : smtp_cmd_data;

    /* Extract the address; the TRUE flag allows <> as valid */

    raw_sender =
      parse_extract_address(raw_sender, &errmess, &start, &end, &sender_domain,
        1);

    if (raw_sender == ((void *)0))
      /* The function moan_smtp_batch() does not return. */
      moan_smtp_batch(smtp_cmd_buffer, "501 %s", errmess);

    sender_address = string_copy(raw_sender);

    /* Qualify unqualified sender addresses if permitted to do so. */

    if (sender_domain == 0 && sender_address[0] != 0 && sender_address[0] != '@')
      {
      if (allow_unqualified_sender)
        {
        sender_address = rewrite_address_qualify(sender_address, 0);
        if ((debug_selector & (0x00200000)) != 0) debug_printf("unqualified address %s accepted "
          "and rewritten\n", raw_sender);
        }
      /* The function moan_smtp_batch() does not return. */
      else moan_smtp_batch(smtp_cmd_buffer, "501 sender address must contain "
        "a domain");
      }
    break;


    /* The RCPT TO command requires an address as an operand. All we do
    here is to parse it for syntactic correctness. There may be any number
    of RCPT TO commands, specifying multiple senders. We build them all into
    a data structure that is in argc/argv format. The start/end values
    given by parse_extract_address are not used, as we keep only the
    extracted address. */

    case RCPT_CMD:
    if (sender_address == ((void *)0))
      /* The function moan_smtp_batch() does not return. */
      moan_smtp_batch(smtp_cmd_buffer, "503 No sender yet given");

    if (smtp_cmd_data[0] == 0)
      /* The function moan_smtp_batch() does not return. */
      moan_smtp_batch(smtp_cmd_buffer, "501 RCPT TO must have an address operand");

    /* Check maximum number allowed */

    if (recipients_max > 0 && recipients_count + 1 > recipients_max)
      /* The function moan_smtp_batch() does not return. */
      moan_smtp_batch(smtp_cmd_buffer, "%s too many recipients",
        recipients_max_reject? "552": "452");

    /* Apply SMTP rewrite, then extract address. Don't allow "<>" as a
    recipient address */

    recipient = ((rewrite_existflags & 0x0100) != 0)?
      rewrite_one(smtp_cmd_data, 0x0100, ((void *)0), 0, (unsigned char *)"",
        global_rewrite_rules) : smtp_cmd_data;

    /* rfc821_domains = TRUE; << no longer needed */
    recipient = parse_extract_address(recipient, &errmess, &start, &end,
      &recipient_domain, 0);
    /* rfc821_domains = FALSE; << no longer needed */

    if (recipient == ((void *)0))
      /* The function moan_smtp_batch() does not return. */
      moan_smtp_batch(smtp_cmd_buffer, "501 %s", errmess);

    /* If the recipient address is unqualified, qualify it if permitted. Then
    add it to the list of recipients. */

    if (recipient_domain == 0)
      {
      if (allow_unqualified_recipient)
        {
        if ((debug_selector & (0x00200000)) != 0) debug_printf("unqualified address %s accepted\n",
          recipient);
        recipient = rewrite_address_qualify(recipient, 1);
        }
      /* The function moan_smtp_batch() does not return. */
      else moan_smtp_batch(smtp_cmd_buffer, "501 recipient address must contain "
        "a domain");
      }
    receive_add_recipient(recipient, -1);
    break;


    /* The DATA command is legal only if it follows successful MAIL FROM
    and RCPT TO commands. This function is complete when a valid DATA
    command is encountered. */

    case DATA_CMD:
    if (sender_address == ((void *)0) || recipients_count <= 0)
      {
      /* The function moan_smtp_batch() does not return. */
      if (sender_address == ((void *)0))
        moan_smtp_batch(smtp_cmd_buffer,
          "503 MAIL FROM:<sender> command must precede DATA");
      else
        moan_smtp_batch(smtp_cmd_buffer,
          "503 RCPT TO:<recipient> must precede DATA");
      }
    else
      {
      done = 3; /* DATA successfully achieved */
      message_ended = 3; /* Indicate in middle of message */
      }
    break;


    /* The VRFY, EXPN, HELP, ETRN, and NOOP commands are ignored. */

    case VRFY_CMD:
    case EXPN_CMD:
    case HELP_CMD:
    case NOOP_CMD:
    case ETRN_CMD:
    bsmtp_transaction_linecount = receive_linecount;
    break;


    case EOF_CMD:
    case QUIT_CMD:
    done = 2;
    break;


    case BADARG_CMD:
    /* The function moan_smtp_batch() does not return. */
    moan_smtp_batch(smtp_cmd_buffer, "501 Unexpected argument data");
    break;


    case BADCHAR_CMD:
    /* The function moan_smtp_batch() does not return. */
    moan_smtp_batch(smtp_cmd_buffer, "501 Unexpected NULL in SMTP command");
    break;


    default:
    /* The function moan_smtp_batch() does not return. */
    moan_smtp_batch(smtp_cmd_buffer, "500 Command unrecognized");
    break;
    }
  }

return done - 2; /* Convert yield values */
}




/*************************************************
*          Start an SMTP session                 *
*************************************************/

/* This function is called at the start of an SMTP session. Thereafter,
smtp_setup_msg() is called to initiate each separate message. This
function does host-specific testing, and outputs the banner line.

Arguments:     none
Returns:       FALSE if the session can not continue; something has
               gone wrong, or the connection to the host is blocked
*/

BOOL
smtp_start_session(void)
{
int size = 256;
int ptr, esclen;
uschar *user_msg, *log_msg;
uschar *code, *esc;
uschar *p, *s, *ss;

smtp_connection_start = time(((void *)0));
for (smtp_ch_index = 0; smtp_ch_index < 20; smtp_ch_index++)
  smtp_connection_had[smtp_ch_index] = SCH_NONE;
smtp_ch_index = 0;

/* Default values for certain variables */

helo_seen = esmtp = helo_accept_junk = 0;
smtp_mailcmd_count = 0;
count_nonmail = 2;
synprot_error_count = unknown_command_count = nonmail_command_count = 0;
smtp_delay_mail = smtp_rlm_base;
auth_advertised = 0;
pipelining_advertised = 0;
pipelining_enable = 1;
sync_cmd_limit = NON_SYNC_CMD_NON_PIPELINING;
smtp_exit_function_called = 0; /* For avoiding loop in not-quit exit */

memset(sender_host_cache, 0, sizeof(sender_host_cache));

/* If receiving by -bs from a trusted user, or testing with -bh, we allow
authentication settings from -oMaa to remain in force. */

if (!host_checking && !sender_host_notsocket) sender_host_authenticated = ((void *)0);
authenticated_by = ((void *)0);






/* Reset ACL connection variables */

acl_var_c = ((void *)0);

/* Allow for trailing 0 in the command and data buffers. */

smtp_cmd_buffer = (uschar *)malloc(2*16384 + 2);
if (smtp_cmd_buffer == ((void *)0))
  log_write(0, 1|6,
    "malloc() failed for SMTP command buffer");
smtp_cmd_buffer[0] = 0;
smtp_data_buffer = smtp_cmd_buffer + 16384 + 1;

/* For batched input, the protocol setting can be overridden from the
command line by a trusted caller. */

if (smtp_batched_input)
  {
  if (received_protocol == ((void *)0)) received_protocol = (unsigned char *)"local-bsmtp";
  }

/* For non-batched SMTP input, the protocol setting is forced here. It will be
reset later if any of EHLO/AUTH/STARTTLS are received. */

else
  received_protocol =
    protocols[0] + ((sender_host_address != ((void *)0))? 6 : 0);

/* Set up the buffer for inputting using direct read() calls, and arrange to
call the local functions instead of the standard C ones. */

smtp_inbuffer = (uschar *)malloc(8192);
if (smtp_inbuffer == ((void *)0))
  log_write(0, 1|6, "malloc() failed for SMTP input buffer");
receive_getc = smtp_getc;
receive_ungetc = smtp_ungetc;
receive_feof = smtp_feof;
receive_ferror = smtp_ferror;
receive_smtp_buffered = smtp_buffered;
smtp_inptr = smtp_inend = smtp_inbuffer;
smtp_had_eof = smtp_had_error = 0;

/* Set up the message size limit; this may be host-specific */

thismessage_size_limit = expand_string_integer(message_size_limit, 1);
if (expand_string_message != ((void *)0))
  {
  if (thismessage_size_limit == -1)
    log_write(0, 1|2, "unable to expand message_size_limit: "
      "%s", expand_string_message);
  else
    log_write(0, 1|2, "invalid message_size_limit: "
      "%s", expand_string_message);
  smtp_closedown((unsigned char *)"Temporary local problem - please try later");
  return 0;
  }

/* When a message is input locally via the -bs or -bS options, sender_host_
unknown is set unless -oMa was used to force an IP address, in which case it
is checked like a real remote connection. When -bs is used from inetd, this
flag is not set, causing the sending host to be checked. The code that deals
with IP source routing (if configured) is never required for -bs or -bS and
the flag sender_host_notsocket is used to suppress it.

If smtp_accept_max and smtp_accept_reserve are set, keep some connections in
reserve for certain hosts and/or networks. */

if (!sender_host_unknown)
  {
  int rc;
  BOOL reserved_host = 0;

  /* Look up IP options (source routing info) on the socket if this is not an
  -oMa "host", and if any are found, log them and drop the connection.

  Linux (and others now, see below) is different to everyone else, so there
  has to be some conditional compilation here. Versions of Linux before 2.1.15
  used a structure whose name was "options". Somebody finally realized that
  this name was silly, and it got changed to "ip_options". I use the
  newer name here, but there is a fudge in the script that sets up os.h
  to define a macro in older Linux systems.

  Sigh. Linux is a fast-moving target. Another generation of Linux uses
  glibc 2, which has chosen ip_opts for the structure name. This is now
  really a glibc thing rather than a Linux thing, so the condition name
  has been changed to reflect this. It is relevant also to GNU/Hurd.

  Mac OS 10.x (Darwin) is like the later glibc versions, but without the
  setting of the __GLIBC__ macro, so we can't detect it automatically. There's
  a special macro defined in the os.h file.

  Some DGUX versions on older hardware appear not to support IP options at
  all, so there is now a general macro which can be set to cut out this
  support altogether.

  How to do this properly in IPv6 is not yet known. */
# 1503 "src/smtp_in.c"
  if (!host_checking && !sender_host_notsocket)
    {




    struct ip_opts ipoptblock;
    struct ip_opts *ipopt = &ipoptblock;
    socklen_t optlen = sizeof(ipoptblock);






    /* Occasional genuine failures of getsockopt() have been seen - for
    example, "reset by peer". Therefore, just log and give up on this
    call, unless the error is ENOPROTOOPT. This error is given by systems
    that have the interfaces but not the mechanism - e.g. GNU/Hurd at the time
    of writing. So for that error, carry on - we just can't do an IP options
    check. */

    if ((debug_selector & (0x00200000)) != 0) debug_printf("checking for IP options\n");

    if (getsockopt(fileno(smtp_out), IPPROTO_IP, 4, (uschar *)(ipopt),
          &optlen) < 0)
      {
      if ((*__errno_location ()) != 92)
        {
        log_write(0, 1, "getsockopt() failed from %s: %s",
          host_and_ident(0), strerror((*__errno_location ())));
        smtp_printf("451 SMTP service not available\r\n");
        return 0;
        }
      }

    /* Deal with any IP options that are set. On the systems I have looked at,
    the value of MAX_IPOPTLEN has been 40, meaning that there should never be
    more logging data than will fit in big_buffer. Nevertheless, after somebody
    questioned this code, I've added in some paranoid checking. */

    else if (optlen > 0)
      {
      uschar *p = big_buffer;
      uschar *pend = big_buffer + big_buffer_size;
      uschar *opt, *adptr;
      int optcount;
      struct in_addr addr;




      uschar *optstart = (uschar *)(ipopt->ip_opts);




      if ((debug_selector & (0x00200000)) != 0) debug_printf("IP options exist\n");

      strcpy((char *)(p),(const char *)("IP options on incoming call:"));
      p += (int)strlen((const char *)(p));

      for (opt = optstart; opt != ((void *)0) &&
           opt < (uschar *)(ipopt) + optlen;)
        {
        switch (*opt)
          {
          case 0:
          opt = ((void *)0);
          break;

          case 1:
          opt++;
          break;

          case 137:
          case 131:
          if (!string_format(p, pend-p, " %s [@%s",
               (*opt == 137)? "SSRR" : "LSRR",



               inet_ntoa(ipopt->ip_dst)))



            {
            opt = ((void *)0);
            break;
            }

          p += (int)strlen((const char *)(p));
          optcount = (opt[1] - 3) / sizeof(struct in_addr);
          adptr = opt + 3;
          while (optcount-- > 0)
            {
            memcpy(&addr, adptr, sizeof(addr));
            if (!string_format(p, pend - p - 1, "%s%s",
                  (optcount == 0)? ":" : "@", inet_ntoa(addr)))
              {
              opt = ((void *)0);
              break;
              }
            p += (int)strlen((const char *)(p));
            adptr += sizeof(struct in_addr);
            }
          *p++ = ']';
          opt += opt[1];
          break;

          default:
            {
            int i;
            if (pend - p < 4 + 3*opt[1]) { opt = ((void *)0); break; }
            strcat((char *)(p),(const char *)("[ "));
            p += 2;
            for (i = 0; i < opt[1]; i++)
              {
              sprintf((char *) p, "%2.2x ", opt[i]);
              p += 3;
              }
            *p++ = ']';
            }
          opt += opt[1];
          break;
          }
        }

      *p = 0;
      log_write(0, 1, "%s", big_buffer);

      /* Refuse any call with IP options. This is what tcpwrappers 7.5 does. */

      log_write(0, 1|16,
        "connection from %s refused (IP options)", host_and_ident(0));

      smtp_printf("554 SMTP service not available\r\n");
      return 0;
      }

    /* Length of options = 0 => there are no options */

    else if ((debug_selector & (0x00200000)) != 0) debug_printf("no IP options found\n");
    }


  /* Set keep-alive in socket options. The option is on by default. This
  setting is an attempt to get rid of some hanging connections that stick in
  read() when the remote end (usually a dialup) goes away. */

  if (smtp_accept_keepalive && !sender_host_notsocket)
    ip_keepalive(fileno(smtp_out), sender_host_address, 0);

  /* If the current host matches host_lookup, set the name by doing a
  reverse lookup. On failure, sender_host_name will be NULL and
  host_lookup_failed will be TRUE. This may or may not be serious - optional
  checks later. */

  if (verify_check_host(&host_lookup) == 0)
    {
    (void)host_name_lookup();
    host_build_sender_fullhost();
    }

  /* Delay this until we have the full name, if it is looked up. */

  set_process_info("handling incoming connection from %s",
    host_and_ident(0));

  /* Start up TLS if tls_on_connect is set. This is for supporting the legacy
  smtps port for use with older style SSL MTAs. */







  /* Test for explicit connection rejection */

  if (verify_check_host(&host_reject_connection) == 0)
    {
    log_write(0x00000004, 1|16, "refused connection "
      "from %s (host_reject_connection)", host_and_ident(0));
    smtp_printf("554 SMTP service not available\r\n");
    return 0;
    }

  /* Test with TCP Wrappers if so configured. There is a problem in that
  hosts_ctl() returns 0 (deny) under a number of system failure circumstances,
  such as disks dying. In these cases, it is desirable to reject with a 4xx
  error instead of a 5xx error. There isn't a "right" way to detect such
  problems. The following kludge is used: errno is zeroed before calling
  hosts_ctl(). If the result is "reject", a 5xx error is given only if the
  value of errno is 0 or ENOENT (which happens if /etc/hosts.{allow,deny} does
  not exist). */
# 1736 "src/smtp_in.c"
  /* Check for reserved slots. The value of smtp_accept_count has already been
  incremented to include this process. */

  if (smtp_accept_max > 0 &&
      smtp_accept_count > smtp_accept_max - smtp_accept_reserve)
    {
    if ((rc = verify_check_host(&smtp_reserve_hosts)) != 0)
      {
      log_write(0x00000004,
        1, "temporarily refused connection from %s: not in "
        "reserve list: connected=%d max=%d reserve=%d%s",
        host_and_ident(0), smtp_accept_count - 1, smtp_accept_max,
        smtp_accept_reserve, (rc == 1)? " (lookup deferred)" : "");
      smtp_printf("421 %s: Too many concurrent SMTP connections; "
        "please try again later\r\n", smtp_active_hostname);
      return 0;
      }
    reserved_host = 1;
    }

  /* If a load level above which only messages from reserved hosts are
  accepted is set, check the load. For incoming calls via the daemon, the
  check is done in the superior process if there are no reserved hosts, to
  save a fork. In all cases, the load average will already be available
  in a global variable at this point. */

  if (smtp_load_reserve >= 0 &&
       load_average > smtp_load_reserve &&
       !reserved_host &&
       verify_check_host(&smtp_reserve_hosts) != 0)
    {
    log_write(0x00000004,
      1, "temporarily refused connection from %s: not in "
      "reserve list and load average = %.2f", host_and_ident(0),
      (double)load_average/1000.0);
    smtp_printf("421 %s: Too much load; please try again later\r\n",
      smtp_active_hostname);
    return 0;
    }

  /* Determine whether unqualified senders or recipients are permitted
  for this host. Unfortunately, we have to do this every time, in order to
  set the flags so that they can be inspected when considering qualifying
  addresses in the headers. For a site that permits no qualification, this
  won't take long, however. */

  allow_unqualified_sender =
    verify_check_host(&sender_unqualified_hosts) == 0;

  allow_unqualified_recipient =
    verify_check_host(&recipient_unqualified_hosts) == 0;

  /* Determine whether HELO/EHLO is required for this host. The requirement
  can be hard or soft. */

  helo_required = verify_check_host(&helo_verify_hosts) == 0;
  if (!helo_required)
    helo_verify = verify_check_host(&helo_try_verify_hosts) == 0;

  /* Determine whether this hosts is permitted to send syntactic junk
  after a HELO or EHLO command. */

  helo_accept_junk = verify_check_host(&helo_accept_junk_hosts) == 0;
  }

/* For batch SMTP input we are now done. */

if (smtp_batched_input) return 1;

/* Run the ACL if it exists */

user_msg = ((void *)0);
if (acl_smtp_connect != ((void *)0))
  {
  int rc;
  rc = acl_check(ACL_WHERE_CONNECT, ((void *)0), acl_smtp_connect, &user_msg,
    &log_msg);
  if (rc != 0)
    {
    (void)smtp_handle_acl_fail(ACL_WHERE_CONNECT, rc, user_msg, log_msg);
    return 0;
    }
  }

/* Output the initial message for a two-way SMTP connection. It may contain
newlines, which then cause a multi-line response to be given. */

code = (unsigned char *)"220"; /* Default status code */
esc = (unsigned char *)""; /* Default extended status code */
esclen = 0; /* Length of esc */

if (user_msg == ((void *)0))
  {
  s = expand_string(smtp_banner);
  if (s == ((void *)0))
    log_write(0, 1|6, "Expansion of \"%s\" (smtp_banner) "
      "failed: %s", smtp_banner, expand_string_message);
  }
else
  {
  int codelen = 3;
  s = user_msg;
  smtp_message_code(&code, &codelen, &s, ((void *)0));
  if (codelen > 4)
    {
    esc = code + 4;
    esclen = codelen - 4;
    }
  }

/* Remove any terminating newlines; might as well remove trailing space too */

p = s + (int)strlen((const char *)(s));
while (p > s && ((*__ctype_b_loc ())[(int) ((p[-1]))] & (unsigned short int) _ISspace)) p--;
*p = 0;

/* It seems that CC:Mail is braindead, and assumes that the greeting message
is all contained in a single IP packet. The original code wrote out the
greeting using several calls to fprint/fputc, and on busy servers this could
cause it to be split over more than one packet - which caused CC:Mail to fall
over when it got the second part of the greeting after sending its first
command. Sigh. To try to avoid this, build the complete greeting message
first, and output it in one fell swoop. This gives a better chance of it
ending up as a single packet. */

ss = store_get_3(size, "src/smtp_in.c", 1861);
ptr = 0;

p = s;
do /* At least once, in case we have an empty string */
  {
  int len;
  uschar *linebreak = (unsigned char *) strchr((const char *)(p),'\n');
  ss = string_cat(ss, &size, &ptr, code, 3);
  if (linebreak == ((void *)0))
    {
    len = (int)strlen((const char *)(p));
    ss = string_cat(ss, &size, &ptr, (unsigned char *)" ", 1);
    }
  else
    {
    len = linebreak - p;
    ss = string_cat(ss, &size, &ptr, (unsigned char *)"-", 1);
    }
  ss = string_cat(ss, &size, &ptr, esc, esclen);
  ss = string_cat(ss, &size, &ptr, p, len);
  ss = string_cat(ss, &size, &ptr, (unsigned char *)"\r\n", 2);
  p += len;
  if (linebreak != ((void *)0)) p++;
  }
while (*p != 0);

ss[ptr] = 0; /* string_cat leaves room for this */

/* Before we write the banner, check that there is no input pending, unless
this synchronisation check is disabled. */

if (!check_sync())
  {
  log_write(0, 1|16, "SMTP protocol "
    "synchronization error (input sent without waiting for greeting): "
    "rejected connection from %s input=\"%s\"", host_and_ident(1),
    string_printing2((smtp_inptr), 1));
  smtp_printf("554 SMTP synchronization error\r\n");
  return 0;
  }

/* Now output the banner */

smtp_printf("%s", ss);
return 1;
}





/*************************************************
*     Handle SMTP syntax and protocol errors     *
*************************************************/

/* Write to the log for SMTP syntax errors in incoming commands, if configured
to do so. Then transmit the error response. The return value depends on the
number of syntax and protocol errors in this SMTP session.

Arguments:
  type      error type, given as a log flag bit
  code      response code; <= 0 means don't send a response
  data      data to reflect in the response (can be NULL)
  errmess   the error message

Returns:    -1   limit of syntax/protocol errors NOT exceeded
            +1   limit of syntax/protocol errors IS exceeded

These values fit in with the values of the "done" variable in the main
processing loop in smtp_setup_msg(). */

static int
synprot_error(int type, int code, uschar *data, uschar *errmess)
{
int yield = -1;

log_write(type, 1, "SMTP %s error in \"%s\" %s %s",
  (type == 0x00008000)? "syntax" : "protocol",
  string_printing2((smtp_cmd_buffer), 1), host_and_ident(1), errmess);

if (++synprot_error_count > smtp_max_synprot_errors)
  {
  yield = 1;
  log_write(0, 1|16, "SMTP call from %s dropped: too many "
    "syntax or protocol errors (last command was \"%s\")",
    host_and_ident(0), smtp_cmd_buffer);
  }

if (code > 0)
  {
  smtp_printf("%d%c%s%s%s\r\n", code, (yield == 1)? '-' : ' ',
    (data == ((void *)0))? (unsigned char *)"" : data, (data == ((void *)0))? (unsigned char *)"" : (unsigned char *)": ", errmess);
  if (yield == 1)
    smtp_printf("%d Too many syntax or protocol errors\r\n", code);
  }

return yield;
}




/*************************************************
*          Log incomplete transactions           *
*************************************************/

/* This function is called after a transaction has been aborted by RSET, QUIT,
connection drops or other errors. It logs the envelope information received
so far in order to preserve address verification attempts.

Argument:   string to indicate what aborted the transaction
Returns:    nothing
*/

static void
incomplete_transaction_log(uschar *what)
{
if (sender_address == ((void *)0) || /* No transaction in progress */
    (log_write_selector & 0x00002000) == 0 /* Not logging */
  ) return;

/* Build list of recipients for logging */

if (recipients_count > 0)
  {
  int i;
  raw_recipients = store_get_3(recipients_count * sizeof(uschar *), "src/smtp_in.c", 1988);
  for (i = 0; i < recipients_count; i++)
    raw_recipients[i] = recipients_list[i].address;
  raw_recipients_count = recipients_count;
  }

log_write(0x00002000, 1|32|64,
  "%s incomplete transaction (%s)", host_and_ident(1), what);
}




/*************************************************
*    Send SMTP response, possibly multiline      *
*************************************************/

/* There are, it seems, broken clients out there that cannot handle multiline
responses. If no_multiline_responses is TRUE (it can be set from an ACL), we
output nothing for non-final calls, and only the first line for anything else.

Arguments:
  code          SMTP code, may involve extended status codes
  codelen       length of smtp code; if > 4 there's an ESC
  final         FALSE if the last line isn't the final line
  msg           message text, possibly containing newlines

Returns:        nothing
*/

void
smtp_respond(uschar* code, int codelen, BOOL final, uschar *msg)
{
int esclen = 0;
uschar *esc = (unsigned char *)"";

if (!final && no_multiline_responses) return;

if (codelen > 4)
  {
  esc = code + 4;
  esclen = codelen - 4;
  }

/* If this is the first output for a (non-batch) RCPT command, see if all RCPTs
have had the same. Note: this code is also present in smtp_printf(). It would
be tidier to have it only in one place, but when it was added, it was easier to
do it that way, so as not to have to mess with the code for the RCPT command,
which sometimes uses smtp_printf() and sometimes smtp_respond(). */

if (rcpt_in_progress)
  {
  if (rcpt_smtp_response == ((void *)0))
    rcpt_smtp_response = string_copy(msg);
  else if (rcpt_smtp_response_same &&
           strcmp((const char *)(rcpt_smtp_response),(const char *)(msg)) != 0)
    rcpt_smtp_response_same = 0;
  rcpt_in_progress = 0;
  }

/* Not output the message, splitting it up into multiple lines if necessary. */

for (;;)
  {
  uschar *nl = (unsigned char *) strchr((const char *)(msg),'\n');
  if (nl == ((void *)0))
    {
    smtp_printf("%.3s%c%.*s%s\r\n", code, final? ' ':'-', esclen, esc, msg);
    return;
    }
  else if (nl[1] == 0 || no_multiline_responses)
    {
    smtp_printf("%.3s%c%.*s%.*s\r\n", code, final? ' ':'-', esclen, esc,
      (int)(nl - msg), msg);
    return;
    }
  else
    {
    smtp_printf("%.3s-%.*s%.*s\r\n", code, esclen, esc, (int)(nl - msg), msg);
    msg = nl + 1;
    while (((*__ctype_b_loc ())[(int) ((*msg))] & (unsigned short int) _ISspace)) msg++;
    }
  }
}




/*************************************************
*            Parse user SMTP message             *
*************************************************/

/* This function allows for user messages overriding the response code details
by providing a suitable response code string at the start of the message
user_msg. Check the message for starting with a response code and optionally an
extended status code. If found, check that the first digit is valid, and if so,
change the code pointer and length to use the replacement. An invalid code
causes a panic log; in this case, if the log messages is the same as the user
message, we must also adjust the value of the log message to show the code that
is actually going to be used (the original one).

This function is global because it is called from receive.c as well as within
this module.

Note that the code length returned includes the terminating whitespace
character, which is always included in the regex match.

Arguments:
  code          SMTP code, may involve extended status codes
  codelen       length of smtp code; if > 4 there's an ESC
  msg           message text
  log_msg       optional log message, to be adjusted with the new SMTP code

Returns:        nothing
*/

void
smtp_message_code(uschar **code, int *codelen, uschar **msg, uschar **log_msg)
{
int n;
int ovector[3];

if (msg == ((void *)0) || *msg == ((void *)0)) return;

n = pcre_exec(regex_smtp_code, ((void *)0), (char *) *msg, (int)strlen((const char *)(*msg)), 0,
  0, ovector, sizeof(ovector)/sizeof(int));
if (n < 0) return;

if ((*msg)[0] != (*code)[0])
  {
  log_write(0, 1|2, "configured error code starts with "
    "incorrect digit (expected %c) in \"%s\"", (*code)[0], *msg);
  if (log_msg != ((void *)0) && *log_msg == *msg)
    *log_msg = string_sprintf("%s %s", *code, *log_msg + ovector[1]);
  }
else
  {
  *code = *msg;
  *codelen = ovector[1]; /* Includes final space */
  }
*msg += ovector[1]; /* Chop the code off the message */
return;
}




/*************************************************
*           Handle an ACL failure                *
*************************************************/

/* This function is called when acl_check() fails. As well as calls from within
this module, it is called from receive.c for an ACL after DATA. It sorts out
logging the incident, and sets up the error response. A message containing
newlines is turned into a multiline SMTP response, but for logging, only the
first line is used.

There's a table of default permanent failure response codes to use in
globals.c, along with the table of names. VFRY is special. Despite RFC1123 it
defaults disabled in Exim. However, discussion in connection with RFC 821bis
(aka RFC 2821) has concluded that the response should be 252 in the disabled
state, because there are broken clients that try VRFY before RCPT. A 5xx
response should be given only when the address is positively known to be
undeliverable. Sigh. Also, for ETRN, 458 is given on refusal, and for AUTH,
503.

From Exim 4.63, it is possible to override the response code details by
providing a suitable response code string at the start of the message provided
in user_msg. The code's first digit is checked for validity.

Arguments:
  where      where the ACL was called from
  rc         the failure code
  user_msg   a message that can be included in an SMTP response
  log_msg    a message for logging

Returns:     0 in most cases
             2 if the failure code was FAIL_DROP, in which case the
               SMTP connection should be dropped (this value fits with the
               "done" variable in smtp_setup_msg() below)
*/

int
smtp_handle_acl_fail(int where, int rc, uschar *user_msg, uschar *log_msg)
{
BOOL drop = rc == 15;
int codelen = 3;
uschar *smtp_code;
uschar *lognl;
uschar *sender_info = (unsigned char *)"";
uschar *what =



  (where == ACL_WHERE_PREDATA)? (unsigned char *)"DATA" :
  (where == ACL_WHERE_DATA)? (unsigned char *)"after DATA" :
  (smtp_cmd_data == ((void *)0))?
    string_sprintf("%s in \"connect\" ACL", acl_wherenames[where]) :
    string_sprintf("%s %s", acl_wherenames[where], smtp_cmd_data);

if (drop) rc = 2;

/* Set the default SMTP code, and allow a user message to change it. */

smtp_code = (rc != 2)? (unsigned char *)"451" : acl_wherecodes[where];
smtp_message_code(&smtp_code, &codelen, &user_msg, &log_msg);

/* We used to have sender_address here; however, there was a bug that was not
updating sender_address after a rewrite during a verify. When this bug was
fixed, sender_address at this point became the rewritten address. I'm not sure
this is what should be logged, so I've changed to logging the unrewritten
address to retain backward compatibility. */


if (where == ACL_WHERE_RCPT || where == ACL_WHERE_DATA)



  {
  sender_info = string_sprintf("F=<%s>%s%s%s%s ",
    sender_address_unrewritten ? sender_address_unrewritten : sender_address,
    sender_host_authenticated ? (unsigned char *)" A=" : (unsigned char *)"",
    sender_host_authenticated ? sender_host_authenticated : (unsigned char *)"",
    sender_host_authenticated && authenticated_id ? (unsigned char *)":" : (unsigned char *)"",
    sender_host_authenticated && authenticated_id ? authenticated_id : (unsigned char *)""
    );
  }

/* If there's been a sender verification failure with a specific message, and
we have not sent a response about it yet, do so now, as a preliminary line for
failures, but not defers. However, always log it for defer, and log it for fail
unless the sender_verify_fail log selector has been turned off. */

if (sender_verified_failed != ((void *)0) &&
    !((sender_verified_failed->flags & (0x00020000)) != 0))
  {
  BOOL save_rcpt_in_progress = rcpt_in_progress;
  rcpt_in_progress = 0; /* So as not to treat these as the error */

  sender_verified_failed->flags |= (0x00020000);

  if (rc != 2 || (log_extra_selector & 0x80010000) != 0)
    log_write(0, 1|16, "%s sender verify %s for <%s>%s",
      host_and_ident(1),
      ((sender_verified_failed->special_action & 255) == 1)? "defer":"fail",
      sender_verified_failed->address,
      (sender_verified_failed->message == ((void *)0))? (unsigned char *)"" :
      string_sprintf(": %s", sender_verified_failed->message));

  if (rc == 2 && sender_verified_failed->user_message != ((void *)0))
    smtp_respond(smtp_code, codelen, 0, string_sprintf(
        ((sender_verified_failed->flags & (0x00040000)) != 0)?
          "Postmaster verification failed while checking <%s>\n%s\n"
          "Several RFCs state that you are required to have a postmaster\n"
          "mailbox for each mail domain. This host does not accept mail\n"
          "from domains whose servers reject the postmaster address."
          :
        ((sender_verified_failed->flags & (0x00080000)) != 0)?
          "Callback setup failed while verifying <%s>\n%s\n"
          "The initial connection, or a HELO or MAIL FROM:<> command was\n"
          "rejected. Refusing MAIL FROM:<> does not help fight spam, disregards\n"
          "RFC requirements, and stops you from receiving standard bounce\n"
          "messages. This host does not accept mail from domains whose servers\n"
          "refuse bounces."
          :
          "Verification failed for <%s>\n%s",
        sender_verified_failed->address,
        sender_verified_failed->user_message));

  rcpt_in_progress = save_rcpt_in_progress;
  }

/* Sort out text for logging */

log_msg = (log_msg == ((void *)0))? (unsigned char *)"" : string_sprintf(": %s", log_msg);
lognl = (unsigned char *) strchr((const char *)(log_msg),'\n');
if (lognl != ((void *)0)) *lognl = 0;

/* Send permanent failure response to the command, but the code used isn't
always a 5xx one - see comments at the start of this function. If the original
rc was FAIL_DROP we drop the connection and yield 2. */

if (rc == 2) smtp_respond(smtp_code, codelen, 1, (user_msg == ((void *)0))?
  (unsigned char *)"Administrative prohibition" : user_msg);

/* Send temporary failure response to the command. Don't give any details,
unless acl_temp_details is set. This is TRUE for a callout defer, a "defer"
verb, and for a header verify when smtp_return_error_details is set.

This conditional logic is all somewhat of a mess because of the odd
interactions between temp_details and return_error_details. One day it should
be re-implemented in a tidier fashion. */

else
  {
  if (acl_temp_details && user_msg != ((void *)0))
    {
    if (smtp_return_error_details &&
        sender_verified_failed != ((void *)0) &&
        sender_verified_failed->message != ((void *)0))
      {
      smtp_respond(smtp_code, codelen, 0, sender_verified_failed->message);
      }
    smtp_respond(smtp_code, codelen, 1, user_msg);
    }
  else
    smtp_respond(smtp_code, codelen, 1,
      (unsigned char *)"Temporary local problem - please try later");
  }

/* Log the incident to the logs that are specified by log_reject_target
(default main, reject). This can be empty to suppress logging of rejections. If
the connection is not forcibly to be dropped, return 0. Otherwise, log why it
is closing if required and return 2.  */

if (log_reject_target != 0)
  log_write(0, log_reject_target, "%s %s%srejected %s%s",
    host_and_ident(1),
    sender_info, (rc == 2)? (unsigned char *)"" : (unsigned char *)"temporarily ", what, log_msg);

if (!drop) return 0;

log_write(0x00001000, 1, "%s closed by DROP in ACL",
  smtp_get_connection_info());

/* Run the not-quit ACL, but without any custom messages. This should not be a
problem, because we get here only if some other ACL has issued "drop", and
in that case, *its* custom messages will have been used above. */

smtp_notquit_exit((unsigned char *)"acl-drop", ((void *)0), ((void *)0));
return 2;
}




/*************************************************
*     Handle SMTP exit when QUIT is not given    *
*************************************************/

/* This function provides a logging/statistics hook for when an SMTP connection
is dropped on the floor or the other end goes away. It's a global function
because it's called from receive.c as well as this module. As well as running
the NOTQUIT ACL, if there is one, this function also outputs a final SMTP
response, either with a custom message from the ACL, or using a default. There
is one case, however, when no message is output - after "drop". In that case,
the ACL that obeyed "drop" has already supplied the custom message, and NULL is
passed to this function.

In case things go wrong while processing this function, causing an error that
may re-enter this funtion, there is a recursion check.

Arguments:
  reason          What $smtp_notquit_reason will be set to in the ACL;
                    if NULL, the ACL is not run
  code            The error code to return as part of the response
  defaultrespond  The default message if there's no user_msg

Returns:          Nothing
*/

void
smtp_notquit_exit(uschar *reason, uschar *code, uschar *defaultrespond, ...)
{
int rc;
uschar *user_msg = ((void *)0);
uschar *log_msg = ((void *)0);

/* Check for recursive acll */

if (smtp_exit_function_called)
  {
  log_write(0, 2, "smtp_notquit_exit() called more than once (%s)",
    reason);
  return;
  }
smtp_exit_function_called = 1;

/* Call the not-QUIT ACL, if there is one, unless no reason is given. */

if (acl_smtp_notquit != ((void *)0) && reason != ((void *)0))
  {
  smtp_notquit_reason = reason;
  rc = acl_check(ACL_WHERE_NOTQUIT, ((void *)0), acl_smtp_notquit, &user_msg,
    &log_msg);
  if (rc == 3)
    log_write(0, 1|2, "ACL for not-QUIT returned ERROR: %s",
      log_msg);
  }

/* Write an SMTP response if we are expected to give one. As the default
responses are all internal, they should always fit in the buffer, but code a
warning, just in case. Note that string_vformat() still leaves a complete
string, even if it is incomplete. */

if (code != ((void *)0) && defaultrespond != ((void *)0))
  {
  if (user_msg == ((void *)0))
    {
    uschar buffer[128];
    va_list ap;
    __builtin_va_start(ap,defaultrespond);
    if (!string_vformat(buffer, sizeof(buffer), (char *) defaultrespond, ap))
      log_write(0, 1|2, "string too large in smtp_notquit_exit()");
    smtp_printf("%s %s\r\n", code, buffer);
    __builtin_va_end(ap);
    }
  else
    smtp_respond(code, 3, 1, user_msg);
  fflush(smtp_out);;
  }
}




/*************************************************
*             Verify HELO argument               *
*************************************************/

/* This function is called if helo_verify_hosts or helo_try_verify_hosts is
matched. It is also called from ACL processing if verify = helo is used and
verification was not previously tried (i.e. helo_try_verify_hosts was not
matched). The result of its processing is to set helo_verified and
helo_verify_failed. These variables should both be FALSE for this function to
be called.

Note that EHLO/HELO is legitimately allowed to quote an address literal. Allow
for IPv6 ::ffff: literals.

Argument:   none
Returns:    TRUE if testing was completed;
            FALSE on a temporary failure
*/

BOOL
smtp_verify_helo(void)
{
BOOL yield = 1;

if (host_checking || (debug_selector & (0x00200000)) != 0) debug_printf("verifying EHLO/HELO argument \"%s\"\n",
  sender_helo_name);

if (sender_helo_name == ((void *)0))
  {
  if (host_checking || (debug_selector & (0x00200000)) != 0) debug_printf("no EHLO/HELO command was issued\n");
  }

/* Deal with the case of -bs without an IP address */

else if (sender_host_address == ((void *)0))
  {
  if (host_checking || (debug_selector & (0x00200000)) != 0) debug_printf("no client IP address: assume success\n");
  helo_verified = 1;
  }

/* Deal with the more common case when there is a sending IP address */

else if (sender_helo_name[0] == '[')
  {
  helo_verified = strncmp((const char *)(sender_helo_name+1),(const char *)(sender_host_address),(int)strlen((const char *)(sender_host_address)))
                                  == 0;
# 2460 "src/smtp_in.c"
  if (host_checking || (debug_selector & (0x00200000)) != 0)
    { if (helo_verified) debug_printf("matched host address\n"); }
  }

/* Do a reverse lookup if one hasn't already given a positive or negative
response. If that fails, or the name doesn't match, try checking with a forward
lookup. */

else
  {
  if (sender_host_name == ((void *)0) && !host_lookup_failed)
    yield = host_name_lookup() != 1;

  /* If a host name is known, check it and all its aliases. */

  if (sender_host_name != ((void *)0))
    {
    helo_verified = strcmpic(sender_host_name, sender_helo_name) == 0;

    if (helo_verified)
      {
      if (host_checking || (debug_selector & (0x00200000)) != 0) debug_printf("matched host name\n");
      }
    else
      {
      uschar **aliases = sender_host_aliases;
      while (*aliases != ((void *)0))
        {
        helo_verified = strcmpic(*aliases++, sender_helo_name) == 0;
        if (helo_verified) break;
        }
      if (host_checking || (debug_selector & (0x00200000)) != 0)
        {
        if (helo_verified)
          debug_printf("matched alias %s\n", *(--aliases));
        }
      }
    }

  /* Final attempt: try a forward lookup of the helo name */

  if (!helo_verified)
    {
    int rc;
    host_item h;
    h.name = sender_helo_name;
    h.address = ((void *)0);
    h.mx = (-1);
    h.next = ((void *)0);
    if (host_checking || (debug_selector & (0x00200000)) != 0) debug_printf("getting IP address for %s\n",
      sender_helo_name);
    rc = host_find_byname(&h, ((void *)0), 0, ((void *)0), 1);
    if (rc == HOST_FOUND || rc == HOST_FOUND_LOCAL)
      {
      host_item *hh = &h;
      while (hh != ((void *)0))
        {
        if (strcmp((const char *)(hh->address),(const char *)(sender_host_address)) == 0)
          {
          helo_verified = 1;
          if (host_checking || (debug_selector & (0x00200000)) != 0)
            debug_printf("IP address for %s matches calling address\n",
              sender_helo_name);
          break;
          }
        hh = hh->next;
        }
      }
    }
  }

if (!helo_verified) helo_verify_failed = 1; /* We've tried ... */
return yield;
}




/*************************************************
*        Send user response message              *
*************************************************/

/* This function is passed a default response code and a user message. It calls
smtp_message_code() to check and possibly modify the response code, and then
calls smtp_respond() to transmit the response. I put this into a function
just to avoid a lot of repetition.

Arguments:
  code         the response code
  user_msg     the user message

Returns:       nothing
*/

static void
smtp_user_msg(uschar *code, uschar *user_msg)
{
int len = 3;
smtp_message_code(&code, &len, &user_msg, ((void *)0));
smtp_respond(code, len, 1, user_msg);
}




/*************************************************
*       Initialize for SMTP incoming message     *
*************************************************/

/* This function conducts the initial dialogue at the start of an incoming SMTP
message, and builds a list of recipients. However, if the incoming message
is part of a batch (-bS option) a separate function is called since it would
be messy having tests splattered about all over this function. This function
therefore handles the case where interaction is occurring. The input and output
files are set up in smtp_in and smtp_out.

The global recipients_list is set to point to a vector of recipient_item
blocks, whose number is given by recipients_count. This is extended by the
receive_add_recipient() function. The global variable sender_address is set to
the sender's address. The yield is +1 if a message has been successfully
started, 0 if a QUIT command was encountered or the connection was refused from
the particular host, or -1 if the connection was lost.

Argument: none

Returns:  > 0 message successfully started (reached DATA)
          = 0 QUIT read or end of file reached or call refused
          < 0 lost connection
*/

int
smtp_setup_msg(void)
{
int done = 0;
BOOL toomany = 0;
BOOL discarded = 0;
BOOL last_was_rej_mail = 0;
BOOL last_was_rcpt = 0;
void *reset_point = store_get_3(0, "src/smtp_in.c", 2598);

if ((debug_selector & (0x00200000)) != 0) debug_printf("smtp_setup_msg entered\n");

/* Reset for start of new message. We allow one RSET not to be counted as a
nonmail command, for those MTAs that insist on sending it between every
message. Ditto for EHLO/HELO and for STARTTLS, to allow for going in and out of
TLS between messages (an Exim client may do this if it has messages queued up
for the host). Note: we do NOT reset AUTH at this point. */

smtp_reset(reset_point);
message_ended = 0;

cmd_list[0].is_mail_cmd = 1;
cmd_list[1].is_mail_cmd = 1;
cmd_list[2].is_mail_cmd = 1;




/* Set the local signal handler for SIGTERM - it tries to end off tidily */

os_non_restarting_signal(15, command_sigterm_handler);

/* Batched SMTP is handled in a different function. */

if (smtp_batched_input) return smtp_setup_batch_msg();

/* Deal with SMTP commands. This loop is exited by setting done to a POSITIVE
value. The values are 2 larger than the required yield of the function. */

while (done <= 0)
  {
  uschar **argv;
  uschar *etrn_command;
  uschar *etrn_serialize_key;
  uschar *errmess;
  uschar *log_msg, *smtp_code;
  uschar *user_msg = ((void *)0);
  uschar *recipient = ((void *)0);
  uschar *hello = ((void *)0);
  uschar *set_id = ((void *)0);
  uschar *s, *ss;
  BOOL was_rej_mail = 0;
  BOOL was_rcpt = 0;
  void (*oldsignal)(int);
  pid_t pid;
  int start, end, sender_domain, recipient_domain;
  int ptr, size, rc;
  int c, i;
  auth_instance *au;

  switch(smtp_read_command(1))
    {
    /* The AUTH command is not permitted to occur inside a transaction, and may
    occur successfully only once per connection. Actually, that isn't quite
    true. When TLS is started, all previous information about a connection must
    be discarded, so a new AUTH is permitted at that time.

    AUTH may only be used when it has been advertised. However, it seems that
    there are clients that send AUTH when it hasn't been advertised, some of
    them even doing this after HELO. And there are MTAs that accept this. Sigh.
    So there's a get-out that allows this to happen.

    AUTH is initially labelled as a "nonmail command" so that one occurrence
    doesn't get counted. We change the label here so that multiple failing
    AUTHS will eventually hit the nonmail threshold. */

    case AUTH_CMD:
    smtp_connection_had[smtp_ch_index++] = SCH_AUTH; if (smtp_ch_index >= 20) smtp_ch_index = 0;
    authentication_failed = 1;
    cmd_list[3].is_mail_cmd = 0;

    if (!auth_advertised && !allow_auth_unadvertised)
      {
      done = synprot_error(0x00004000, 503, ((void *)0),
        (unsigned char *)"AUTH command used when not advertised");
      break;
      }
    if (sender_host_authenticated != ((void *)0))
      {
      done = synprot_error(0x00004000, 503, ((void *)0),
        (unsigned char *)"already authenticated");
      break;
      }
    if (sender_address != ((void *)0))
      {
      done = synprot_error(0x00004000, 503, ((void *)0),
        (unsigned char *)"not permitted in mail transaction");
      break;
      }

    /* Check the ACL */

    if (acl_smtp_auth != ((void *)0))
      {
      rc = acl_check(ACL_WHERE_AUTH, ((void *)0), acl_smtp_auth, &user_msg, &log_msg);
      if (rc != 0)
        {
        done = smtp_handle_acl_fail(ACL_WHERE_AUTH, rc, user_msg, log_msg);
        break;
        }
      }

    /* Find the name of the requested authentication mechanism. */

    s = smtp_cmd_data;
    while ((c = *smtp_cmd_data) != 0 && !((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISspace))
      {
      if (!((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISalnum) && c != '-' && c != '_')
        {
        done = synprot_error(0x00008000, 501, ((void *)0),
          (unsigned char *)"invalid character in authentication mechanism name");
        goto COMMAND_LOOP;
        }
      smtp_cmd_data++;
      }

    /* If not at the end of the line, we must be at white space. Terminate the
    name and move the pointer on to any data that may be present. */

    if (*smtp_cmd_data != 0)
      {
      *smtp_cmd_data++ = 0;
      while (((*__ctype_b_loc ())[(int) ((*smtp_cmd_data))] & (unsigned short int) _ISspace)) smtp_cmd_data++;
      }

    /* Search for an authentication mechanism which is configured for use
    as a server and which has been advertised (unless, sigh, allow_auth_
    unadvertised is set). */

    for (au = auths; au != ((void *)0); au = au->next)
      {
      if (strcmpic(s, au->public_name) == 0 && au->server &&
          (au->advertised || allow_auth_unadvertised)) break;
      }

    if (au == ((void *)0))
      {
      done = synprot_error(0x00004000, 504, ((void *)0),
        string_sprintf("%s authentication mechanism not supported", s));
      break;
      }

    /* Run the checking code, passing the remainder of the command line as
    data. Initials the $auth<n> variables as empty. Initialize $0 empty and set
    it as the only set numerical variable. The authenticator may set $auth<n>
    and also set other numeric variables. The $auth<n> variables are preferred
    nowadays; the numerical variables remain for backwards compatibility.

    Afterwards, have a go at expanding the set_id string, even if
    authentication failed - for bad passwords it can be useful to log the
    userid. On success, require set_id to expand and exist, and put it in
    authenticated_id. Save this in permanent store, as the working store gets
    reset at HELO, RSET, etc. */

    for (i = 0; i < 3; i++) auth_vars[i] = ((void *)0);
    expand_nmax = 0;
    expand_nlength[0] = 0; /* $0 contains nothing */

    c = (au->info->servercode)(au, smtp_cmd_data);
    if (au->set_id != ((void *)0)) set_id = expand_string(au->set_id);
    expand_nmax = -1; /* Reset numeric variables */
    for (i = 0; i < 3; i++) auth_vars[i] = ((void *)0); /* Reset $auth<n> */

    /* The value of authenticated_id is stored in the spool file and printed in
    log lines. It must not contain binary zeros or newline characters. In
    normal use, it never will, but when playing around or testing, this error
    can (did) happen. To guard against this, ensure that the id contains only
    printing characters. */

    if (set_id != ((void *)0)) set_id = string_printing2((set_id), 1);

    /* For the non-OK cases, set up additional logging data if set_id
    is not empty. */

    if (c != 0)
      {
      if (set_id != ((void *)0) && *set_id != 0)
        set_id = string_sprintf(" (set_id=%s)", set_id);
      else set_id = (unsigned char *)"";
      }

    /* Switch on the result */

    switch(c)
      {
      case 0:
      if (au->set_id == ((void *)0) || set_id != ((void *)0)) /* Complete success */
        {
        if (set_id != ((void *)0)) authenticated_id = string_copy_malloc(set_id);
        sender_host_authenticated = au->name;
        authentication_failed = 0;
        received_protocol =
          protocols[2 + 2 + ((tls_active >= 0)? 1:0)] +
            ((sender_host_address != ((void *)0))? 6 : 0);
        s = ss = (unsigned char *)"235 Authentication succeeded";
        authenticated_by = au;
        break;
        }

      /* Authentication succeeded, but we failed to expand the set_id string.
      Treat this as a temporary error. */

      auth_defer_msg = expand_string_message;
      /* Fall through */

      case 1:
      s = string_sprintf("435 Unable to authenticate at present%s",
        auth_defer_user_msg);
      ss = string_sprintf("435 Unable to authenticate at present%s: %s",
        set_id, auth_defer_msg);
      break;

      case 11:
      s = ss = (unsigned char *)"501 Invalid base64 data";
      break;

      case 13:
      s = ss = (unsigned char *)"501 Authentication cancelled";
      break;

      case 12:
      s = ss = (unsigned char *)"553 Initial data not expected";
      break;

      case 2:
      s = (unsigned char *)"535 Incorrect authentication data";
      ss = string_sprintf("535 Incorrect authentication data%s", set_id);
      break;

      default:
      s = (unsigned char *)"435 Internal error";
      ss = string_sprintf("435 Internal error%s: return %d from authentication "
        "check", set_id, c);
      break;
      }

    smtp_printf("%s\r\n", s);
    if (c != 0)
      log_write(0, 1|16, "%s authenticator failed for %s: %s",
        au->name, host_and_ident(0), ss);

    break; /* AUTH_CMD */

    /* The HELO/EHLO commands are permitted to appear in the middle of a
    session as well as at the beginning. They have the effect of a reset in
    addition to their other functions. Their absence at the start cannot be
    taken to be an error.

    RFC 2821 says:

      If the EHLO command is not acceptable to the SMTP server, 501, 500,
      or 502 failure replies MUST be returned as appropriate.  The SMTP
      server MUST stay in the same state after transmitting these replies
      that it was in before the EHLO was received.

    Therefore, we do not do the reset until after checking the command for
    acceptability. This change was made for Exim release 4.11. Previously
    it did the reset first. */

    case HELO_CMD:
    smtp_connection_had[smtp_ch_index++] = SCH_HELO; if (smtp_ch_index >= 20) smtp_ch_index = 0;
    hello = (unsigned char *)"HELO";
    esmtp = 0;
    goto HELO_EHLO;

    case EHLO_CMD:
    smtp_connection_had[smtp_ch_index++] = SCH_EHLO; if (smtp_ch_index >= 20) smtp_ch_index = 0;
    hello = (unsigned char *)"EHLO";
    esmtp = 1;

    HELO_EHLO: /* Common code for HELO and EHLO */
    cmd_list[1].is_mail_cmd = 0;
    cmd_list[2].is_mail_cmd = 0;

    /* Reject the HELO if its argument was invalid or non-existent. A
    successful check causes the argument to be saved in malloc store. */

    if (!check_helo(smtp_cmd_data))
      {
      smtp_printf("501 Syntactically invalid %s argument(s)\r\n", hello);

      log_write(0, 1|16, "rejected %s from %s: syntactically "
        "invalid argument(s): %s", hello, host_and_ident(0),
        (*smtp_cmd_argument == 0)? (unsigned char *)"(no argument given)" :
                           string_printing2((smtp_cmd_argument), 1));

      if (++synprot_error_count > smtp_max_synprot_errors)
        {
        log_write(0, 1|16, "SMTP call from %s dropped: too many "
          "syntax or protocol errors (last command was \"%s\")",
          host_and_ident(0), smtp_cmd_buffer);
        done = 1;
        }

      break;
      }

    /* If sender_host_unknown is true, we have got here via the -bs interface,
    not called from inetd. Otherwise, we are running an IP connection and the
    host address will be set. If the helo name is the primary name of this
    host and we haven't done a reverse lookup, force one now. If helo_required
    is set, ensure that the HELO name matches the actual host. If helo_verify
    is set, do the same check, but softly. */

    if (!sender_host_unknown)
      {
      BOOL old_helo_verified = helo_verified;
      uschar *p = smtp_cmd_data;

      while (*p != 0 && !((*__ctype_b_loc ())[(int) ((*p))] & (unsigned short int) _ISspace)) { *p = tolower(*p); p++; }
      *p = 0;

      /* Force a reverse lookup if HELO quoted something in helo_lookup_domains
      because otherwise the log can be confusing. */

      if (sender_host_name == ((void *)0) &&
           (deliver_domain = sender_helo_name, /* set $domain */
            match_isinlist(sender_helo_name, &helo_lookup_domains, 0,
              &domainlist_anchor, ((void *)0), MCL_DOMAIN, 1, ((void *)0))) == 0)
        (void)host_name_lookup();

      /* Rebuild the fullhost info to include the HELO name (and the real name
      if it was looked up.) */

      host_build_sender_fullhost(); /* Rebuild */
      set_process_info("handling%s incoming connection from %s",
        (tls_active >= 0)? " TLS" : "", host_and_ident(0));

      /* Verify if configured. This doesn't give much security, but it does
      make some people happy to be able to do it. If helo_required is set,
      (host matches helo_verify_hosts) failure forces rejection. If helo_verify
      is set (host matches helo_try_verify_hosts), it does not. This is perhaps
      now obsolescent, since the verification can now be requested selectively
      at ACL time. */

      helo_verified = helo_verify_failed = 0;
      if (helo_required || helo_verify)
        {
        BOOL tempfail = !smtp_verify_helo();
        if (!helo_verified)
          {
          if (helo_required)
            {
            smtp_printf("%d %s argument does not match calling host\r\n",
              tempfail? 451 : 550, hello);
            log_write(0, 1|16, "%srejected \"%s %s\" from %s",
              tempfail? "temporarily " : "",
              hello, sender_helo_name, host_and_ident(0));
            helo_verified = old_helo_verified;
            break; /* End of HELO/EHLO processing */
            }
          if (host_checking || (debug_selector & (0xffffffff)) != 0) debug_printf("%s verification failed but host is in "
            "helo_try_verify_hosts\n", hello);
          }
        }
      }






    /* Apply an ACL check if one is defined; afterwards, recheck
    synchronization in case the client started sending in a delay. */

    if (acl_smtp_helo != ((void *)0))
      {
      rc = acl_check(ACL_WHERE_HELO, ((void *)0), acl_smtp_helo, &user_msg, &log_msg);
      if (rc != 0)
        {
        done = smtp_handle_acl_fail(ACL_WHERE_HELO, rc, user_msg, log_msg);
        sender_helo_name = ((void *)0);
        host_build_sender_fullhost(); /* Rebuild */
        break;
        }
      else if (!check_sync()) goto SYNC_FAILURE;
      }

    /* Generate an OK reply. The default string includes the ident if present,
    and also the IP address if present. Reflecting back the ident is intended
    as a deterrent to mail forgers. For maximum efficiency, and also because
    some broken systems expect each response to be in a single packet, arrange
    that the entire reply is sent in one write(). */

    auth_advertised = 0;
    pipelining_advertised = 0;




    smtp_code = (unsigned char *)"250 "; /* Default response code plus space*/
    if (user_msg == ((void *)0))
      {
      s = string_sprintf("%.3s %s Hello %s%s%s",
        smtp_code,
        smtp_active_hostname,
        (sender_ident == ((void *)0))? (unsigned char *)"" : sender_ident,
        (sender_ident == ((void *)0))? (unsigned char *)"" : (unsigned char *)" at ",
        (sender_host_name == ((void *)0))? sender_helo_name : sender_host_name);

      ptr = (int)strlen((const char *)(s));
      size = ptr + 1;

      if (sender_host_address != ((void *)0))
        {
        s = string_cat(s, &size, &ptr, (unsigned char *)" [", 2);
        s = string_cat(s, &size, &ptr, sender_host_address,
          (int)strlen((const char *)(sender_host_address)));
        s = string_cat(s, &size, &ptr, (unsigned char *)"]", 1);
        }
      }

    /* A user-supplied EHLO greeting may not contain more than one line. Note
    that the code returned by smtp_message_code() includes the terminating
    whitespace character. */

    else
      {
      char *ss;
      int codelen = 4;
      smtp_message_code(&smtp_code, &codelen, &user_msg, ((void *)0));
      s = string_sprintf("%.*s%s", codelen, smtp_code, user_msg);
      if ((ss = strpbrk((char *) s, "\r\n")) != ((void *)0))
        {
        log_write(0, 1|2, "EHLO/HELO response must not contain "
          "newlines: message truncated: %s", string_printing2((s), 1));
        *ss = 0;
        }
      ptr = (int)strlen((const char *)(s));
      size = ptr + 1;
      }

    s = string_cat(s, &size, &ptr, (unsigned char *)"\r\n", 2);

    /* If we received EHLO, we must create a multiline response which includes
    the functions supported. */

    if (esmtp)
      {
      s[3] = '-';

      /* I'm not entirely happy with this, as an MTA is supposed to check
      that it has enough room to accept a message of maximum size before
      it sends this. However, there seems little point in not sending it.
      The actual size check happens later at MAIL FROM time. By postponing it
      till then, VRFY and EXPN can be used after EHLO when space is short. */

      if (thismessage_size_limit > 0)
        {
        sprintf((char *) big_buffer, "%.3s-SIZE %d\r\n", smtp_code,
          thismessage_size_limit);
        s = string_cat(s, &size, &ptr, big_buffer, (int)strlen((const char *)(big_buffer)));
        }
      else
        {
        s = string_cat(s, &size, &ptr, smtp_code, 3);
        s = string_cat(s, &size, &ptr, (unsigned char *)"-SIZE\r\n", 7);
        }

      /* Exim does not do protocol conversion or data conversion. It is 8-bit
      clean; if it has an 8-bit character in its hand, it just sends it. It
      cannot therefore specify 8BITMIME and remain consistent with the RFCs.
      However, some users want this option simply in order to stop MUAs
      mangling messages that contain top-bit-set characters. It is therefore
      provided as an option. */

      if (accept_8bitmime)
        {
        s = string_cat(s, &size, &ptr, smtp_code, 3);
        s = string_cat(s, &size, &ptr, (unsigned char *)"-8BITMIME\r\n", 11);
        }

      /* Advertise ETRN if there's an ACL checking whether a host is
      permitted to issue it; a check is made when any host actually tries. */

      if (acl_smtp_etrn != ((void *)0))
        {
        s = string_cat(s, &size, &ptr, smtp_code, 3);
        s = string_cat(s, &size, &ptr, (unsigned char *)"-ETRN\r\n", 7);
        }

      /* Advertise EXPN if there's an ACL checking whether a host is
      permitted to issue it; a check is made when any host actually tries. */

      if (acl_smtp_expn != ((void *)0))
        {
        s = string_cat(s, &size, &ptr, smtp_code, 3);
        s = string_cat(s, &size, &ptr, (unsigned char *)"-EXPN\r\n", 7);
        }

      /* Exim is quite happy with pipelining, so let the other end know that
      it is safe to use it, unless advertising is disabled. */

      if (pipelining_enable &&
          verify_check_host(&pipelining_advertise_hosts) == 0)
        {
        s = string_cat(s, &size, &ptr, smtp_code, 3);
        s = string_cat(s, &size, &ptr, (unsigned char *)"-PIPELINING\r\n", 13);
        sync_cmd_limit = NON_SYNC_CMD_PIPELINING;
        pipelining_advertised = 1;
        }

      /* If any server authentication mechanisms are configured, advertise
      them if the current host is in auth_advertise_hosts. The problem with
      advertising always is that some clients then require users to
      authenticate (and aren't configurable otherwise) even though it may not
      be necessary (e.g. if the host is in host_accept_relay).

      RFC 2222 states that SASL mechanism names contain only upper case
      letters, so output the names in upper case, though we actually recognize
      them in either case in the AUTH command. */

      if (auths != ((void *)0))
        {
        if (verify_check_host(&auth_advertise_hosts) == 0)
          {
          auth_instance *au;
          BOOL first = 1;
          for (au = auths; au != ((void *)0); au = au->next)
            {
            if (au->server && (au->advertise_condition == ((void *)0) ||
                expand_check_condition(au->advertise_condition, au->name,
                (unsigned char *)"authenticator")))
              {
              int saveptr;
              if (first)
                {
                s = string_cat(s, &size, &ptr, smtp_code, 3);
                s = string_cat(s, &size, &ptr, (unsigned char *)"-AUTH", 5);
                first = 0;
                auth_advertised = 1;
                }
              saveptr = ptr;
              s = string_cat(s, &size, &ptr, (unsigned char *)" ", 1);
              s = string_cat(s, &size, &ptr, au->public_name,
                (int)strlen((const char *)(au->public_name)));
              while (++saveptr < ptr) s[saveptr] = toupper(s[saveptr]);
              au->advertised = 1;
              }
            else au->advertised = 0;
            }
          if (!first) s = string_cat(s, &size, &ptr, (unsigned char *)"\r\n", 2);
          }
        }

      /* Advertise TLS (Transport Level Security) aka SSL (Secure Socket Layer)
      if it has been included in the binary, and the host matches
      tls_advertise_hosts. We must *not* advertise if we are already in a
      secure connection. */
# 3160 "src/smtp_in.c"
      /* Finish off the multiline reply with one that is always available. */

      s = string_cat(s, &size, &ptr, smtp_code, 3);
      s = string_cat(s, &size, &ptr, (unsigned char *)" HELP\r\n", 7);
      }

    /* Terminate the string (for debug), write it, and note that HELO/EHLO
    has been seen. */

    s[ptr] = 0;





    (void)fwrite(s, 1, ptr, smtp_out);
    if ((debug_selector & (0x00200000)) != 0)
      {
      uschar *cr;
      while ((cr = (unsigned char *) strchr((const char *)(s),'\r')) != ((void *)0)) /* lose CRs */
        memmove(cr, cr + 1, (ptr--) - (cr - s));
      debug_printf("SMTP>> %s", s);
      }
    helo_seen = 1;

    /* Reset the protocol and the state, abandoning any previous message. */

    received_protocol = (esmtp?
      protocols[2 +
        ((sender_host_authenticated != ((void *)0))? 2 : 0) +
        ((tls_active >= 0)? 1 : 0)]
      :
      protocols[0 + ((tls_active >= 0)? 1 : 0)])
      +
      ((sender_host_address != ((void *)0))? 6 : 0);

    smtp_reset(reset_point);
    toomany = 0;
    break; /* HELO/EHLO */


    /* The MAIL command requires an address as an operand. All we do
    here is to parse it for syntactic correctness. The form "<>" is
    a special case which converts into an empty string. The start/end
    pointers in the original are not used further for this address, as
    it is the canonical extracted address which is all that is kept. */

    case MAIL_CMD:
    smtp_connection_had[smtp_ch_index++] = SCH_MAIL; if (smtp_ch_index >= 20) smtp_ch_index = 0;
    smtp_mailcmd_count++; /* Count for limit and ratelimit */
    was_rej_mail = 1; /* Reset if accepted */

    if (helo_required && !helo_seen)
      {
      smtp_printf("503 HELO or EHLO required\r\n");
      log_write(0, 1|16, "rejected MAIL from %s: no "
        "HELO/EHLO given", host_and_ident(0));
      break;
      }

    if (sender_address != ((void *)0))
      {
      done = synprot_error(0x00004000, 503, ((void *)0),
        (unsigned char *)"sender already given");
      break;
      }

    if (smtp_cmd_data[0] == 0)
      {
      done = synprot_error(0x00004000, 501, ((void *)0),
        (unsigned char *)"MAIL must have an address operand");
      break;
      }

    /* Check to see if the limit for messages per connection would be
    exceeded by accepting further messages. */

    if (smtp_accept_max_per_connection > 0 &&
        smtp_mailcmd_count > smtp_accept_max_per_connection)
      {
      smtp_printf("421 too many messages in this connection\r\n");
      log_write(0, 1|16, "rejected MAIL command %s: too many "
        "messages in one connection", host_and_ident(1));
      break;
      }

    /* Reset for start of message - even if this is going to fail, we
    obviously need to throw away any previous data. */

    smtp_reset(reset_point);
    toomany = 0;
    sender_data = recipient_data = ((void *)0);

    /* Loop, checking for ESMTP additions to the MAIL FROM command. */

    if (esmtp) for(;;)
      {
      uschar *name, *value, *end;
      unsigned long int size;

      if (!extract_option(&name, &value)) break;

      /* Handle SIZE= by reading the value. We don't do the check till later,
      in order to be able to log the sender address on failure. */

      if (strcmpic(name, (unsigned char *)"SIZE") == 0 &&
          ((size = strtoul((const char *)(value),(char **)(&end),10)), *end == 0))
        {
        if ((size == (9223372036854775807L * 2UL + 1UL) && (*__errno_location ()) == 34) || size > 2147483647)
          size = 2147483647;
        message_size = (int)size;
        }

      /* If this session was initiated with EHLO and accept_8bitmime is set,
      Exim will have indicated that it supports the BODY=8BITMIME option. In
      fact, it does not support this according to the RFCs, in that it does not
      take any special action for forwarding messages containing 8-bit
      characters. That is why accept_8bitmime is not the default setting, but
      some sites want the action that is provided. We recognize both "8BITMIME"
      and "7BIT" as body types, but take no action. */

      else if (accept_8bitmime && strcmpic(name, (unsigned char *)"BODY") == 0 &&
          (strcmpic(value, (unsigned char *)"8BITMIME") == 0 ||
           strcmpic(value, (unsigned char *)"7BIT") == 0)) {}

      /* Handle the AUTH extension. If the value given is not "<>" and either
      the ACL says "yes" or there is no ACL but the sending host is
      authenticated, we set it up as the authenticated sender. However, if the
      authenticator set a condition to be tested, we ignore AUTH on MAIL unless
      the condition is met. The value of AUTH is an xtext, which means that +,
      = and cntrl chars are coded in hex; however "<>" is unaffected by this
      coding. */

      else if (strcmpic(name, (unsigned char *)"AUTH") == 0)
        {
        if (strcmp((const char *)(value),(const char *)("<>")) != 0)
          {
          int rc;
          uschar *ignore_msg;

          if (auth_xtextdecode(value, &authenticated_sender) < 0)
            {
            /* Put back terminator overrides for error message */
            name[-1] = ' ';
            value[-1] = '=';
            done = synprot_error(0x00008000, 501, ((void *)0),
              (unsigned char *)"invalid data for AUTH");
            goto COMMAND_LOOP;
            }

          if (acl_smtp_mailauth == ((void *)0))
            {
            ignore_msg = (unsigned char *)"client not authenticated";
            rc = (sender_host_authenticated != ((void *)0))? 0 : 2;
            }
          else
            {
            ignore_msg = (unsigned char *)"rejected by ACL";
            rc = acl_check(ACL_WHERE_MAILAUTH, ((void *)0), acl_smtp_mailauth,
              &user_msg, &log_msg);
            }

          switch (rc)
            {
            case 0:
            if (authenticated_by == ((void *)0) ||
                authenticated_by->mail_auth_condition == ((void *)0) ||
                expand_check_condition(authenticated_by->mail_auth_condition,
                    authenticated_by->name, (unsigned char *)"authenticator"))
              break; /* Accept the AUTH */

            ignore_msg = (unsigned char *)"server_mail_auth_condition failed";
            if (authenticated_id != ((void *)0))
              ignore_msg = string_sprintf("%s: authenticated ID=\"%s\"",
                ignore_msg, authenticated_id);

            /* Fall through */

            case 2:
            authenticated_sender = ((void *)0);
            log_write(0, 1, "ignoring AUTH=%s from %s (%s)",
              value, host_and_ident(1), ignore_msg);
            break;

            /* Should only get DEFER or ERROR here. Put back terminator
            overrides for error message */

            default:
            name[-1] = ' ';
            value[-1] = '=';
            (void)smtp_handle_acl_fail(ACL_WHERE_MAILAUTH, rc, user_msg,
              log_msg);
            goto COMMAND_LOOP;
            }
          }
        }

      /* Unknown option. Stick back the terminator characters and break
      the loop. An error for a malformed address will occur. */

      else
        {
        name[-1] = ' ';
        value[-1] = '=';
        break;
        }
      }

    /* If we have passed the threshold for rate limiting, apply the current
    delay, and update it for next time, provided this is a limited host. */

    if (smtp_mailcmd_count > smtp_rlm_threshold &&
        verify_check_host(&smtp_ratelimit_hosts) == 0)
      {
      if ((debug_selector & (0x00200000)) != 0) debug_printf("rate limit MAIL: delay %.3g sec\n",
        smtp_delay_mail/1000.0);
      millisleep((int)smtp_delay_mail);
      smtp_delay_mail *= smtp_rlm_factor;
      if (smtp_delay_mail > (double)smtp_rlm_limit)
        smtp_delay_mail = (double)smtp_rlm_limit;
      }

    /* Now extract the address, first applying any SMTP-time rewriting. The
    TRUE flag allows "<>" as a sender address. */

    raw_sender = ((rewrite_existflags & 0x0100) != 0)?
      rewrite_one(smtp_cmd_data, 0x0100, ((void *)0), 0, (unsigned char *)"",
        global_rewrite_rules) : smtp_cmd_data;

    /* rfc821_domains = TRUE; << no longer needed */
    raw_sender =
      parse_extract_address(raw_sender, &errmess, &start, &end, &sender_domain,
        1);
    /* rfc821_domains = FALSE; << no longer needed */

    if (raw_sender == ((void *)0))
      {
      done = synprot_error(0x00008000, 501, smtp_cmd_data, errmess);
      break;
      }

    sender_address = raw_sender;

    /* If there is a configured size limit for mail, check that this message
    doesn't exceed it. The check is postponed to this point so that the sender
    can be logged. */

    if (thismessage_size_limit > 0 && message_size > thismessage_size_limit)
      {
      smtp_printf("552 Message size exceeds maximum permitted\r\n");
      log_write(0x00000400,
          1|16, "rejected MAIL FROM:<%s> %s: "
          "message too big: size%s=%d max=%d",
          sender_address,
          host_and_ident(1),
          (message_size == 2147483647)? ">" : "",
          message_size,
          thismessage_size_limit);
      sender_address = ((void *)0);
      break;
      }

    /* Check there is enough space on the disk unless configured not to.
    When smtp_check_spool_space is set, the check is for thismessage_size_limit
    plus the current message - i.e. we accept the message only if it won't
    reduce the space below the threshold. Add 5000 to the size to allow for
    overheads such as the Received: line and storing of recipients, etc.
    By putting the check here, even when SIZE is not given, it allow VRFY
    and EXPN etc. to be used when space is short. */

    if (!receive_check_fs(
         (smtp_check_spool_space && message_size >= 0)?
            message_size + 5000 : 0))
      {
      smtp_printf("452 Space shortage, please try later\r\n");
      sender_address = ((void *)0);
      break;
      }

    /* If sender_address is unqualified, reject it, unless this is a locally
    generated message, or the sending host or net is permitted to send
    unqualified addresses - typically local machines behaving as MUAs -
    in which case just qualify the address. The flag is set above at the start
    of the SMTP connection. */

    if (sender_domain == 0 && sender_address[0] != 0)
      {
      if (allow_unqualified_sender)
        {
        sender_domain = (int)strlen((const char *)(sender_address)) + 1;
        sender_address = rewrite_address_qualify(sender_address, 0);
        if ((debug_selector & (0x00200000)) != 0) debug_printf("unqualified address %s accepted\n",
          raw_sender);
        }
      else
        {
        smtp_printf("501 %s: sender address must contain a domain\r\n",
          smtp_cmd_data);
        log_write(0x00008000,
          1|16,
          "unqualified sender rejected: <%s> %s%s",
          raw_sender,
          host_and_ident(1),
          host_lookup_msg);
        sender_address = ((void *)0);
        break;
        }
      }

    /* Apply an ACL check if one is defined, before responding. Afterwards,
    when pipelining is not advertised, do another sync check in case the ACL
    delayed and the client started sending in the meantime. */

    if (acl_smtp_mail == ((void *)0)) rc = 0; else
      {
      rc = acl_check(ACL_WHERE_MAIL, ((void *)0), acl_smtp_mail, &user_msg, &log_msg);
      if (rc == 0 && !pipelining_advertised && !check_sync())
        goto SYNC_FAILURE;
      }

    if (rc == 0 || rc == 7)
      {
      if (user_msg == ((void *)0)) smtp_printf("250 OK\r\n");
        else smtp_user_msg((unsigned char *)"250", user_msg);
      smtp_delay_rcpt = smtp_rlr_base;
      recipients_discarded = (rc == 7);
      was_rej_mail = 0;
      }
    else
      {
      done = smtp_handle_acl_fail(ACL_WHERE_MAIL, rc, user_msg, log_msg);
      sender_address = ((void *)0);
      }
    break;


    /* The RCPT command requires an address as an operand. There may be any
    number of RCPT commands, specifying multiple recipients. We build them all
    into a data structure. The start/end values given by parse_extract_address
    are not used, as we keep only the extracted address. */

    case RCPT_CMD:
    smtp_connection_had[smtp_ch_index++] = SCH_RCPT; if (smtp_ch_index >= 20) smtp_ch_index = 0;
    rcpt_count++;
    was_rcpt = rcpt_in_progress = 1;

    /* There must be a sender address; if the sender was rejected and
    pipelining was advertised, we assume the client was pipelining, and do not
    count this as a protocol error. Reset was_rej_mail so that further RCPTs
    get the same treatment. */

    if (sender_address == ((void *)0))
      {
      if (pipelining_advertised && last_was_rej_mail)
        {
        smtp_printf("503 sender not yet given\r\n");
        was_rej_mail = 1;
        }
      else
        {
        done = synprot_error(0x00004000, 503, ((void *)0),
          (unsigned char *)"sender not yet given");
        was_rcpt = 0; /* Not a valid RCPT */
        }
      rcpt_fail_count++;
      break;
      }

    /* Check for an operand */

    if (smtp_cmd_data[0] == 0)
      {
      done = synprot_error(0x00008000, 501, ((void *)0),
        (unsigned char *)"RCPT must have an address operand");
      rcpt_fail_count++;
      break;
      }

    /* Apply SMTP rewriting then extract the working address. Don't allow "<>"
    as a recipient address */

    recipient = ((rewrite_existflags & 0x0100) != 0)?
      rewrite_one(smtp_cmd_data, 0x0100, ((void *)0), 0, (unsigned char *)"",
        global_rewrite_rules) : smtp_cmd_data;

    /* rfc821_domains = TRUE; << no longer needed */
    recipient = parse_extract_address(recipient, &errmess, &start, &end,
      &recipient_domain, 0);
    /* rfc821_domains = FALSE; << no longer needed */

    if (recipient == ((void *)0))
      {
      done = synprot_error(0x00008000, 501, smtp_cmd_data, errmess);
      rcpt_fail_count++;
      break;
      }

    /* If the recipient address is unqualified, reject it, unless this is a
    locally generated message. However, unqualified addresses are permitted
    from a configured list of hosts and nets - typically when behaving as
    MUAs rather than MTAs. Sad that SMTP is used for both types of traffic,
    really. The flag is set at the start of the SMTP connection.

    RFC 1123 talks about supporting "the reserved mailbox postmaster"; I always
    assumed this meant "reserved local part", but the revision of RFC 821 and
    friends now makes it absolutely clear that it means *mailbox*. Consequently
    we must always qualify this address, regardless. */

    if (recipient_domain == 0)
      {
      if (allow_unqualified_recipient ||
          strcmpic(recipient, (unsigned char *)"postmaster") == 0)
        {
        if ((debug_selector & (0x00200000)) != 0) debug_printf("unqualified address %s accepted\n",
          recipient);
        recipient_domain = (int)strlen((const char *)(recipient)) + 1;
        recipient = rewrite_address_qualify(recipient, 1);
        }
      else
        {
        rcpt_fail_count++;
        smtp_printf("501 %s: recipient address must contain a domain\r\n",
          smtp_cmd_data);
        log_write(0x00008000,
          1|16, "unqualified recipient rejected: "
          "<%s> %s%s", recipient, host_and_ident(1),
          host_lookup_msg);
        break;
        }
      }

    /* Check maximum allowed */

    if (rcpt_count > recipients_max && recipients_max > 0)
      {
      if (recipients_max_reject)
        {
        rcpt_fail_count++;
        smtp_printf("552 too many recipients\r\n");
        if (!toomany)
          log_write(0, 1|16, "too many recipients: message "
            "rejected: sender=<%s> %s", sender_address, host_and_ident(1));
        }
      else
        {
        rcpt_defer_count++;
        smtp_printf("452 too many recipients\r\n");
        if (!toomany)
          log_write(0, 1|16, "too many recipients: excess "
            "temporarily rejected: sender=<%s> %s", sender_address,
            host_and_ident(1));
        }

      toomany = 1;
      break;
      }

    /* If we have passed the threshold for rate limiting, apply the current
    delay, and update it for next time, provided this is a limited host. */

    if (rcpt_count > smtp_rlr_threshold &&
        verify_check_host(&smtp_ratelimit_hosts) == 0)
      {
      if ((debug_selector & (0x00200000)) != 0) debug_printf("rate limit RCPT: delay %.3g sec\n",
        smtp_delay_rcpt/1000.0);
      millisleep((int)smtp_delay_rcpt);
      smtp_delay_rcpt *= smtp_rlr_factor;
      if (smtp_delay_rcpt > (double)smtp_rlr_limit)
        smtp_delay_rcpt = (double)smtp_rlr_limit;
      }

    /* If the MAIL ACL discarded all the recipients, we bypass ACL checking
    for them. Otherwise, check the access control list for this recipient. As
    there may be a delay in this, re-check for a synchronization error
    afterwards, unless pipelining was advertised. */

    if (recipients_discarded) rc = 7; else
      {
      rc = acl_check(ACL_WHERE_RCPT, recipient, acl_smtp_rcpt, &user_msg,
        &log_msg);
      if (rc == 0 && !pipelining_advertised && !check_sync())
        goto SYNC_FAILURE;
      }

    /* The ACL was happy */

    if (rc == 0)
      {
      if (user_msg == ((void *)0)) smtp_printf("250 Accepted\r\n");
        else smtp_user_msg((unsigned char *)"250", user_msg);
      receive_add_recipient(recipient, -1);
      }

    /* The recipient was discarded */

    else if (rc == 7)
      {
      if (user_msg == ((void *)0)) smtp_printf("250 Accepted\r\n");
        else smtp_user_msg((unsigned char *)"250", user_msg);
      rcpt_fail_count++;
      discarded = 1;
      log_write(0, 1|16, "%s F=<%s> rejected RCPT %s: "
        "discarded by %s ACL%s%s", host_and_ident(1),
        (sender_address_unrewritten != ((void *)0))?
        sender_address_unrewritten : sender_address,
        smtp_cmd_argument, recipients_discarded? "MAIL" : "RCPT",
        (log_msg == ((void *)0))? (unsigned char *)"" : (unsigned char *)": ",
        (log_msg == ((void *)0))? (unsigned char *)"" : log_msg);
      }

    /* Either the ACL failed the address, or it was deferred. */

    else
      {
      if (rc == 2) rcpt_fail_count++; else rcpt_defer_count++;
      done = smtp_handle_acl_fail(ACL_WHERE_RCPT, rc, user_msg, log_msg);
      }
    break;


    /* The DATA command is legal only if it follows successful MAIL FROM
    and RCPT TO commands. However, if pipelining is advertised, a bad DATA is
    not counted as a protocol error if it follows RCPT (which must have been
    rejected if there are no recipients.) This function is complete when a
    valid DATA command is encountered.

    Note concerning the code used: RFC 2821 says this:

     -  If there was no MAIL, or no RCPT, command, or all such commands
        were rejected, the server MAY return a "command out of sequence"
        (503) or "no valid recipients" (554) reply in response to the
        DATA command.

    The example in the pipelining RFC 2920 uses 554, but I use 503 here
    because it is the same whether pipelining is in use or not.

    If all the RCPT commands that precede DATA provoked the same error message
    (often indicating some kind of system error), it is helpful to include it
    with the DATA rejection (an idea suggested by Tony Finch). */

    case DATA_CMD:
    smtp_connection_had[smtp_ch_index++] = SCH_DATA; if (smtp_ch_index >= 20) smtp_ch_index = 0;
    if (!discarded && recipients_count <= 0)
      {
      if (rcpt_smtp_response_same && rcpt_smtp_response != ((void *)0))
        {
        uschar *code = (unsigned char *)"503";
        int len = (int)strlen((const char *)(rcpt_smtp_response));
        smtp_respond(code, 3, 0, (unsigned char *)"All RCPT commands were rejected with "
          "this error:");
        /* Responses from smtp_printf() will have \r\n on the end */
        if (len > 2 && rcpt_smtp_response[len-2] == '\r')
          rcpt_smtp_response[len-2] = 0;
        smtp_respond(code, 3, 0, rcpt_smtp_response);
        }
      if (pipelining_advertised && last_was_rcpt)
        smtp_printf("503 Valid RCPT command must precede DATA\r\n");
      else
        done = synprot_error(0x00004000, 503, ((void *)0),
          (unsigned char *)"valid RCPT command must precede DATA");
      break;
      }

    if (toomany && recipients_max_reject)
      {
      sender_address = ((void *)0); /* This will allow a new MAIL without RSET */
      sender_address_unrewritten = ((void *)0);
      smtp_printf("554 Too many recipients\r\n");
      break;
      }

    /* If there is an ACL, re-check the synchronization afterwards, since the
    ACL may have delayed. */

    if (acl_smtp_predata == ((void *)0)) rc = 0; else
      {
      enable_dollar_recipients = 1;
      rc = acl_check(ACL_WHERE_PREDATA, ((void *)0), acl_smtp_predata, &user_msg,
        &log_msg);
      enable_dollar_recipients = 0;
      if (rc == 0 && !check_sync()) goto SYNC_FAILURE;
      }

    if (rc == 0)
      {
      if (user_msg == ((void *)0))
        smtp_printf("354 Enter message, ending with \".\" on a line by itself\r\n");
      else smtp_user_msg((unsigned char *)"354", user_msg);
      done = 3;
      message_ended = 3; /* Indicate in middle of data */
      }

    /* Either the ACL failed the address, or it was deferred. */

    else
      done = smtp_handle_acl_fail(ACL_WHERE_PREDATA, rc, user_msg, log_msg);
    break;


    case VRFY_CMD:
    smtp_connection_had[smtp_ch_index++] = SCH_VRFY; if (smtp_ch_index >= 20) smtp_ch_index = 0;
    rc = acl_check(ACL_WHERE_VRFY, ((void *)0), acl_smtp_vrfy, &user_msg, &log_msg);
    if (rc != 0)
      done = smtp_handle_acl_fail(ACL_WHERE_VRFY, rc, user_msg, log_msg);
    else
      {
      uschar *address;
      uschar *s = ((void *)0);

      /* rfc821_domains = TRUE; << no longer needed */
      address = parse_extract_address(smtp_cmd_data, &errmess, &start, &end,
        &recipient_domain, 0);
      /* rfc821_domains = FALSE; << no longer needed */

      if (address == ((void *)0))
        s = string_sprintf("501 %s", errmess);
      else
        {
        address_item *addr = deliver_make_addr(address, 0);
        switch(verify_address(addr, ((void *)0), 0x0002 | 0x0004, -1,
               -1, -1, ((void *)0), ((void *)0), ((void *)0)))
          {
          case 0:
          s = string_sprintf("250 <%s> is deliverable", address);
          break;

          case 1:
          s = (addr->user_message != ((void *)0))?
            string_sprintf("451 <%s> %s", address, addr->user_message) :
            string_sprintf("451 Cannot resolve <%s> at this time", address);
          break;

          case 2:
          s = (addr->user_message != ((void *)0))?
            string_sprintf("550 <%s> %s", address, addr->user_message) :
            string_sprintf("550 <%s> is not deliverable", address);
          log_write(0, 1, "VRFY failed for %s %s",
            smtp_cmd_argument, host_and_ident(1));
          break;
          }
        }

      smtp_printf("%s\r\n", s);
      }
    break;


    case EXPN_CMD:
    smtp_connection_had[smtp_ch_index++] = SCH_EXPN; if (smtp_ch_index >= 20) smtp_ch_index = 0;
    rc = acl_check(ACL_WHERE_EXPN, ((void *)0), acl_smtp_expn, &user_msg, &log_msg);
    if (rc != 0)
      done = smtp_handle_acl_fail(ACL_WHERE_EXPN, rc, user_msg, log_msg);
    else
      {
      BOOL save_log_testing_mode = log_testing_mode;
      address_test_mode = log_testing_mode = 1;
      (void) verify_address(deliver_make_addr(smtp_cmd_data, 0),
        smtp_out, 0x0002 | 0x0004 | 0x0008, -1, -1, -1,
        ((void *)0), ((void *)0), ((void *)0));
      address_test_mode = 0;
      log_testing_mode = save_log_testing_mode; /* true for -bh */
      }
    break;
# 3981 "src/smtp_in.c"
    /* The ACL for QUIT is provided for gathering statistical information or
    similar; it does not affect the response code, but it can supply a custom
    message. */

    case QUIT_CMD:
    smtp_connection_had[smtp_ch_index++] = SCH_QUIT; if (smtp_ch_index >= 20) smtp_ch_index = 0;
    incomplete_transaction_log((unsigned char *)"QUIT");
    if (acl_smtp_quit != ((void *)0))
      {
      rc = acl_check(ACL_WHERE_QUIT, ((void *)0), acl_smtp_quit, &user_msg, &log_msg);
      if (rc == 3)
        log_write(0, 1|2, "ACL for QUIT returned ERROR: %s",
          log_msg);
      }
    if (user_msg == ((void *)0))
      smtp_printf("221 %s closing connection\r\n", smtp_active_hostname);
    else
      smtp_respond((unsigned char *)"221", 3, 1, user_msg);





    done = 2;
    log_write(0x00001000, 1, "%s closed by QUIT",
      smtp_get_connection_info());
    break;


    case RSET_CMD:
    smtp_connection_had[smtp_ch_index++] = SCH_RSET; if (smtp_ch_index >= 20) smtp_ch_index = 0;
    incomplete_transaction_log((unsigned char *)"RSET");
    smtp_reset(reset_point);
    toomany = 0;
    smtp_printf("250 Reset OK\r\n");
    cmd_list[0].is_mail_cmd = 0;
    break;


    case NOOP_CMD:
    smtp_connection_had[smtp_ch_index++] = SCH_NOOP; if (smtp_ch_index >= 20) smtp_ch_index = 0;
    smtp_printf("250 OK\r\n");
    break;


    /* Show ETRN/EXPN/VRFY if there's an ACL for checking hosts; if actually
    used, a check will be done for permitted hosts. Show STARTTLS only if not
    already in a TLS session and if it would be advertised in the EHLO
    response. */

    case HELP_CMD:
    smtp_connection_had[smtp_ch_index++] = SCH_HELP; if (smtp_ch_index >= 20) smtp_ch_index = 0;
    smtp_printf("214-Commands supported:\r\n");
      {
      uschar buffer[256];
      buffer[0] = 0;
      strcat((char *)(buffer),(const char *)(" AUTH"));





      strcat((char *)(buffer),(const char *)(" HELO EHLO MAIL RCPT DATA"));
      strcat((char *)(buffer),(const char *)(" NOOP QUIT RSET HELP"));
      if (acl_smtp_etrn != ((void *)0)) strcat((char *)(buffer),(const char *)(" ETRN"));
      if (acl_smtp_expn != ((void *)0)) strcat((char *)(buffer),(const char *)(" EXPN"));
      if (acl_smtp_vrfy != ((void *)0)) strcat((char *)(buffer),(const char *)(" VRFY"));
      smtp_printf("214%s\r\n", buffer);
      }
    break;


    case EOF_CMD:
    incomplete_transaction_log((unsigned char *)"connection lost");
    smtp_notquit_exit((unsigned char *)"connection-lost", (unsigned char *)"421",
      (unsigned char *)"%s lost input connection", smtp_active_hostname);

    /* Don't log by default unless in the middle of a message, as some mailers
    just drop the call rather than sending QUIT, and it clutters up the logs.
    */

    if (sender_address != ((void *)0) || recipients_count > 0)
      log_write(0x00000080,
          1,
          "unexpected %s while reading SMTP command from %s%s",
          sender_host_unknown? "EOF" : "disconnection",
          host_and_ident(0), smtp_read_error);

    else log_write(0x00001000, 1, "%s lost%s",
      smtp_get_connection_info(), smtp_read_error);

    done = 1;
    break;


    case ETRN_CMD:
    smtp_connection_had[smtp_ch_index++] = SCH_ETRN; if (smtp_ch_index >= 20) smtp_ch_index = 0;
    if (sender_address != ((void *)0))
      {
      done = synprot_error(0x00004000, 503, ((void *)0),
        (unsigned char *)"ETRN is not permitted inside a transaction");
      break;
      }

    log_write(0x00000020, 1, "ETRN %s received from %s", smtp_cmd_argument,
      host_and_ident(0));

    rc = acl_check(ACL_WHERE_ETRN, ((void *)0), acl_smtp_etrn, &user_msg, &log_msg);
    if (rc != 0)
      {
      done = smtp_handle_acl_fail(ACL_WHERE_ETRN, rc, user_msg, log_msg);
      break;
      }

    /* Compute the serialization key for this command. */

    etrn_serialize_key = string_sprintf("etrn-%s\n", smtp_cmd_data);

    /* If a command has been specified for running as a result of ETRN, we
    permit any argument to ETRN. If not, only the # standard form is permitted,
    since that is strictly the only kind of ETRN that can be implemented
    according to the RFC. */

    if (smtp_etrn_command != ((void *)0))
      {
      uschar *error;
      BOOL rc;
      etrn_command = smtp_etrn_command;
      deliver_domain = smtp_cmd_data;
      rc = transport_set_up_command(&argv, smtp_etrn_command, 1, 0, ((void *)0),
        (unsigned char *)"ETRN processing", &error);
      deliver_domain = ((void *)0);
      if (!rc)
        {
        log_write(0, 1|2, "failed to set up ETRN command: %s",
          error);
        smtp_printf("458 Internal failure\r\n");
        break;
        }
      }

    /* Else set up to call Exim with the -R option. */

    else
      {
      if (*smtp_cmd_data++ != '#')
        {
        done = synprot_error(0x00008000, 501, ((void *)0),
          (unsigned char *)"argument must begin with #");
        break;
        }
      etrn_command = (unsigned char *)"exim -R";
      argv = child_exec_exim(CEE_RETURN_ARGV, 1, ((void *)0), 1, 2, (unsigned char *)"-R",
        smtp_cmd_data);
      }

    /* If we are host-testing, don't actually do anything. */

    if (host_checking)
      {
      if (host_checking || (debug_selector & ((0xffffffff & ~(0x00000001 | 0x00040000 | 0x04000000) ))) != 0)
        {
        debug_printf("ETRN command is: %s\n", etrn_command);
        debug_printf("ETRN command execution skipped\n");
        }
      if (user_msg == ((void *)0)) smtp_printf("250 OK\r\n");
        else smtp_user_msg((unsigned char *)"250", user_msg);
      break;
      }


    /* If ETRN queue runs are to be serialized, check the database to
    ensure one isn't already running. */

    if (smtp_etrn_serialize && !enq_start(etrn_serialize_key))
      {
      smtp_printf("458 Already processing %s\r\n", smtp_cmd_data);
      break;
      }

    /* Fork a child process and run the command. We don't want to have to
    wait for the process at any point, so set SIGCHLD to SIG_IGN before
    forking. It should be set that way anyway for external incoming SMTP,
    but we save and restore to be tidy. If serialization is required, we
    actually run the command in yet another process, so we can wait for it
    to complete and then remove the serialization lock. */

    oldsignal = signal(17, ((__sighandler_t) 1));

    if ((pid = fork()) == 0)
      {
      smtp_input = 0; /* This process is not associated with the */
      (void)fclose(smtp_in); /* SMTP call any more. */
      (void)fclose(smtp_out);

      signal(17, ((__sighandler_t) 0)); /* Want to catch child */

      /* If not serializing, do the exec right away. Otherwise, fork down
      into another process. */

      if (!smtp_etrn_serialize || (pid = fork()) == 0)
        {
        if ((debug_selector & (0x00000080)) != 0) debug_print_argv(argv);
        exim_nullstd(); /* Ensure std{in,out,err} exist */
        execv((char *) argv[0], (char *const *)argv);
        log_write(0, 1|6, "exec of \"%s\" (ETRN) failed: %s",
          etrn_command, strerror((*__errno_location ())));
        _exit(1); /* paranoia */
        }

      /* Obey this if smtp_serialize and the 2nd fork yielded non-zero. That
      is, we are in the first subprocess, after forking again. All we can do
      for a failing fork is to log it. Otherwise, wait for the 2nd process to
      complete, before removing the serialization. */

      if (pid < 0)
        log_write(0, 1|2, "2nd fork for serialized ETRN "
          "failed: %s", strerror((*__errno_location ())));
      else
        {
        int status;
        if ((debug_selector & ((0xffffffff & ~(0x00000001 | 0x00040000 | 0x04000000) ))) != 0) debug_printf("waiting for serialized ETRN process %d\n",
          (int)pid);
        (void)wait(&status);
        if ((debug_selector & ((0xffffffff & ~(0x00000001 | 0x00040000 | 0x04000000) ))) != 0) debug_printf("serialized ETRN process %d ended\n",
          (int)pid);
        }

      enq_end(etrn_serialize_key);
      _exit(0);
      }

    /* Back in the top level SMTP process. Check that we started a subprocess
    and restore the signal state. */

    if (pid < 0)
      {
      log_write(0, 1|2, "fork of process for ETRN failed: %s",
        strerror((*__errno_location ())));
      smtp_printf("458 Unable to fork process\r\n");
      if (smtp_etrn_serialize) enq_end(etrn_serialize_key);
      }
    else
      {
      if (user_msg == ((void *)0)) smtp_printf("250 OK\r\n");
        else smtp_user_msg((unsigned char *)"250", user_msg);
      }

    signal(17, oldsignal);
    break;


    case BADARG_CMD:
    done = synprot_error(0x00008000, 501, ((void *)0),
      (unsigned char *)"unexpected argument data");
    break;


    /* This currently happens only for NULLs, but could be extended. */

    case BADCHAR_CMD:
    done = synprot_error(0x00008000, 0, ((void *)0), /* Just logs */
      (unsigned char *)"NULL character(s) present (shown as '?')");
    smtp_printf("501 NULL characters are not allowed in SMTP commands\r\n");
    break;


    case BADSYN_CMD:
    SYNC_FAILURE:
    if (smtp_inend >= smtp_inbuffer + 8192)
      smtp_inend = smtp_inbuffer + 8192 - 1;
    c = smtp_inend - smtp_inptr;
    if (c > 150) c = 150;
    smtp_inptr[c] = 0;
    incomplete_transaction_log((unsigned char *)"sync failure");
    log_write(0, 1|16, "SMTP protocol synchronization error "
      "(next input sent too soon: pipelining was%s advertised): "
      "rejected \"%s\" %s next input=\"%s\"",
      pipelining_advertised? "" : " not",
      smtp_cmd_buffer, host_and_ident(1),
      string_printing2((smtp_inptr), 1));
    smtp_notquit_exit((unsigned char *)"synchronization-error", (unsigned char *)"554",
      (unsigned char *)"SMTP synchronization error");
    done = 1; /* Pretend eof - drops connection */
    break;


    case TOO_MANY_NONMAIL_CMD:
    s = smtp_cmd_buffer;
    while (*s != 0 && !((*__ctype_b_loc ())[(int) ((*s))] & (unsigned short int) _ISspace)) s++;
    incomplete_transaction_log((unsigned char *)"too many non-mail commands");
    log_write(0, 1|16, "SMTP call from %s dropped: too many "
      "nonmail commands (last was \"%.*s\")", host_and_ident(0),
      s - smtp_cmd_buffer, smtp_cmd_buffer);
    smtp_notquit_exit((unsigned char *)"bad-commands", (unsigned char *)"554", (unsigned char *)"Too many nonmail commands");
    done = 1; /* Pretend eof - drops connection */
    break;


    default:
    if (unknown_command_count++ >= smtp_max_unknown_commands)
      {
      log_write(0x00008000, 1,
        "SMTP syntax error in \"%s\" %s %s",
        string_printing2((smtp_cmd_buffer), 1), host_and_ident(1),
        (unsigned char *)"unrecognized command");
      incomplete_transaction_log((unsigned char *)"unrecognized command");
      smtp_notquit_exit((unsigned char *)"bad-commands", (unsigned char *)"500",
        (unsigned char *)"Too many unrecognized commands");
      done = 2;
      log_write(0, 1|16, "SMTP call from %s dropped: too many "
        "unrecognized commands (last was \"%s\")", host_and_ident(0),
        smtp_cmd_buffer);
      }
    else
      done = synprot_error(0x00008000, 500, ((void *)0),
        (unsigned char *)"unrecognized command");
    break;
    }

  /* This label is used by goto's inside loops that want to break out to
  the end of the command-processing loop. */

  COMMAND_LOOP:
  last_was_rej_mail = was_rej_mail; /* Remember some last commands for */
  last_was_rcpt = was_rcpt; /* protocol error handling */
  continue;
  }

return done - 2; /* Convert yield values */
}

/* End of smtp_in.c */
# 1 "src/tls-gnu.c"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* This header is separate from features.h so that the compiler can
   include it implicitly at the start of every compilation.  It must
   not itself include <features.h> or any other header that includes
   <features.h> because the implicit include comes before any feature
   test macros that may be defined in a source file before it first
   explicitly includes a system header.  GCC knows the name of this
   header in order to preinclude it.  */

/* We do support the IEC 559 math functionality, real and complex.  */



/* wchar_t uses ISO/IEC 10646 (2nd ed., published 2011-03-15) /
   Unicode 6.0.  */


/* We do not support C11 <threads.h>.  */
# 1 "<command-line>" 2
# 1 "src/tls-gnu.c"
# 1 "/usr/include/stdio.h" 1 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991, 1994-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */





# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* These are defined by the user (or the compiler)
   to specify the desired environment:

   __STRICT_ANSI__	ISO Standard C.
   _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
   _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
   _POSIX_SOURCE	IEEE Std 1003.1.
   _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
			if >=199309L, add IEEE Std 1003.1b-1993;
			if >=199506L, add IEEE Std 1003.1c-1995;
			if >=200112L, all of IEEE 1003.1-2004
			if >=200809L, all of IEEE 1003.1-2008
   _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
			Single Unix conformance is wanted, to 600 for the
			sixth revision, to 700 for the seventh revision.
   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
   _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
   _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
   _FILE_OFFSET_BITS=N	Select default filesystem interface.
   _BSD_SOURCE		ISO C, POSIX, and 4.3BSD things.
   _SVID_SOURCE		ISO C, POSIX, and SVID things.
   _ATFILE_SOURCE	Additional *at interfaces.
   _GNU_SOURCE		All of the above, plus GNU extensions.
   _REENTRANT		Select additionally reentrant object.
   _THREAD_SAFE		Same as _REENTRANT, often used by other systems.
   _FORTIFY_SOURCE	If set to numeric value > 0 additional security
			measures are defined, according to level.

   The `-ansi' switch to the GNU C compiler defines __STRICT_ANSI__.
   If none of these are defined, the default is to have _SVID_SOURCE,
   _BSD_SOURCE, and _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
   200112L.  If more than one of these are defined, they accumulate.
   For example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE
   together give you ISO C, 1003.1, and 1003.2, but nothing else.

   These are defined by this file and are used by the
   header files to decide what to declare or define:

   __USE_ISOC11		Define ISO C11 things.
   __USE_ISOC99		Define ISO C99 things.
   __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
   __USE_POSIX		Define IEEE Std 1003.1 things.
   __USE_POSIX2		Define IEEE Std 1003.2 things.
   __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
   __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
   __USE_XOPEN		Define XPG things.
   __USE_XOPEN_EXTENDED	Define X/Open Unix things.
   __USE_UNIX98		Define Single Unix V2 things.
   __USE_XOPEN2K        Define XPG6 things.
   __USE_XOPEN2KXSI     Define XPG6 XSI things.
   __USE_XOPEN2K8       Define XPG7 things.
   __USE_XOPEN2K8XSI    Define XPG7 XSI things.
   __USE_LARGEFILE	Define correct standard I/O things.
   __USE_LARGEFILE64	Define LFS things with separate names.
   __USE_FILE_OFFSET64	Define 64bit interface as default.
   __USE_BSD		Define 4.3BSD things.
   __USE_SVID		Define SVID things.
   __USE_MISC		Define things common to BSD and System V Unix.
   __USE_ATFILE		Define *at interfaces and AT_* constants for them.
   __USE_GNU		Define GNU extensions.
   __USE_REENTRANT	Define reentrant/thread-safe *_r functions.
   __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
   __FAVOR_BSD		Favor 4.3BSD things in cases of conflict.

   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
   only for compatibility.  All new code should use the other symbols
   to test for features.

   All macros listed above as possibly being defined by this file are
   explicitly undefined if they are not explicitly defined.
   Feature-test macros that are not defined by the user or compiler
   but are implied by the other feature-test macros defined (or by the
   lack of any definitions) are defined by the file.  */


/* Undefine everything, so we get a clean slate.  */
# 126 "/usr/include/features.h" 3 4
/* Suppress kernel-name space pollution unless user expressedly asks
   for it.  */




/* Always use ISO C things.  */


/* Convenience macros to test the versions of glibc and gcc.
   Use them like this:
   #if __GNUC_PREREQ (2,8)
   ... code requiring gcc 2.8 or later ...
   #endif
   Note - they won't work for gcc1 or glibc1, since the _MINOR macros
   were not defined then.  */
# 150 "/usr/include/features.h" 3 4
/* If _BSD_SOURCE was defined by the user, favor BSD over POSIX.  */






/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */
# 183 "/usr/include/features.h" 3 4
/* If nothing (other than _GNU_SOURCE) is defined,
   define _BSD_SOURCE and _SVID_SOURCE.  */







/* This is to enable the ISO C11 extension.  */





/* This is to enable the ISO C99 extension.  */





/* This is to enable the ISO C90 Amendment 1:1995 extension.  */





/* This is to enable compatibility for ISO C++11.

   So far g++ does not provide a macro.  Check the temporary macro for
   now, too.  */





/* If none of the ANSI/POSIX macros are defined, use POSIX.1 and POSIX.2
   (and IEEE Std 1003.1b-1993 unless _XOPEN_SOURCE is defined).  */
# 343 "/usr/include/features.h" 3 4
/* Get definitions of __STDC_* predefined macros, if the compiler has
   not preincluded this header automatically.  */
# 1 "/usr/include/stdc-predef.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 346 "/usr/include/features.h" 2 3 4

/* This macro indicates that the installed library is the GNU C Library.
   For historic reasons the value now is 6 and this will stay from now
   on.  The use of this variable is deprecated.  Use __GLIBC__ and
   __GLIBC_MINOR__ now (see below) when you want to test for a specific
   GNU C library version and use the values in <gnu/lib-names.h> to get
   the sonames of the shared libraries.  */



/* Major and minor version number of the GNU C library package.  Use
   these macros to test for features in specific releases.  */






/* Decide whether a compiler supports the long long datatypes.  */







/* This is here only because every header file already includes this one.  */


# 1 "/usr/include/sys/cdefs.h" 1 3 4
/* Copyright (C) 1992-2002, 2004, 2005, 2006, 2007, 2009, 2011, 2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* We are almost always included from features.h. */




/* The GNU libc does not support any K&R compilers or the traditional mode
   of ISO C compilers anymore.  Check for some of the combinations not
   anymore supported.  */




/* Some user header file might have defined this before.  */





/* All functions, except those with callbacks or those that
   synchronize memory, are leaf functions.  */
# 50 "/usr/include/sys/cdefs.h" 3 4
/* GCC can always grok prototypes.  For C++ programs we add throw()
   to help it optimize the function calls.  But this works only with
   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
   as non-throwing using a function attribute since programs can use
   the -fexceptions options for C code as well.  */
# 81 "/usr/include/sys/cdefs.h" 3 4
/* These two macros are not used in glibc anymore.  They are kept here
   only because some other projects expect the macros to be defined.  */



/* For these things, GCC behaves the ANSI way normally,
   and the non-ANSI way under -traditional.  */




/* This is not a typedef so `const __ptr_t' does the right thing.  */




/* C++ needs to know that types and declarations are C, not C++.  */
# 107 "/usr/include/sys/cdefs.h" 3 4
/* The standard library needs the functions from the ISO C90 standard
   in the std namespace.  At the same time we want to be safe for
   future changes and we include the ISO C99 code in the non-standard
   namespace __c99.  The C++ wrapper header take case of adding the
   definitions to the global namespace.  */
# 120 "/usr/include/sys/cdefs.h" 3 4
/* For compatibility we do not add the declarations into any
   namespace.  They will end up in the global namespace which is what
   old code expects.  */
# 132 "/usr/include/sys/cdefs.h" 3 4
/* Support for bounded pointers.  */







/* Fortify support.  */
# 157 "/usr/include/sys/cdefs.h" 3 4
/* Support for flexible arrays.  */

/* GCC 2.97 supports C99 flexible array members.  */
# 175 "/usr/include/sys/cdefs.h" 3 4
/* __asm__ ("xyz") is used throughout the headers to rename functions
   at the assembly language level.  This is wrapped by the __REDIRECT
   macro, in order to support compilers that can do this some other
   way.  When compilers don't support asm-names at all, we have to do
   preprocessor tricks instead (which don't have exactly the right
   semantics, but it's the best we can do).

   Example:
   int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); */
# 202 "/usr/include/sys/cdefs.h" 3 4
/*
#elif __SOME_OTHER_COMPILER__

# define __REDIRECT(name, proto, alias) name proto; 	_Pragma("let " #name " = " #alias)
)
*/


/* GCC has various useful declarations that can be made with the
   `__attribute__' syntax.  All of the ways we use this do fine if
   they are omitted for compilers that don't understand it. */




/* At some point during the gcc 2.96 development the `malloc' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */






/* At some point during the gcc 2.96 development the `pure' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */






/* This declaration tells the compiler that the value is constant.  */






/* At some point during the gcc 3.1 development the `used' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */
# 253 "/usr/include/sys/cdefs.h" 3 4
/* gcc allows marking deprecated functions.  */






/* At some point during the gcc 2.8 development the `format_arg' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.
   If several `format_arg' attributes are given for the same function, in
   gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
   all designated arguments are considered.  */






/* At some point during the gcc 2.97 development the `strfmon' format
   attribute for functions was introduced.  We don't want to use it
   unconditionally (although this would be possible) since it
   generates warnings.  */







/* The nonull function attribute allows to mark pointer parameters which
   must not be NULL.  */






/* If fortification mode, we warn about unused results of certain
   function calls which can lead to problems.  */
# 306 "/usr/include/sys/cdefs.h" 3 4
/* Forces a function to be always inlined.  */






/* Associate error messages with the source location of the call site rather
   than with the source location inside the function.  */






/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
   inline semantics, unless -fgnu89-inline is used.  */
# 341 "/usr/include/sys/cdefs.h" 3 4
/* GCC 4.3 and above allow passing all anonymous arguments of an
   __extern_always_inline function to some other vararg function.  */





/* It is possible to compile containing GCC extensions even if GCC is
   run in pedantic mode if the uses are carefully marked using the
   `__extension__' keyword.  But this is not generally available before
   version 2.8.  */




/* __restrict is known in EGCS 1.2 and above. */




/* ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
     array_name[restrict]
   GCC 3.1 supports this.  */
# 385 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 386 "/usr/include/sys/cdefs.h" 2 3 4
# 376 "/usr/include/features.h" 2 3 4


/* If we don't have __REDIRECT, prototypes will be missing if
   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. */







/* Decide whether we can define 'extern inline' functions in headers.  */







/* This is here only because every header file already includes this one.
   Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
   <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
   that will always return failure (and set errno to ENOSYS).  */
# 1 "/usr/include/gnu/stubs.h" 1 3 4
/* This file is automatically generated.
   This file selects the right generated file of `__stub_FUNCTION' macros
   based on the architecture being compiled for.  */






# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
/* This file is automatically generated.
   It defines a symbol `__stub_FUNCTION' for each function
   in the C library which is a stub, meaning it will fail
   every time called, usually setting errno to ENOSYS.  */
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 400 "/usr/include/features.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 162 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 212 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 34 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/bits/types.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 11 "/usr/include/bits/wordsize.h" 3 4
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# 28 "/usr/include/bits/types.h" 2 3 4

/* Convenience types.  */
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;

/* Fixed-size types, underlying types depend on word size and compiler.  */
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;





/* quad_t is also 64 bits.  */

typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 69 "/usr/include/bits/types.h" 3 4
/* The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
   macros for each of the OS types we define below.  The definitions
   of those macros must use the following macros for underlying types.
   We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
   variants of each of the following integer types on this machine.

	16		-- "natural" 16-bit type (always short)
	32		-- "natural" 32-bit type (always int)
	64		-- "natural" 64-bit type (long or long long)
	LONG32		-- 32-bit type, traditionally long
	QUAD		-- 64-bit type, always long long
	WORD		-- natural type of __WORDSIZE bits (int or long)
	LONGWORD	-- type of __WORDSIZE bits, traditionally long

   We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
   conventional uses of `long' or `long long' type modifiers match the
   types we define, even when a less-adorned type would be the same size.
   This matters for (somewhat) portably writing printf/scanf formats for
   these types, where using the appropriate l or ll format modifiers can
   make the typedefs and the formats match up across all GNU platforms.  If
   we used `long' when it's 64 bits where `long long' is expected, then the
   compiler would warn about the formats not matching the argument types,
   and the programmer changing them to shut up the compiler would break the
   program's portability.

   Here we assume what is presently the case in all the GCC configurations
   we support: long long is always 64 bits, long is always word/address size,
   and int is always 32 bits.  */
# 125 "/usr/include/bits/types.h" 3 4
/* No need to mark the typedef with __extension__.   */




# 1 "/usr/include/bits/typesizes.h" 1 3 4
/* bits/typesizes.h -- underlying types for *_t.  Linux/x86-64 version.
   Copyright (C) 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/bits/typesizes.h" 3 4
/* See <bits/types.h> for the meaning of these macros.  This file exists so
   that <bits/types.h> need not vary across different GNU platforms.  */

/* X32 kernel interface is 64-bit.  */
# 76 "/usr/include/bits/typesizes.h" 3 4
/* Tell the libc code that off_t and off64_t are actually the same type
   for all ABI purposes, even if possibly expressed as different base types
   for C type-checking purposes.  */


/* Same for ino_t and ino64_t.  */



/* Number of descriptors that can fit in an `fd_set'.  */
# 131 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t; /* Type of device numbers.  */
typedef unsigned int __uid_t; /* Type of user identifications.  */
typedef unsigned int __gid_t; /* Type of group identifications.  */
typedef unsigned long int __ino_t; /* Type of file serial numbers.  */
typedef unsigned long int __ino64_t; /* Type of file serial numbers (LFS).*/
typedef unsigned int __mode_t; /* Type of file attribute bitmasks.  */
typedef unsigned long int __nlink_t; /* Type of file link counts.  */
typedef long int __off_t; /* Type of file sizes and offsets.  */
typedef long int __off64_t; /* Type of file sizes and offsets (LFS).  */
typedef int __pid_t; /* Type of process identifications.  */
typedef struct { int __val[2]; } __fsid_t; /* Type of file system IDs.  */
typedef long int __clock_t; /* Type of CPU usage counts.  */
typedef unsigned long int __rlim_t; /* Type for resource measurement.  */
typedef unsigned long int __rlim64_t; /* Type for resource measurement (LFS).  */
typedef unsigned int __id_t; /* General type for IDs.  */
typedef long int __time_t; /* Seconds since the Epoch.  */
typedef unsigned int __useconds_t; /* Count of microseconds.  */
typedef long int __suseconds_t; /* Signed count of microseconds.  */

typedef int __daddr_t; /* The type of a disk address.  */
typedef int __key_t; /* Type of an IPC key.  */

/* Clock ID used in clock and timer functions.  */
typedef int __clockid_t;

/* Timer ID returned by `timer_create'.  */
typedef void * __timer_t;

/* Type to represent block size.  */
typedef long int __blksize_t;

/* Types from the Large File Support interface.  */

/* Type to count number of disk blocks.  */
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;

/* Type to count file system blocks.  */
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;

/* Type to count file system nodes.  */
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

/* Type of miscellaneous file system fields.  */
typedef long int __fsword_t;

typedef long int __ssize_t; /* Type of a byte count, or error.  */

/* Signed long type used in system calls.  */
typedef long int __syscall_slong_t;
/* Unsigned long type used in system calls.  */
typedef unsigned long int __syscall_ulong_t;

/* These few don't really vary by system, they always correspond
   to one of the other defined types.  */
typedef __off64_t __loff_t; /* Type of file sizes and offsets (LFS).  */
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;

/* Duplicates info from stdint.h but this is used in unistd.h.  */
typedef long int __intptr_t;

/* Duplicate info from sys/socket.h.  */
typedef unsigned int __socklen_t;
# 36 "/usr/include/stdio.h" 2 3 4







/* Define outside of namespace so the C++ is happy.  */
struct _IO_FILE;


/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE FILE;

# 63 "/usr/include/stdio.h" 3 4
/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
/* Copyright (C) 1991-1995,1997-2007,2009,2011,2012
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Written by Per Bothner <bothner@cygnus.com>.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.

   As a special exception, if you link the code in this file with
   files compiled with a GNU compiler to produce an executable,
   that does not cause the resulting executable to be covered by
   the GNU Lesser General Public License.  This exception does not
   however invalidate any other reasons why the executable file
   might be covered by the GNU Lesser General Public License.
   This exception applies to code released by its copyright holders
   in files containing the exception.  */




# 1 "/usr/include/_G_config.h" 1 3 4
/* This file is needed by libio to define various configuration parameters.
   These are always the same in the GNU C library.  */




/* Define types for libio in terms of the standard internal type names.  */

# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 10 "/usr/include/_G_config.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 162 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
/* Copyright (C) 1995-2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */
# 81 "/usr/include/wchar.h" 3 4
/* Conversion state information.  */
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value; /* Value so far.  */
} __mbstate_t;




/* The rest of the file is only used if used if __need_mbstate_t is not
   defined.  */
# 897 "/usr/include/wchar.h" 3 4
/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 45 "/usr/include/_G_config.h" 3 4
/* These library features are always available in the GNU C library.  */







/* This is defined by <bits/stat.h> if `st_blksize' exists.  */
# 33 "/usr/include/libio.h" 2 3 4
/* ALL of these should be defined in _G_config.h */
# 48 "/usr/include/libio.h" 3 4
/* This define avoids name pollution if we're using GNU stdarg.h */

# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdarg.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
# 36 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdarg.h" 3 4
/* Define __gnuc_va_list.  */



typedef __builtin_va_list __gnuc_va_list;


/* Define the standard macros for the user,
   if this invocation was from the user program.  */
# 51 "/usr/include/libio.h" 2 3 4
# 87 "/usr/include/libio.h" 3 4
/* Magic numbers and bits for the _flags field.
   The magic numbers use the high-order bits of _flags;
   the remaining bits are available for variable flags.
   Note: The magic numbers must all be negative if stdio
   emulation is desired. */
# 125 "/usr/include/libio.h" 3 4
/* These are "formatting flags" matching the iostream fmtflags enum values. */
# 145 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;

/* Handle lock.  */







typedef void _IO_lock_t;



/* A streammarker remembers a position in a buffer. */

struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;
  /* If _pos >= 0
 it points to _buf->Gbase()+_pos. FIXME comment */
  /* if _pos < 0, it points to _buf->eBptr()+_pos. FIXME comment */
  int _pos;
# 178 "/usr/include/libio.h" 3 4
};

/* This is the structure from the libstdc++ codecvt class.  */
enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 246 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags; /* High-order word is _IO_MAGIC; rest is flags. */


  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr; /* Current read pointer */
  char* _IO_read_end; /* End of get area. */
  char* _IO_read_base; /* Start of putback+get area. */
  char* _IO_write_base; /* Start of put area. */
  char* _IO_write_ptr; /* Current put pointer. */
  char* _IO_write_end; /* End of put area. */
  char* _IO_buf_base; /* Start of reserve area. */
  char* _IO_buf_end; /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base; /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset; /* This used to be _offset but it's too small.  */


  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;
# 294 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 303 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;
  /* Make sure we don't get into trouble again.  */
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 335 "/usr/include/libio.h" 3 4
/* Functions to do I/O and file management for a stream.  */

/* Read NBYTES bytes from COOKIE into a buffer pointed to by BUF.
   Return number of bytes read.  */
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);

/* Write N bytes pointed to by BUF to COOKIE.  Write all N bytes
   unless there is an error.  Return number of bytes written.  If
   there is an error, return 0 and do not write anything.  If the file
   has been opened for append (__mode.__append set), then set the file
   pointer to the end of the file and then do the write; if not, just
   write at the current file pointer.  */
typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);

/* Move COOKIE's file position to *POS bytes from the
   beginning of the file (if W is SEEK_SET),
   the current position (if W is SEEK_CUR),
   or the end of the file (if W is SEEK_END).
   Set *POS to the new file position.
   Returns zero if successful, nonzero if not.  */
typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);

/* Close COOKIE.  */
typedef int __io_close_fn (void *__cookie);
# 391 "/usr/include/libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 435 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);

/* This one is for Emacs. */



extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 465 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "/usr/include/stdio.h" 2 3 4
# 107 "/usr/include/stdio.h" 3 4
/* The type of the second argument to `fgetpos' and `fsetpos'.  */


typedef _G_fpos_t fpos_t;








/* The possibilities for the third argument to `setvbuf'.  */





/* Default buffer size.  */





/* End of file character.
   Some things throughout the library rely on this being -1.  */





/* The possibilities for the third argument to `fseek'.
   These values should not be changed.  */
# 155 "/usr/include/stdio.h" 3 4
/* Get the values:
   L_tmpnam	How long an array of chars must be to be passed to `tmpnam'.
   TMP_MAX	The minimum number of unique filenames generated by tmpnam
		(and tempnam when it uses tmpnam's name space),
		or tempnam (the two are separate).
   L_ctermid	How long an array to pass to `ctermid'.
   L_cuserid	How long an array to pass to `cuserid'.
   FOPEN_MAX	Minimum number of files that can be open at once.
   FILENAME_MAX	Maximum length of a filename.  */
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
/* Copyright (C) 1994, 1997, 1998, 1999, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 165 "/usr/include/stdio.h" 2 3 4


/* Standard streams.  */
extern struct _IO_FILE *stdin; /* Standard input stream.  */
extern struct _IO_FILE *stdout; /* Standard output stream.  */
extern struct _IO_FILE *stderr; /* Standard error output stream.  */
/* C89/C99 say they're macros.  Make them happy.  */





/* Remove file FILENAME.  */
extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));
/* Rename file OLD to NEW.  */
extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));









/* Create a temporary file and open it read/write.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern FILE *tmpfile (void) ;
# 208 "/usr/include/stdio.h" 3 4
/* Generate a temporary filename.  */
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;

# 232 "/usr/include/stdio.h" 3 4

/* Close STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fclose (FILE *__stream);
/* Flush STREAM, or all streams if STREAM is NULL.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fflush (FILE *__stream);

# 266 "/usr/include/stdio.h" 3 4


/* Open a file and create a new stream for it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;
/* Open a file, replacing an existing stream with it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4

# 329 "/usr/include/stdio.h" 3 4

/* If BUF is NULL, make STREAM unbuffered.
   Else make it use buffer BUF, of size BUFSIZ.  */
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));
/* Make STREAM use buffering mode MODE.
   If BUF is not NULL, use N bytes of it for buffering;
   else allocate an internal buffer N bytes long.  */
extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

# 351 "/usr/include/stdio.h" 3 4

/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int printf (const char *__restrict __format, ...);
/* Write formatted output to S.  */
extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));

/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);
/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);
/* Write formatted output to S from argument list ARG.  */
extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));

# 420 "/usr/include/stdio.h" 3 4

/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;
/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int scanf (const char *__restrict __format, ...) ;
/* Read formatted input from S.  */
extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 463 "/usr/include/stdio.h" 3 4

# 526 "/usr/include/stdio.h" 3 4

/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getchar (void);


/* The C standard explicitly says this is a macro, so we always do the
   optimization for it.  */
# 565 "/usr/include/stdio.h" 3 4

/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.

   These functions is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);

/* Write a character to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int putchar (int __c);


/* The C standard explicitly says this can be a macro,
   so we always do the optimization for it.  */
# 617 "/usr/include/stdio.h" 3 4

/* Get a newline-terminated string of finite length from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;



/* Get a newline-terminated string from stdin, removing the newline.
   DO NOT USE THIS FUNCTION!!  There is no limit on how much it will read.

   The function has been officially removed in ISO C11.  This opportunity
   is used to also remove it from the GNU feature list.  It is now only
   available when explicitly using an old ISO C, Unix, or POSIX standard.
   GCC defines _GNU_SOURCE when building C++ code and the function is still
   in C++11, so it is also available for C++.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *gets (char *__s) __attribute__ ((__deprecated__));


# 684 "/usr/include/stdio.h" 3 4

/* Write a string to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);

/* Write a string, followed by a newline, to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int puts (const char *__s);


/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int ungetc (int __c, FILE *__stream);


/* Read chunks of generic data from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;
/* Write chunks of generic data to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 744 "/usr/include/stdio.h" 3 4

/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fseek (FILE *__stream, long int __off, int __whence);
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern long int ftell (FILE *__stream) ;
/* Rewind to the beginning of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void rewind (FILE *__stream);


/* The Single Unix Specification, Version 2, specifies an alternative,
   more adequate interface for the two functions above which deal with
   file offset.  `long int' is not the right type.  These definitions
   are originally defined in the Large File Support API.  */
# 792 "/usr/include/stdio.h" 3 4


/* Get STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
/* Set STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4

# 824 "/usr/include/stdio.h" 3 4

/* Clear the error and EOF indicators for STREAM.  */
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
/* Return the EOF indicator for STREAM.  */
extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
/* Return the error indicator for STREAM.  */
extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

# 841 "/usr/include/stdio.h" 3 4

/* Print a message describing the meaning of the value of errno.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void perror (const char *__s);


/* Provide the declarations for `sys_errlist' and `sys_nerr' if they
   are available on this system.  Even if available, these variables
   should not be used directly.  The `strerror' function provides
   all the necessary functionality.  */
# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
/* Declare sys_errlist and sys_nerr, or don't.  Compatibility (do) version.
   Copyright (C) 2002, 2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* sys_errlist and sys_nerr are deprecated.  Use strerror instead.  */
# 854 "/usr/include/stdio.h" 2 3 4
# 931 "/usr/include/stdio.h" 3 4
/* If we are compiling with optimizing read this file.  It contains
   several optimizing inline functions and macros.  */
# 943 "/usr/include/stdio.h" 3 4

# 2 "src/tls-gnu.c" 2
# 1 "src/mytypes.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2012 */
/* See the file NOTICE for conditions of use and distribution. */


/* This header file contains type definitions and macros that I use as
"standard" in the code of Exim and its utilities. Make it idempotent because
local_scan.h includes it and exim.h includes them both (to get this earlier). */
# 29 "src/mytypes.h"
/* If gcc is being used to compile Exim, we can use its facility for checking
the arguments of printf-like functions. This is done by a macro. */
# 47 "src/mytypes.h"
/* Some operating systems (naughtily, imo) include a definition for "uchar" in
the standard header files, so we use "uschar". Solaris has u_char in
sys/types.h. This is just a typing convenience, of course. */

typedef unsigned char uschar;
typedef int BOOL;
/* We also have SIGNAL_BOOL, which requires signal.h be included, so is defined
elsewhere */


/* These macros save typing for the casting that is needed to cope with the
mess that is "char" in ISO/ANSI C. Having now been bitten enough times by
systems where "char" is actually signed, I've converted Exim to use entirely
unsigned chars, except in a few special places such as arguments that are
almost always literal strings. */
# 70 "src/mytypes.h"
/* The C library string functions expect "char *" arguments. Use macros to
avoid having to write a cast each time. We do this for string and file
functions that are called quite often; for other calls to external libraries
(which are on the whole special-purpose) we just use individual casts. */
# 117 "src/mytypes.h"
/* End of mytypes.h */
# 3 "src/tls-gnu.c" 2
# 1 "src/local_scan.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2012 */
/* See the file NOTICE for conditions of use and distribution. */

/* This file is the header that is the only Exim header to be included in the
source for the local_scan.c() function. It contains definitions that are made
available for use in that function, and which are documented.

This API is also used for functions called by the ${dlfunc expansion item. */


/* Some basic types that make some things easier, the Exim configuration
settings, and the store functions. */

# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdarg.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
# 36 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdarg.h" 3 4
/* Define __gnuc_va_list.  */






/* Define the standard macros for the user,
   if this invocation was from the user program.  */
# 55 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdarg.h" 3 4
/* Define va_list, if desired, from __gnuc_va_list. */
/* We deliberately do not define va_list when called from
   stdio.h, because ANSI C says that stdio.h is not supposed to define
   va_list.  stdio.h needs to have access to that data type, 
   but must not use that name.  It should use the name __gnuc_va_list,
   which is safe because it is reserved for the implementation.  */
# 85 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stdarg.h" 3 4
/* The macro _VA_LIST_ is the same thing used by this file in Ultrix.
   But on BSD NET2 we must not test or define or undef it.
   (Note that the comments in NET 2's ansi.h
   are incorrect for _VA_LIST_--see stdio.h!)  */

/* The macro _VA_LIST_DEFINED is used in Windows NT 3.5  */

/* The macro _VA_LIST is used in SCO Unix 3.2.  */

/* The macro _VA_LIST_T_H is used in the Bull dpx2  */

/* The macro __va_list__ is used by BeOS.  */

typedef __gnuc_va_list va_list;
# 19 "src/local_scan.h" 2
# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/sys/types.h" 2 3 4



# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 30 "/usr/include/sys/types.h" 2 3 4
# 44 "/usr/include/sys/types.h" 3 4
typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 60 "/usr/include/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;
# 98 "/usr/include/sys/types.h" 3 4
typedef __pid_t pid_t;
# 109 "/usr/include/sys/types.h" 3 4
typedef __ssize_t ssize_t;
# 132 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 71 "/usr/include/time.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 72 "/usr/include/time.h" 2 3 4


/* Returned by `time'.  */
typedef __time_t time_t;

# 88 "/usr/include/time.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 89 "/usr/include/time.h" 2 3 4

/* Clock ID used in clock and timer functions.  */
typedef __clockid_t clockid_t;
# 100 "/usr/include/time.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 101 "/usr/include/time.h" 2 3 4

/* Timer ID returned by `timer_create'.  */
typedef __timer_t timer_t;
# 133 "/usr/include/sys/types.h" 2 3 4
# 146 "/usr/include/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 162 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 147 "/usr/include/sys/types.h" 2 3 4
# 155 "/usr/include/sys/types.h" 3 4
/* These size-specific names are used by some of the inet code.  */
# 186 "/usr/include/sys/types.h" 3 4
/* For GCC 2.7 and later, we can use specific type-size attributes.  */







typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));


/* Some code from BIND tests this macro to see if the types above are
   defined.  */
# 232 "/usr/include/sys/types.h" 3 4
/* Types from the Large File Support interface.  */


typedef __blkcnt_t blkcnt_t; /* Type to count number of disk blocks.  */



typedef __fsblkcnt_t fsblkcnt_t; /* Type to count file system blocks.  */



typedef __fsfilcnt_t fsfilcnt_t; /* Type to count file system inodes.  */
# 268 "/usr/include/sys/types.h" 3 4
/* Now add the thread types.  */





# 20 "src/local_scan.h" 2
# 1 "build-Linux-x86_64/config.h" 1
/*************************************************
*           Configuration header for Exim        *
*************************************************/

/* This file was automatically generated from Makefile and config.h.defaults,
using values specified in the configuration file Local/Makefile.
Do not edit it. Instead, edit Local/Makefile and rerun make. */
# 23 "build-Linux-x86_64/config.h"
/* ALT_CONFIG_PREFIX not set */
/* TRUSTED_CONFIG_LIST not set */




/* AUTH_CRAM_MD5 not set */
/* AUTH_CYRUS_SASL not set */
/* AUTH_DOVECOT not set */
/* AUTH_GSASL not set */
/* AUTH_HEIMDAL_GSSAPI not set */
/* AUTH_PLAINTEXT not set */
/* AUTH_SPA not set */



/* CONFIGURE_FILE_USE_EUID not set */
/* CONFIGURE_FILE_USE_NODE not set */
/* CONFIGURE_GROUP not set */
/* CONFIGURE_OWNER not set */
/* CYRUS_PWCHECK_SOCKET not set */
/* CYRUS_SASLAUTHD_SOCKET not set */



/* DISABLE_DKIM not set */
/* DISABLE_D_OPTION not set */
/* ENABLE_DISABLE_FSYNC not set */




/* EXIM_CLIENT_DH_MIN_BITS not set */
/* EXIM_GNUTLS_LIBRARY_LOG_LEVEL not set */
/* EXIM_SERVER_DH_BITS_PRE2_12 not set */
/* EXIM_PERL not set */


/* EXPAND_DLFUNC not set */
/* EXPAND_LISTMATCH_RHS not set */

/* HAVE_CRYPT16 not set */
/* HAVE_SA_LEN not set */




/* IPV6_USE_INET_PTON not set */
/* LDAP_LIB_TYPE not set */
/* LOCAL_SCAN_HAS_OPTIONS not set */

/* LOG_FILE_PATH not set */

/* LOOKUP_CDB not set */


/* LOOKUP_DSEARCH not set */
/* LOOKUP_IBASE not set */
/* LOOKUP_LDAP not set */

/* LOOKUP_MYSQL not set */
/* LOOKUP_NIS not set */
/* LOOKUP_NISPLUS not set */
/* LOOKUP_ORACLE not set */
/* LOOKUP_PASSWD not set */
/* LOOKUP_PGSQL not set */
/* LOOKUP_SQLITE not set */
/* LOOKUP_TESTDB not set */
/* LOOKUP_WHOSON not set */
/* LOOKUP_WILDLSEARCH not set */
/* LOOKUP_NWILDLSEARCH not set */
/* LOOKUP_MODULE_DIR not set */






/* NVALGRIND not set */
/* PID_FILE_PATH not set */
/* RADIUS_CONFIG_FILE not set */
/* RADIUS_LIB_TYPE not set */



/* ROUTER_IPLOOKUP not set */







/* SUPPORT_A6 not set */
/* SUPPORT_CRYPTEQ not set */
/* SUPPORT_MAILDIR not set */
/* SUPPORT_MAILSTORE not set */
/* SUPPORT_MBX not set */
/* SUPPORT_MOVE_FROZEN_MESSAGES not set */
/* SUPPORT_PAM not set */
/* SUPPORT_TLS not set */
/* SUPPORT_TRANSLATE_IP_ADDRESS not set */

/* SYSLOG_LONG_LINES not set */





/* TRANSPORT_LMTP not set */



/* USE_GDBM not set */
/* USE_GNUTLS not set */
/* USE_READLINE not set */
/* USE_TCP_WRAPPERS not set */
/* USE_TDB not set */
/* WHITELIST_D_MACROS not set */
/* WITH_CONTENT_SCAN not set */
/* WITH_OLD_DEMIME not set */
/* WITH_OLD_CLAMAV_STREAM not set */

/* EXPERIMENTAL_BRIGHTMAIL not set */
/* EXPERIMENTAL_DCC not set */
/* EXPERIMENTAL_OCSP not set */
/* EXPERIMENTAL_SPF not set */
/* EXPERIMENTAL_SRS not set */
/* WANT_DEEPER_PRINTF_CHECKS not set */
# 171 "build-Linux-x86_64/config.h"
/* End of config.h */
# 21 "src/local_scan.h" 2
# 1 "src/mytypes.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2012 */
/* See the file NOTICE for conditions of use and distribution. */


/* This header file contains type definitions and macros that I use as
"standard" in the code of Exim and its utilities. Make it idempotent because
local_scan.h includes it and exim.h includes them both (to get this earlier). */
# 117 "src/mytypes.h"
/* End of mytypes.h */
# 22 "src/local_scan.h" 2
# 1 "src/store.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2009 */
/* See the file NOTICE for conditions of use and distribution. */

/* Header for Exim's memory allocation functions */




/* Define symbols for identifying the store pools. */

enum { POOL_MAIN, POOL_PERM, POOL_SEARCH };

/* This variable (the one for the current pool) is set by store_get() to its
yield, and by store_reset() to NULL. This allows string_cat() to optimize its
store handling. */

extern void *store_last_get[3];

/* This variable contains the current store pool number. */

extern int store_pool;

/* Macros for calling the memory allocation routines with
tracing information for debugging. */
# 41 "src/store.h"
/* The real functions */

extern BOOL store_extend_3(void *, int, int, const char *, int); /* The */
extern void store_free_3(void *, const char *, int); /* value of the */
extern void *store_get_3(int, const char *, int); /* 2nd arg is   */
extern void *store_get_perm_3(int, const char *, int); /* __FILE__ in  */
extern void *store_malloc_3(int, const char *, int); /* every call,  */
extern void store_release_3(void *, const char *, int); /* so give its  */
extern void store_reset_3(void *, const char *, int); /* correct type */



/* End of store.h */
# 23 "src/local_scan.h" 2


/* The function and its return codes. */

extern int local_scan(int, uschar **);

enum {
  LOCAL_SCAN_ACCEPT, /* Accept */
  LOCAL_SCAN_ACCEPT_FREEZE, /* Accept, but freeze */
  LOCAL_SCAN_ACCEPT_QUEUE, /* Accept, but no immediate delivery */
  LOCAL_SCAN_REJECT, /* Permanent rejection */
  LOCAL_SCAN_REJECT_NOLOGHDR, /* Permanent rejection, no log header */
  LOCAL_SCAN_TEMPREJECT, /* Temporary rejection */
  LOCAL_SCAN_TEMPREJECT_NOLOGHDR /* Temporary rejection, no log header */
};


/* Functions called by ${dlfunc{file}{func}{arg}...} return one of the five
status codes defined immediately below. The function's first argument is either
the result of expansion, or the error message in case of failure. The second
and third arguments are standard argument count and vector, comprising the
{arg} values specified in the expansion item. */

typedef int exim_dlfunc_t(uschar **yield, int argc, uschar *argv[]);


/* Return codes from the support functions lss_match_xxx(). These are also the
codes that dynamically-loaded ${dlfunc functions must return. */






/* Extra return code for ${dlfunc functions */




/* Available logging destinations */






/* Accessible debugging bits */





/* Option types that can be used for local_scan_options. The boolean ones
MUST be last so that they are contiguous with the internal boolean specials. */

enum { opt_stringptr, opt_int, opt_octint, opt_mkint, opt_Kint, opt_fixed,
  opt_time, opt_bool };


/* The length of message identification strings. This is the id used internally
by exim. The external version for use in Received: strings has a leading 'E'
added to ensure it starts with a letter. */



/* The offset to the start of the data in the data file - this allows for
the name of the data file to be present in the first line. */



/* Some people (Marc Merlin et al) are maintaining a patch that allows for
dynamic local_scan() libraries. This code is not yet in Exim proper, but it
helps the maintainers if we keep their ABI version numbers here. This may
mutate into more general support later. The major number is increased when the
ABI is changed in a non backward compatible way. The minor number is increased
each time a new feature is added (in a way that doesn't break backward
compatibility). */






/* Structure definitions that are documented as visible in the function. */

typedef struct header_line {
  struct header_line *next;
  int type;
  int slen;
  uschar *text;
} header_line;

/* Entries in lists options are in this form. */

typedef struct {
  const char *name;
  int type;
  void *value;
} optionlist;

/*Structure for holding information about an envelope address. The errors_to
field is always NULL except for one_time aliases that had errors_to on the
routers that generated them. */

typedef struct recipient_item {
  uschar *address; /* the recipient address */
  int pno; /* parent number for "one_time" alias, or -1 */
  uschar *errors_to; /* the errors_to address or NULL */



} recipient_item;


/* Global variables that are documented as visible in the function. */

extern unsigned int debug_selector; /* Debugging bits */

extern int body_linecount; /* Line count in body */
extern int body_zerocount; /* Binary zero count in body */
extern uschar *expand_string_message; /* Error info for failing expansion */
extern uschar *headers_charset; /* Charset for RFC 2047 decoding */
extern header_line *header_last; /* Final header */
extern header_line *header_list; /* First header */
extern BOOL host_checking; /* Set when checking a host */
extern uschar *interface_address; /* Interface for incoming call */
extern int interface_port; /* Port number for incoming call */
extern uschar *message_id; /* Internal id of message being handled */
extern uschar *received_protocol; /* Name of incoming protocol */
extern int recipients_count; /* Number of recipients */
extern recipient_item *recipients_list;/* List of recipient addresses */
extern unsigned char *sender_address; /* Sender address */
extern uschar *sender_host_address; /* IP address of sender, as chars */
extern uschar *sender_host_authenticated; /* Name of authentication mechanism */
extern uschar *sender_host_name; /* Host name from lookup */
extern int sender_host_port; /* Port number of sender */
extern BOOL smtp_batched_input; /* TRUE if SMTP batch (no interaction) */
extern BOOL smtp_input; /* TRUE if input is via SMTP */


/* Functions that are documented as visible in local_scan(). */

extern int child_close(pid_t, int);
extern pid_t child_open(uschar **, uschar **, int, int *, int *, BOOL);
extern pid_t child_open_exim(int *);
extern pid_t child_open_exim2(int *, uschar *, uschar *);
extern void debug_printf(const char *, ...) __attribute__((format(printf,1,2)));
extern uschar *expand_string(uschar *);
extern void header_add(int, const char *, ...);
extern void header_add_at_position(BOOL, uschar *, BOOL, int, const char *, ...);
extern void header_remove(int, const uschar *);
extern BOOL header_testname(header_line *, const uschar *, int, BOOL);
extern BOOL header_testname_incomplete(header_line *, const uschar *, int, BOOL);
extern void log_write(unsigned int, int, const char *format, ...) __attribute__((format(printf,3,4)));
extern int lss_b64decode(uschar *, uschar **);
extern uschar *lss_b64encode(uschar *, int);
extern int lss_match_domain(uschar *, uschar *);
extern int lss_match_local_part(uschar *, uschar *, BOOL);
extern int lss_match_address(uschar *, uschar *, BOOL);
extern int lss_match_host(uschar *, uschar *, uschar *);
extern void receive_add_recipient(uschar *, int);
extern BOOL receive_remove_recipient(uschar *);
extern uschar *rfc2047_decode(uschar *, BOOL, uschar *, int, int *, uschar **);
extern int smtp_fflush(void);
extern void smtp_printf(const char *, ...) __attribute__((format(printf,1,2)));
extern void smtp_vprintf(const char *, va_list);
extern uschar *string_copy(const uschar *);
extern uschar *string_copyn(uschar *, int);
extern uschar *string_sprintf(const char *, ...) ;

/* End of local_scan.h */
# 4 "src/tls-gnu.c" 2
# 1 "src/macros.h" 1
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2012 */
/* See the file NOTICE for conditions of use and distribution. */


/* These two macros make it possible to obtain the result of macro-expanding
a string as a text string. This is sometimes useful for debugging output. */





/* When running in the test harness, the load average is fudged. */





/* The address_item structure has a word full of 1-bit flags. These macros
manipulate them. */
# 38 "src/macros.h"
/* For almost all calls to convert things to printing characters, we want to
allow tabs. A macro just makes life a bit easier. */




/* We need a special return code for "no recipients and failed to send an error
message". ANSI C defines only EXIT_FAILURE and EXIT_SUCCESS. On the assumption
that these are always 1 and 0 on Unix systems ... */




/* Character-handling macros. It seems that the set of standard functions in
ctype.h aren't actually all that useful. One reason for this is that email is
international, so the concept of using a locale to vary what they do is not
helpful. Another problem is that in different operating systems, the libraries
yield different results, even in the default locale. For example, Linux yields
TRUE for iscntrl() for all characters > 127, whereas many other systems yield
FALSE. For these reasons we define our own set of macros for a number of
character testing functions. Ensure that all these tests treat their arguments
as unsigned. */
# 75 "src/macros.h"
/* Convenience for testing strings */




/* When built with TLS support, the act of flushing SMTP output becomes
a no-op once an SSL session is in progress. */
# 90 "src/macros.h"
/* Define which ends of pipes are for reading and writing, as some systems
don't make the file descriptors two-way. */




/* The RFC 1413 ident port */



/* A macro to simplify testing bits in lookup types */



/* Debugging control */




/* The default From: text for DSNs */



/* The size of the vector for saving/restoring address expansion pointers while
verifying. This has to be explicit because it is referenced in more than one
source module. */



/* The maximum permitted number of command-line (-D) macro definitions. We
need a limit only to make it easier to generate argument vectors for re-exec
of Exim. */



/* The number of integer variables available in filter files. If this is
changed, then the tables in expand.c for accessing them must be changed too. */



/* The size of the vector holding delay warning times */



/* The size of the buffer holding the processing information string. */



/* The size of buffer to get for constructing log entries. Make it big
enough to hold all the headers from a normal kind of message. */



/* The size of the circular buffer that remembers recent SMTP commands */



/* The initial size of a big buffer for use in various places. It gets put
into big_buffer_size and in some circumstances increased. It should be at least
as long as the maximum path length. */
# 159 "src/macros.h"
/* This limits the length of data returned by local_scan(). Because it is
written on the spool, it gets read into big_buffer. */



/* A limit to the length of an address. RFC 2821 limits the local part to 64
and the domain to 255, so this should be adequate, taking into account quotings
etc. */



/* The length of the base names of spool files, which consist of an internal
message id with a trailing "-H" or "-D" added. */



/* The maximum number of message ids to store in a waiting database
record. */



/* Fixed option values for all PCRE functions */




/* Macros for trivial functions */





/* Options for dns_next_rr */

enum { RESET_NEXT, RESET_ANSWERS, RESET_AUTHORITY, RESET_ADDITIONAL };

/* Argument values for the time-of-day function */

enum { tod_log, tod_log_bare, tod_log_zone, tod_log_datestamp_daily,
       tod_log_datestamp_monthly, tod_zone, tod_full, tod_bsdin,
       tod_mbx, tod_epoch, tod_epoch_l, tod_zulu };

/* For identifying types of driver */

enum {
  DTYPE_NONE,
  DTYPE_ROUTER,
  DTYPE_TRANSPORT
};

/* Error numbers for generating error messages when reading a message on the
standard input. */

enum {
  ERRMESS_BADARGADDRESS, /* Bad address via argument list */
  ERRMESS_BADADDRESS, /* Bad address read via -t */
  ERRMESS_NOADDRESS, /* Message has no addresses */
  ERRMESS_IGADDRESS, /* All -t addresses ignored */
  ERRMESS_BADNOADDRESS, /* Bad address via -t, leaving none */
  ERRMESS_IOERR, /* I/O error while reading a message */
  ERRMESS_VLONGHEADER, /* Excessively long message header */
  ERRMESS_VLONGHDRLINE, /* Excessively long single line in header */
  ERRMESS_TOOBIG, /* Message too big */
  ERRMESS_TOOMANYRECIP, /* Too many recipients */
  ERRMESS_LOCAL_SCAN, /* Rejected by local scan */
  ERRMESS_LOCAL_ACL /* Rejected by non-SMTP ACL */
};

/* Error handling styles - set by option, and apply only when receiving
a local message not via SMTP. */

enum {
  ERRORS_SENDER, /* Return to sender (default) */
  ERRORS_STDERR /* Write on stderr */
};

/* Exec control values when Exim execs itself via child_exec_exim. */

enum {
  CEE_RETURN_ARGV, /* Don't exec, just build and return argv */
  CEE_EXEC_EXIT, /* Just exit if exec fails */
  CEE_EXEC_PANIC /* Panic-die if exec fails */
};

/* Bit values for filter_test */





/* Returns from the routing, transport and authentication functions (not all
apply to all of them). Some other functions also use these convenient values,
and some additional values are used only by non-driver functions.

OK, FAIL, DEFER, ERROR, and FAIL_FORCED are also declared in local_scan.h for
use in the local_scan() function and in ${dlfunc loaded functions. Do not
change them unilaterally. */






/***********/
# 277 "src/macros.h"
/* Returns from the deliver_message() function */






/* Returns from DNS lookup functions. */

enum { DNS_SUCCEED, DNS_NOMATCH, DNS_NODATA, DNS_AGAIN, DNS_FAIL };

/* Ending states when reading a message. The order is important. The test
for having to swallow the rest of an SMTP message is whether the value is
>= END_NOTENDED. */
# 299 "src/macros.h"
/* Options bits for debugging; D_v and D_local_scan are also in local_scan.h */
# 334 "src/macros.h"
/* The D_all value must always have all bits set, as it is recognized specially
by the function that decodes debug and log selectors. This is to enable it to
set all the bits in a multi-word selector. Debug doesn't use this yet, but we
are getting close. In fact, we want to omit "memory" for -d+all, but can't
handle this here. It is fudged externally. */
# 358 "src/macros.h"
/* Options bits for logging. Those that will end up in log_write_selector have
values < 0x80000000. They can be used in calls to log_write(). The others have
values > 0x80000000 and are put into log_extra_selector (without the top bit).
These are only ever tested independently. "All" is a magic value that is used
only in the name table to set all options in both bit maps. */

/* The L_all value must always have all bits set, as it is recognized specially
by the function that decodes debug and log selectors. This is to enable it to
set all the bits in a multi-word selector. */
# 429 "src/macros.h"
/* Private error numbers for delivery failures, set negative so as not
to conflict with system errno values. */
# 479 "src/macros.h"
/* These must be last, so all retry deferments can easily be identified */
# 488 "src/macros.h"
/* Special actions to take after failure or deferment. */

enum {
  SPECIAL_NONE, /* No special action */
  SPECIAL_FREEZE, /* Freeze message */
  SPECIAL_FAIL, /* Fail the delivery */
  SPECIAL_WARN /* Send a warning message */
};

/* Flags that get ORed into the more_errno field of an address to give more
information about errors for retry purposes. They are greater than 256, because
the bottom byte contains 'A' or 'M' for remote addresses, to indicate whether
the name was looked up only via an address record or whether MX records were
used, respectively. */



/* Permission and other options for parse_extract_addresses(),
filter_interpret(), and rda_interpret(), i.e. what special things are allowed
in redirection operations. Not all apply to all cases. Some of the bits allow
and some forbid, reflecting the "allow" and "forbid" options in the redirect
router, which were chosen to represent the standard situation for users'
.forward files. */
# 534 "src/macros.h"
/* This is the set that apply to expansions in filters */




/* As well as the RDO bits themselves, we need the bit numbers in order to
access (most of) the individual bits as separate options. This could be
automated, but I haven't bothered. Keep this list in step with the above! */

enum { RDON_BLACKHOLE, RDON_DEFER, RDON_EACCES, RDON_ENOTDIR, RDON_EXISTS,
  RDON_FAIL, RDON_FILTER, RDON_FREEZE, RDON_INCLUDE, RDON_LOG, RDON_LOOKUP,
  RDON_PERL, RDON_READFILE, RDON_READSOCK, RDON_RUN, RDON_DLFUNC, RDON_REALLOG,
  RDON_REWRITE, RDON_EXIM_FILTER, RDON_SIEVE_FILTER, RDON_PREPEND_HOME };

/* Results of filter or forward file processing. Some are only from a filter;
some are only from a forward file. */

enum {
  FF_DELIVERED, /* Success, took significant action */
  FF_NOTDELIVERED, /* Success, didn't take significant action */
  FF_BLACKHOLE, /* Blackholing requested */
  FF_DEFER, /* Defer requested */
  FF_FAIL, /* Fail requested */
  FF_INCLUDEFAIL, /* :include: failed */
  FF_NONEXIST, /* Forward file does not exist */
  FF_FREEZE, /* Freeze requested */
  FF_ERROR /* We have a problem */
};

/* Values for identifying particular headers; printing characters are used, so
they can be read in the spool file for those headers that are permanently
marked. The lower case values don't get onto the spool; they are used only as
return values from header_checkname(). */
# 585 "src/macros.h"
/* These values are used only when adding new headers from an ACL; they too
never get onto the spool. The type of the added header is set by reference
to the header name, by calling header_checkname(). */






/* Types of item in options lists. These are the bottom 8 bits of the "type"
field, which is an int. The opt_void value is used for entries in tables that
point to special types of value that are accessed only indirectly (e.g. the
rewrite data that is built out of a string option.) We need to have some values
visible in local_scan, so the following are declared there:

  opt_stringptr, opt_int, opt_octint, opt_mkint, opt_Kint, opt_fixed, opt_time,
  opt_bool

To make sure we don't conflict, the local_scan.h values start from zero, and
those defined here start from 32. The boolean ones must all be together so they
can be easily tested as a group. That is the only use of opt_bool_last. */

enum { opt_bit = 32, opt_bool_verify, opt_bool_set, opt_expand_bool,
  opt_bool_last,
  opt_rewrite, opt_timelist, opt_uid, opt_gid, opt_uidlist, opt_gidlist,
  opt_expand_uid, opt_expand_gid, opt_void };

/* There's a high-ish bit which is used to flag duplicate options, kept
for compatibility, which shouldn't be output. Also used for hidden options
that are automatically maintained from others. Another high bit is used to
flag driver options that although private (so as to be settable only on some
drivers), are stored in the instance block so as to be accessible from outside.
A third high bit is set when an option is read, so as to be able to give an
error if any option is set twice. Finally, there's a bit which is set when an
option is set with the "hide" prefix, to prevent -bP from showing it to
non-admin callers. The next byte up in the int is used to keep the bit number
for booleans that are kept in one bit. */







/* Verify types when directing and routing */

enum { v_none, v_sender, v_recipient, v_expn };

/* Option flags for verify_address() */
# 646 "src/macros.h"
/* Values for fields in callout cache records */






/* Options for lookup functions */





/* Status values for host_item blocks. Require hstatus_unusable and
hstatus_unusable_expired to be last. */

enum { hstatus_unknown, hstatus_usable, hstatus_unusable,
       hstatus_unusable_expired };

/* Reasons why a host is unusable (for clearer log messages) */

enum { hwhy_unknown, hwhy_retry, hwhy_failed, hwhy_deferred, hwhy_ignored };

/* Domain lookup types for routers */

enum { lk_default, lk_byname, lk_bydns };

/* Values for the self_code fields */

enum { self_freeze, self_defer, self_send, self_reroute, self_pass, self_fail };

/* Flags for rewrite rules */
# 701 "src/macros.h"
/* Flags for log_write(); LOG_MAIN, LOG_PANIC, and LOG_REJECT are also in
local_scan.h */
# 714 "src/macros.h"
/* and for debug_bits() logging action control: */


/* SMTP command identifiers for the smtp_connection_had field that records the
most recent SMTP commands. Must be kept in step with the list of names in
smtp_in.c that is used for creating the smtp_no_mail logging action. SCH_NONE
is "empty". */

enum { SCH_NONE, SCH_AUTH, SCH_DATA, SCH_EHLO, SCH_ETRN, SCH_EXPN, SCH_HELO,
       SCH_HELP, SCH_MAIL, SCH_NOOP, SCH_QUIT, SCH_RCPT, SCH_RSET, SCH_STARTTLS,
       SCH_VRFY };

/* Returns from host_find_by{name,dns}() */

enum {
  HOST_FIND_FAILED, /* failed to find the host */
  HOST_FIND_AGAIN, /* could not resolve at this time */
  HOST_FOUND, /* found host */
  HOST_FOUND_LOCAL, /* found, but MX points to local host */
  HOST_IGNORED /* found but ignored - used internally only */
};

/* Flags for host_find_bydns() */







/* Actions applied to specific messages. */

enum { MSG_DELIVER, MSG_FREEZE, MSG_REMOVE, MSG_THAW, MSG_ADD_RECIPIENT,
       MSG_MARK_ALL_DELIVERED, MSG_MARK_DELIVERED, MSG_EDIT_SENDER,
       MSG_SHOW_COPY, MSG_LOAD,
       /* These ones must be last: a test for >= MSG_SHOW_BODY is used
       to test for actions that list individual spool files. */
       MSG_SHOW_BODY, MSG_SHOW_HEADER, MSG_SHOW_LOG };

/* Returns from the spool_read_header() function */

enum {
  spool_read_OK, /* success */
  spool_read_notopen, /* open failed */
  spool_read_enverror, /* error in the envelope */
  spool_read_hdrerror /* error in the headers */
};

/* Options for transport_write_message */
# 773 "src/macros.h"
/* Codes for the host_find_failed and host_all_ignored options. */
# 782 "src/macros.h"
/* Router information flags */




/* Codes for match types in match_check_list; to any of them, MCL_NOEXPAND may
be added */



enum { MCL_STRING, MCL_DOMAIN, MCL_HOST, MCL_ADDRESS, MCL_LOCALPART };

/* Codes for the places from which ACLs can be called. These are cunningly
ordered to make it easy to implement tests for certain ACLs when processing
"control" modifiers, by means of a maximum "where" value. Do not modify this
order without checking carefully!

**** IMPORTANT***
****   Furthermore, remember to keep these in step with the tables
****   of names and response codes in globals.c.
**** IMPORTANT ****
*/

enum { ACL_WHERE_RCPT, /* Some controls are for RCPT only */
       ACL_WHERE_MAIL, /* )                                           */
       ACL_WHERE_PREDATA, /* ) There are several tests for "in message", */
       ACL_WHERE_MIME, /* ) implemented by <= WHERE_NOTSMTP           */
       ACL_WHERE_DKIM, /* )                                           */
       ACL_WHERE_DATA, /* )                                           */
       ACL_WHERE_NOTSMTP, /* )                                           */

       ACL_WHERE_AUTH, /* These remaining ones are not currently    */
       ACL_WHERE_CONNECT, /* required to be in a special order so they */
       ACL_WHERE_ETRN, /* are just alphabetical.                    */
       ACL_WHERE_EXPN,
       ACL_WHERE_HELO,
       ACL_WHERE_MAILAUTH,
       ACL_WHERE_NOTSMTP_START,
       ACL_WHERE_NOTQUIT,
       ACL_WHERE_QUIT,
       ACL_WHERE_STARTTLS,
       ACL_WHERE_VRFY
     };

/* Situations for spool_write_header() */

enum { SW_RECEIVING, SW_DELIVERING, SW_MODIFYING };

/* MX fields for hosts not obtained from MX records are always negative.
MX_NONE is the default case; lesser values are used when the hosts are
randomized in batches. */



/* host_item.port defaults to PORT_NONE; the only current case where this
is changed before running the transport is when an dnslookup router sets an
explicit port number. */



/* Flags for single-key search defaults */




/* Filter types */

enum { FILTER_UNSET, FILTER_FORWARD, FILTER_EXIM, FILTER_SIEVE };

/* End of macros.h */
# 5 "src/tls-gnu.c" 2
typedef int BOOL;
typedef unsigned char uschar;
typedef long int time_t;
typedef struct address_item_propagated {
  uschar *address_data; /* arbitrary data to keep with the address */
  uschar *domain_data; /* from "domains" lookup */
  uschar *localpart_data; /* from "local_parts" lookup */
  uschar *errors_address; /* where to send errors (NULL => sender) */
  header_line *extra_headers; /* additional headers */
  uschar *remove_headers; /* list of those to remove */




} address_item_propagated;
typedef struct retry_item {
  struct retry_item *next; /* for chaining */
  uschar *key; /* string identifying host/address/message */
  int basic_errno; /* error code for this destination */
  int more_errno; /* additional error information */
  uschar *message; /* local error message */
  int flags; /* see below */
} retry_item;
typedef struct reply_item {
  uschar *from; /* ) */
  uschar *reply_to; /* ) */
  uschar *to; /* ) */
  uschar *cc; /* ) specific header fields */
  uschar *bcc; /* ) */
  uschar *subject; /* ) */
  uschar *headers; /* misc other headers, concatenated */
  uschar *text; /* text string body */
  uschar *file; /* file body */
  BOOL file_expand; /* expand the body */
  int expand_forbid; /* expansion lockout flags */
  uschar *logfile; /* file to keep a log in */
  uschar *oncelog; /* file to keep records in for once only */
  time_t once_repeat; /* time to repeat "once only" */
  BOOL return_message; /* send back the original message */
} reply_item;
typedef struct host_item {
  struct host_item *next;
  uschar *name; /* Host name */
  uschar *address; /* IP address in text form */
  int port; /* port value in host order (if SRV lookup) */
  int mx; /* MX value if found via MX records */
  int sort_key; /* MX*1000 plus random "fraction" */
  int status; /* Usable, unusable, or unknown */
  int why; /* Why host is unusable */
  int last_try; /* Time of last try if known */
} host_item;
typedef struct rewrite_rule {
  struct rewrite_rule *next;
  int flags;
  uschar *key;
  uschar *replacement;
} rewrite_rule;
typedef unsigned int uid_t;
typedef unsigned int gid_t;
typedef struct transport_instance {
  struct transport_instance *next;
  uschar *name; /* Instance name */
  struct transport_info *info; /* Info for this driver */
  void *options_block; /* Pointer to private options */
  uschar *driver_name; /* Must be first */
  int (*setup)( /* Setup entry point */
    struct transport_instance *,
    struct address_item *,
    struct transport_feedback *, /* For passing back config data */
    uid_t, /* The uid that will be used */
    gid_t, /* The gid that will be used */
    uschar **); /* For an error message */
                                  /**************************************/
  int batch_max; /* )                                  */
  uschar *batch_id; /* )                                  */
  uschar *home_dir; /* ) Used only for local transports   */
  uschar *current_dir; /* )                                  */
                                  /**************************************/
  BOOL multi_domain; /* )                                  */
  BOOL overrides_hosts; /* ) Used only for remote transports  */
  int max_addresses; /* )                                  */
  int connection_max_messages;/* )                                  */
                                  /**************************************/
  BOOL deliver_as_creator; /* Used only by pipe at present */
  BOOL disable_logging; /* For very weird requirements */
  BOOL initgroups; /* Initialize groups when setting uid */
  BOOL uid_set; /* uid is set */
  BOOL gid_set; /* gid is set */
  uid_t uid;
  gid_t gid;
  uschar *expand_uid; /* Variable uid */
  uschar *expand_gid; /* Variable gid */
  uschar *warn_message; /* Used only by appendfile at present */
  uschar *shadow; /* Name of shadow transport */
  uschar *shadow_condition; /* Condition for running it */
  uschar *filter_command; /* For on-the-fly-filtering */
  uschar *add_headers; /* Add these headers */
  uschar *remove_headers; /* Remove these headers */
  uschar *return_path; /* Overriding (rewriting) return path */
  uschar *debug_string; /* Debugging output */
  uschar *message_size_limit; /* Biggest message this transport handles */
  uschar *headers_rewrite; /* Rules for rewriting headers */
  rewrite_rule *rewrite_rules; /* Parsed rewriting rules */
  int rewrite_existflags; /* Bits showing which headers are rewritten */
  int filter_timeout; /* For transport filter timing */
  BOOL body_only; /* Deliver only the body */
  BOOL delivery_date_add; /* Add Delivery-Date header */
  BOOL envelope_to_add; /* Add Envelope-To header */
  BOOL headers_only; /* Deliver only the headers */
  BOOL rcpt_include_affixes; /* TRUE to retain affixes in RCPT commands */
  BOOL return_path_add; /* Add Return-Path header */
  BOOL return_output; /* TRUE if output should always be returned */
  BOOL return_fail_output; /* ditto, but only on failure */
  BOOL log_output; /* Similarly for logging */
  BOOL log_fail_output;
  BOOL log_defer_output;
  BOOL retry_use_local_part; /* Defaults true for local, false for remote */
} transport_instance;
typedef struct router_instance {
  struct router_instance *next;
  uschar *name;
  struct router_info *info;
  void *options_block; /* Pointer to private options */
  uschar *driver_name; /* Must be first */

  uschar *address_data; /* Arbitrary data */



  uschar *cannot_route_message; /* Used when routing fails */
  uschar *condition; /* General condition */
  uschar *current_directory; /* For use during delivery */
  uschar *debug_string; /* Debugging output */
  uschar *domains; /* Specific domains */
  uschar *errors_to; /* Errors address */
  uschar *expand_gid; /* Expanded gid string */
  uschar *expand_uid; /* Expanded uid string */
  uschar *expand_more; /* Expanded more string */
  uschar *expand_unseen; /* Expanded unseen string */
  uschar *extra_headers; /* Additional headers */
  uschar *fallback_hosts; /* For remote transports (text list) */
  uschar *home_directory; /* For use during delivery */
  uschar *ignore_target_hosts; /* Target hosts to ignore */
  uschar *local_parts; /* Specific local parts */
  uschar *pass_router_name; /* Router for passed address */
  uschar *prefix; /* Address prefix */
  uschar *redirect_router_name; /* Router for generated address */
  uschar *remove_headers; /* Removed headers */
  uschar *require_files; /* File checks before router is run */
  uschar *router_home_directory; /* For use while routing */
  uschar *self; /* Text option for handling self reference */
  uschar *senders; /* Specific senders */
  uschar *suffix; /* Address suffix */
  uschar *translate_ip_address; /* IP address translation fudgery */
  uschar *transport_name; /* Transport name */

  BOOL address_test; /* Use this router when testing addresses */





  BOOL expn; /* Use this router when processing EXPN */
  BOOL caseful_local_part; /* TRUE => don't lowercase */
  BOOL check_local_user; /* TRUE => check local user */
  BOOL disable_logging; /* For very weird requirements */
  BOOL fail_verify_recipient; /* Fail verify if recipient match this router */
  BOOL fail_verify_sender; /* Fail verify if sender match this router */
  BOOL gid_set; /* Flag to indicate gid is set */
  BOOL initgroups; /* TRUE if initgroups is required */
  BOOL log_as_local; /* TRUE logs as a local delivery */
  BOOL more; /* If FALSE, do no more if this one fails */
  BOOL pass_on_timeout; /* Treat timeout DEFERs as fails */
  BOOL prefix_optional; /* Just what it says */
  BOOL repeat_use; /* If FALSE, skip if ancestor used it */
  BOOL retry_use_local_part; /* Just what it says */
  BOOL same_domain_copy_routing; /* TRUE => copy routing for same domain */
  BOOL self_rewrite; /* TRUE to rewrite headers if making local */
  BOOL suffix_optional; /* As it says */
  BOOL verify_only; /* Skip this router if not verifying */
  BOOL verify_recipient; /* Use this router when verifying a recipient*/
  BOOL verify_sender; /* Use this router when verifying a sender */
  BOOL uid_set; /* Flag to indicate uid is set */
  BOOL unseen; /* If TRUE carry on, even after success */

  int self_code; /* Encoded version of "self" */
  uid_t uid; /* Fixed uid value */
  gid_t gid; /* Fixed gid value */

  host_item *fallback_hostlist; /* For remote transport (block chain) */
  transport_instance *transport; /* Transport block (when found) */
  struct router_instance *pass_router; /* Actual router for passed address */
  struct router_instance *redirect_router; /* Actual router for generated address */
} router_instance;
typedef struct address_item {
  struct address_item *next; /* for chaining addresses */
  struct address_item *parent; /* parent address */
  struct address_item *first; /* points to first after group delivery */
  struct address_item *dupof; /* points to address this is a duplicate of */

  router_instance *start_router; /* generated address starts here */
  router_instance *router; /* the router that routed */
  transport_instance *transport; /* the transport to use */

  host_item *host_list; /* host data for the transport */
  host_item *host_used; /* host that took delivery or failed hard */
  host_item *fallback_hosts; /* to try if delivery defers */

  reply_item *reply; /* data for autoreply */
  retry_item *retries; /* chain of retry information */

  uschar *address; /* address being delivered or routed */
  uschar *unique; /* used for disambiguating */
  uschar *cc_local_part; /* caseful local part */
  uschar *lc_local_part; /* lowercased local part */
  uschar *local_part; /* points to cc or lc version */
  uschar *prefix; /* stripped prefix of local part */
  uschar *suffix; /* stripped suffix of local part */
  uschar *domain; /* working domain (lower cased) */

  uschar *address_retry_key; /* retry key including full address */
  uschar *domain_retry_key; /* retry key for domain only */

  uschar *current_dir; /* current directory for transporting */
  uschar *home_dir; /* home directory for transporting */
  uschar *message; /* error message */
  uschar *user_message; /* error message that can be sent over SMTP
                                     or quoted in bounce message */
  uschar *onetime_parent; /* saved original parent for onetime */
  uschar **pipe_expandn; /* numeric expansions for pipe from filter */
  uschar *return_filename; /* name of return file */
  uschar *self_hostname; /* after self=pass */
  uschar *shadow_message; /* info about shadow transporting */






  uid_t uid; /* uid for transporting */
  gid_t gid; /* gid for transporting */

  unsigned int flags; /* a row of bits, defined above */
  unsigned int domain_cache[(16 * 2)/32];
  unsigned int localpart_cache[(16 * 2)/32];
  int mode; /* mode for local transporting to a file */
  int more_errno; /* additional error information */
                                  /* (may need to hold a timestamp) */

  short int basic_errno; /* status after failure */
  short int child_count; /* number of child addresses */
  short int return_file; /* fileno of return data file */
  short int special_action; /* ( used when when deferred or failed */
                                  /* (  also  */
                                  /* ( contains = or - when successful SMTP delivered */
                                  /* (  also  */
                                  /* ( contains verify rc in sender verify cache */
  short int transport_return; /* result of delivery attempt */
  address_item_propagated p; /* fields that are propagated to children */
} address_item;
/*************************************************
*     Exim - an Internet mail transport agent    *
*************************************************/

/* Copyright (c) University of Cambridge 1995 - 2012 */
/* See the file NOTICE for conditions of use and distribution. */

/* Copyright (c) Phil Pennock 2012 */

/* This file provides TLS/SSL support for Exim using the GnuTLS library,
one of the available supported implementations.  This file is #included into
tls.c when USE_GNUTLS has been set.

The code herein is a revamp of GnuTLS integration using the current APIs; the
original tls-gnu.c was based on a patch which was contributed by Nikos
Mavroyanopoulos.  The revamp is partially a rewrite, partially cut&paste as
appropriate.

APIs current as of GnuTLS 2.12.18; note that the GnuTLS manual is for GnuTLS 3,
which is not widely deployed by OS vendors.  Will note issues below, which may
assist in updating the code in the future.  Another sources of hints is
mod_gnutls for Apache (SNI callback registration and handling).

Keeping client and server variables more split than before and is currently
the norm, in anticipation of TLS in ACL callouts.

I wanted to switch to gnutls_certificate_set_verify_function() so that
certificate rejection could happen during handshake where it belongs, rather
than being dropped afterwards, but that was introduced in 2.10.0 and Debian
(6.0.5) is still on 2.8.6.  So for now we have to stick with sub-par behaviour.

(I wasn't looking for libraries quite that old, when updating to get rid of
compiler warnings of deprecated APIs.  If it turns out that a lot of the rest
require current GnuTLS, then we'll drop support for the ancient libraries).
*/

# 1 "/usr/include/gnutls/gnutls.h" 1 3 4
/* -*- c -*-
 * Copyright (C) 2000-2012 Free Software Foundation, Inc.
 *
 * Author: Nikos Mavrogiannopoulos
 *
 * This file is part of GnuTLS.
 *
 * The GnuTLS is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 */

/* This file contains the types and prototypes for all the
 * high level functionality of the gnutls main library.
 *
 * If the optional C++ binding was built, it is available in
 * gnutls/gnutlsxx.h.
 *
 * The openssl compatibility layer (which is under the GNU GPL
 * license) is in gnutls/openssl.h.
 *
 * The low level cipher functionality is in gnutls/crypto.h.
 */





/* Get size_t. */
# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */





/* snaroff@next.com says the NeXT needs this.  */




/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 147 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 279 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since 
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." */
# 306 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... */
# 324 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
typedef int wchar_t;
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 41 "/usr/include/gnutls/gnutls.h" 2 3 4
/* Get ssize_t. */


/* *INDENT-OFF* */
# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 46 "/usr/include/gnutls/gnutls.h" 2 3 4
/* *INDENT-ON* */

/* Get time_t. */
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */






# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 28 "/usr/include/time.h" 2 3 4






/* Get size_t and NULL from <stddef.h>.  */


# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2013 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 157 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 358 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 394 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 38 "/usr/include/time.h" 2 3 4

/* This defines CLOCKS_PER_SEC, which is the number of processor clock
   ticks per second.  */
# 1 "/usr/include/bits/time.h" 1 3 4
/* System-dependent timing definitions.  Linux version.
   Copyright (C) 1996,1997,1999-2003,2010,2011,2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <time.h> instead.
 */
# 42 "/usr/include/bits/time.h" 3 4
/* ISO/IEC 9899:1990 7.12.1: <time.h>
   The macro `CLOCKS_PER_SEC' is the number per second of the value
   returned by the `clock' function. */
/* CAE XSH, Issue 4, Version 2: <time.h>
   The value of CLOCKS_PER_SEC is required to be 1 million on all
   XSI-conformant systems. */
# 42 "/usr/include/time.h" 2 3 4

/* This is the obsolete POSIX.1-1988 name for the same constant.  */
# 55 "/usr/include/time.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2012 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 56 "/usr/include/time.h" 2 3 4


/* Returned by `clock'.  */
typedef __clock_t clock_t;

# 131 "/usr/include/time.h" 3 4

/* Used by other time functions.  */
struct tm
{
  int tm_sec; /* Seconds.	[0-60] (1 leap second) */
  int tm_min; /* Minutes.	[0-59] */
  int tm_hour; /* Hours.	[0-23] */
  int tm_mday; /* Day.		[1-31] */
  int tm_mon; /* Month.	[0-11] */
  int tm_year; /* Year	- 1900.  */
  int tm_wday; /* Day of week.	[0-6] */
  int tm_yday; /* Days in year.[0-365]	*/
  int tm_isdst; /* DST.		[-1/0/1]*/





  long int __tm_gmtoff; /* Seconds east of UTC.  */
  const char *__tm_zone; /* Timezone abbreviation.  */

};

# 186 "/usr/include/time.h" 3 4

/* Time used by the program so far (user time + system time).
   The result / CLOCKS_PER_SECOND is program time in seconds.  */
extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));

/* Return the current time and put it in *TIMER if TIMER is not NULL.  */
extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));

/* Return the difference between TIME1 and TIME0.  */
extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return the `time_t' representation of TP and normalize TP.  */
extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE characters and return the number
   of characters written, or 0 if it would exceed MAXSIZE.  */
extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));

# 236 "/usr/include/time.h" 3 4

/* Return the `struct tm' representation of *TIMER
   in Universal Coordinated Time (aka Greenwich Mean Time).  */
extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));

/* Return the `struct tm' representation
   of *TIMER in the local timezone.  */
extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));

# 258 "/usr/include/time.h" 3 4

/* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));

/* Equivalent to `asctime (localtime (timer))'.  */
extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));

# 281 "/usr/include/time.h" 3 4
/* Defined in localtime.c.  */
extern char *__tzname[2]; /* Current timezone names.  */
extern int __daylight; /* If daylight-saving time is ever in use.  */
extern long int __timezone; /* Seconds west of UTC.  */
# 308 "/usr/include/time.h" 3 4
/* Nonzero if YEAR is a leap year (every 4 years,
   except every 100th isn't, and every 400th is).  */
# 430 "/usr/include/time.h" 3 4

# 50 "/usr/include/gnutls/gnutls.h" 2 3 4
# 68 "/usr/include/gnutls/gnutls.h" 3 4
/**
 * gnutls_cipher_algorithm_t:
 * @GNUTLS_CIPHER_UNKNOWN: Unknown algorithm.
 * @GNUTLS_CIPHER_NULL: NULL algorithm.
 * @GNUTLS_CIPHER_ARCFOUR_128: ARCFOUR stream cipher with 128-bit keys.
 * @GNUTLS_CIPHER_3DES_CBC: 3DES in CBC mode.
 * @GNUTLS_CIPHER_AES_128_CBC: AES in CBC mode with 128-bit keys.
 * @GNUTLS_CIPHER_AES_192_CBC: AES in CBC mode with 192-bit keys.
 * @GNUTLS_CIPHER_AES_256_CBC: AES in CBC mode with 256-bit keys.
 * @GNUTLS_CIPHER_ARCFOUR_40: ARCFOUR stream cipher with 40-bit keys.
 * @GNUTLS_CIPHER_CAMELLIA_128_CBC: Camellia in CBC mode with 128-bit keys.
 * @GNUTLS_CIPHER_CAMELLIA_192_CBC: Camellia in CBC mode with 192-bit keys.
 * @GNUTLS_CIPHER_CAMELLIA_256_CBC: Camellia in CBC mode with 256-bit keys.
 * @GNUTLS_CIPHER_RC2_40_CBC: RC2 in CBC mode with 40-bit keys.
 * @GNUTLS_CIPHER_DES_CBC: DES in CBC mode (56-bit keys).
 * @GNUTLS_CIPHER_AES_128_GCM: AES in GCM mode with 128-bit keys.
 * @GNUTLS_CIPHER_AES_256_GCM: AES in GCM mode with 256-bit keys.
 * @GNUTLS_CIPHER_IDEA_PGP_CFB: IDEA in CFB mode.
 * @GNUTLS_CIPHER_3DES_PGP_CFB: 3DES in CFB mode.
 * @GNUTLS_CIPHER_CAST5_PGP_CFB: CAST5 in CFB mode.
 * @GNUTLS_CIPHER_BLOWFISH_PGP_CFB: Blowfish in CFB mode.
 * @GNUTLS_CIPHER_SAFER_SK128_PGP_CFB: Safer-SK in CFB mode with 128-bit keys.
 * @GNUTLS_CIPHER_AES128_PGP_CFB: AES in CFB mode with 128-bit keys.
 * @GNUTLS_CIPHER_AES192_PGP_CFB: AES in CFB mode with 192-bit keys.
 * @GNUTLS_CIPHER_AES256_PGP_CFB: AES in CFB mode with 256-bit keys.
 * @GNUTLS_CIPHER_TWOFISH_PGP_CFB: Twofish in CFB mode.
 *
 * Enumeration of different symmetric encryption algorithms.
 */
  typedef enum gnutls_cipher_algorithm
  {
    GNUTLS_CIPHER_UNKNOWN = 0,
    GNUTLS_CIPHER_NULL = 1,
    GNUTLS_CIPHER_ARCFOUR_128 = 2,
    GNUTLS_CIPHER_3DES_CBC = 3,
    GNUTLS_CIPHER_AES_128_CBC = 4,
    GNUTLS_CIPHER_AES_256_CBC = 5,
    GNUTLS_CIPHER_ARCFOUR_40 = 6,
    GNUTLS_CIPHER_CAMELLIA_128_CBC = 7,
    GNUTLS_CIPHER_CAMELLIA_256_CBC = 8,
    GNUTLS_CIPHER_RC2_40_CBC = 90,
    GNUTLS_CIPHER_DES_CBC = 91,
    GNUTLS_CIPHER_AES_192_CBC = 92,
    GNUTLS_CIPHER_AES_128_GCM = 93,
    GNUTLS_CIPHER_AES_256_GCM = 94,
    GNUTLS_CIPHER_CAMELLIA_192_CBC = 95,
    GNUTLS_CIPHER_SALSA20_256 = 96,
    GNUTLS_CIPHER_ESTREAM_SALSA20_256 = 97,

    /* used only for PGP internals. Ignored in TLS/SSL
     */
    GNUTLS_CIPHER_IDEA_PGP_CFB = 200,
    GNUTLS_CIPHER_3DES_PGP_CFB = 201,
    GNUTLS_CIPHER_CAST5_PGP_CFB = 202,
    GNUTLS_CIPHER_BLOWFISH_PGP_CFB = 203,
    GNUTLS_CIPHER_SAFER_SK128_PGP_CFB = 204,
    GNUTLS_CIPHER_AES128_PGP_CFB = 205,
    GNUTLS_CIPHER_AES192_PGP_CFB = 206,
    GNUTLS_CIPHER_AES256_PGP_CFB = 207,
    GNUTLS_CIPHER_TWOFISH_PGP_CFB = 208
  } gnutls_cipher_algorithm_t;

/**
 * gnutls_kx_algorithm_t:
 * @GNUTLS_KX_UNKNOWN: Unknown key-exchange algorithm.
 * @GNUTLS_KX_RSA: RSA key-exchange algorithm.
 * @GNUTLS_KX_DHE_DSS: DHE-DSS key-exchange algorithm.
 * @GNUTLS_KX_DHE_RSA: DHE-RSA key-exchange algorithm.
 * @GNUTLS_KX_ECDHE_RSA: ECDHE-RSA key-exchange algorithm.
 * @GNUTLS_KX_ECDHE_ECDSA: ECDHE-ECDSA key-exchange algorithm.
 * @GNUTLS_KX_ANON_DH: Anon-DH key-exchange algorithm.
 * @GNUTLS_KX_ANON_ECDH: Anon-ECDH key-exchange algorithm.
 * @GNUTLS_KX_SRP: SRP key-exchange algorithm.
 * @GNUTLS_KX_RSA_EXPORT: RSA-EXPORT key-exchange algorithm (defunc).
 * @GNUTLS_KX_SRP_RSA: SRP-RSA key-exchange algorithm.
 * @GNUTLS_KX_SRP_DSS: SRP-DSS key-exchange algorithm.
 * @GNUTLS_KX_PSK: PSK key-exchange algorithm.
 * @GNUTLS_KX_DHE_PSK: DHE-PSK key-exchange algorithm.
 * @GNUTLS_KX_ECDHE_PSK: ECDHE-PSK key-exchange algorithm.
 *
 * Enumeration of different key exchange algorithms.
 */
  typedef enum
  {
    GNUTLS_KX_UNKNOWN = 0,
    GNUTLS_KX_RSA = 1,
    GNUTLS_KX_DHE_DSS = 2,
    GNUTLS_KX_DHE_RSA = 3,
    GNUTLS_KX_ANON_DH = 4,
    GNUTLS_KX_SRP = 5,
    GNUTLS_KX_RSA_EXPORT = 6,
    GNUTLS_KX_SRP_RSA = 7,
    GNUTLS_KX_SRP_DSS = 8,
    GNUTLS_KX_PSK = 9,
    GNUTLS_KX_DHE_PSK = 10,
    GNUTLS_KX_ANON_ECDH = 11,
    GNUTLS_KX_ECDHE_RSA = 12,
    GNUTLS_KX_ECDHE_ECDSA = 13,
    GNUTLS_KX_ECDHE_PSK = 14,
  } gnutls_kx_algorithm_t;

/**
 * gnutls_params_type_t:
 * @GNUTLS_PARAMS_RSA_EXPORT: Session RSA-EXPORT parameters (defunc).
 * @GNUTLS_PARAMS_DH: Session Diffie-Hellman parameters.
 * @GNUTLS_PARAMS_ECDH: Session Elliptic-Curve Diffie-Hellman parameters.
 *
 * Enumeration of different TLS session parameter types.
 */
  typedef enum
  {
    GNUTLS_PARAMS_RSA_EXPORT = 1,
    GNUTLS_PARAMS_DH = 2,
    GNUTLS_PARAMS_ECDH = 3,
  } gnutls_params_type_t;

/**
 * gnutls_credentials_type_t:
 * @GNUTLS_CRD_CERTIFICATE: Certificate credential.
 * @GNUTLS_CRD_ANON: Anonymous credential.
 * @GNUTLS_CRD_SRP: SRP credential.
 * @GNUTLS_CRD_PSK: PSK credential.
 * @GNUTLS_CRD_IA: IA credential.
 *
 * Enumeration of different credential types.
 */
  typedef enum
  {
    GNUTLS_CRD_CERTIFICATE = 1,
    GNUTLS_CRD_ANON,
    GNUTLS_CRD_SRP,
    GNUTLS_CRD_PSK,
    GNUTLS_CRD_IA
  } gnutls_credentials_type_t;




/**
 * gnutls_mac_algorithm_t:
 * @GNUTLS_MAC_UNKNOWN: Unknown MAC algorithm.
 * @GNUTLS_MAC_NULL: NULL MAC algorithm (empty output).
 * @GNUTLS_MAC_MD5: HMAC-MD5 algorithm.
 * @GNUTLS_MAC_SHA1: HMAC-SHA-1 algorithm.
 * @GNUTLS_MAC_RMD160: HMAC-RMD160 algorithm.
 * @GNUTLS_MAC_MD2: HMAC-MD2 algorithm.
 * @GNUTLS_MAC_SHA256: HMAC-SHA-256 algorithm.
 * @GNUTLS_MAC_SHA384: HMAC-SHA-384 algorithm.
 * @GNUTLS_MAC_SHA512: HMAC-SHA-512 algorithm.
 * @GNUTLS_MAC_SHA224: HMAC-SHA-224 algorithm.
 * @GNUTLS_MAC_AEAD: MAC implicit through AEAD cipher.
 *
 * Enumeration of different Message Authentication Code (MAC)
 * algorithms.
 */
  typedef enum
  {
    GNUTLS_MAC_UNKNOWN = 0,
    GNUTLS_MAC_NULL = 1,
    GNUTLS_MAC_MD5 = 2,
    GNUTLS_MAC_SHA1 = 3,
    GNUTLS_MAC_RMD160 = 4,
    GNUTLS_MAC_MD2 = 5,
    GNUTLS_MAC_SHA256 = 6,
    GNUTLS_MAC_SHA384 = 7,
    GNUTLS_MAC_SHA512 = 8,
    GNUTLS_MAC_SHA224 = 9,
      /* If you add anything here, make sure you align with
         gnutls_digest_algorithm_t. */
    GNUTLS_MAC_AEAD = 200, /* indicates that MAC is on the cipher */
    GNUTLS_MAC_UMAC_96 = 201,
    GNUTLS_MAC_UMAC_128 = 202,
  } gnutls_mac_algorithm_t;

/**
 * gnutls_digest_algorithm_t:
 * @GNUTLS_DIG_UNKNOWN: Unknown hash algorithm.
 * @GNUTLS_DIG_NULL: NULL hash algorithm (empty output).
 * @GNUTLS_DIG_MD5: MD5 algorithm.
 * @GNUTLS_DIG_SHA1: SHA-1 algorithm.
 * @GNUTLS_DIG_RMD160: RMD160 algorithm.
 * @GNUTLS_DIG_MD2: MD2 algorithm.
 * @GNUTLS_DIG_SHA256: SHA-256 algorithm.
 * @GNUTLS_DIG_SHA384: SHA-384 algorithm.
 * @GNUTLS_DIG_SHA512: SHA-512 algorithm.
 * @GNUTLS_DIG_SHA224: SHA-224 algorithm.
 *
 * Enumeration of different digest (hash) algorithms.
 */
  typedef enum
  {
    GNUTLS_DIG_UNKNOWN = GNUTLS_MAC_UNKNOWN,
    GNUTLS_DIG_NULL = GNUTLS_MAC_NULL,
    GNUTLS_DIG_MD5 = GNUTLS_MAC_MD5,
    GNUTLS_DIG_SHA1 = GNUTLS_MAC_SHA1,
    GNUTLS_DIG_RMD160 = GNUTLS_MAC_RMD160,
    GNUTLS_DIG_MD2 = GNUTLS_MAC_MD2,
    GNUTLS_DIG_SHA256 = GNUTLS_MAC_SHA256,
    GNUTLS_DIG_SHA384 = GNUTLS_MAC_SHA384,
    GNUTLS_DIG_SHA512 = GNUTLS_MAC_SHA512,
    GNUTLS_DIG_SHA224 = GNUTLS_MAC_SHA224
      /* If you add anything here, make sure you align with
         gnutls_mac_algorithm_t. */
  } gnutls_digest_algorithm_t;

  /* exported for other gnutls headers. This is the maximum number of
   * algorithms (ciphers, kx or macs).
   */


/**
 * gnutls_compression_method_t:
 * @GNUTLS_COMP_UNKNOWN: Unknown compression method.
 * @GNUTLS_COMP_NULL: The NULL compression method (no compression).
 * @GNUTLS_COMP_DEFLATE: The DEFLATE compression method from zlib.
 * @GNUTLS_COMP_ZLIB: Same as %GNUTLS_COMP_DEFLATE.
 *
 * Enumeration of different TLS compression methods.
 */
  typedef enum
  {
    GNUTLS_COMP_UNKNOWN = 0,
    GNUTLS_COMP_NULL = 1,
    GNUTLS_COMP_DEFLATE = 2,
    GNUTLS_COMP_ZLIB = GNUTLS_COMP_DEFLATE,
  } gnutls_compression_method_t;

  /*
   * Flags for gnutls_init()
   *
   * @GNUTLS_SERVER: Connection end is a server.
   * @GNUTLS_CLIENT: Connection end is a client.
   * @GNUTLS_DATAGRAM: Connection is datagram oriented (DTLS).
   * @GNUTLS_NONBLOCK: Connection should not block (DTLS).
   * @GNUTLS_NO_EXTENSIONS: Do not enable any TLS extensions by default.
   *
   */






/**
 * gnutls_alert_level_t:
 * @GNUTLS_AL_WARNING: Alert of warning severity.
 * @GNUTLS_AL_FATAL: Alert of fatal severity.
 *
 * Enumeration of different TLS alert severities.
 */
  typedef enum
  {
    GNUTLS_AL_WARNING = 1,
    GNUTLS_AL_FATAL
  } gnutls_alert_level_t;

/**
 * gnutls_alert_description_t:
 * @GNUTLS_A_CLOSE_NOTIFY: Close notify.
 * @GNUTLS_A_UNEXPECTED_MESSAGE: Unexpected message.
 * @GNUTLS_A_BAD_RECORD_MAC: Bad record MAC.
 * @GNUTLS_A_DECRYPTION_FAILED: Decryption failed.
 * @GNUTLS_A_RECORD_OVERFLOW: Record overflow.
 * @GNUTLS_A_DECOMPRESSION_FAILURE: Decompression failed.
 * @GNUTLS_A_HANDSHAKE_FAILURE: Handshake failed.
 * @GNUTLS_A_SSL3_NO_CERTIFICATE: No certificate.
 * @GNUTLS_A_BAD_CERTIFICATE: Certificate is bad.
 * @GNUTLS_A_UNSUPPORTED_CERTIFICATE: Certificate is not supported.
 * @GNUTLS_A_CERTIFICATE_REVOKED: Certificate was revoked.
 * @GNUTLS_A_CERTIFICATE_EXPIRED: Certificate is expired.
 * @GNUTLS_A_CERTIFICATE_UNKNOWN: Unknown certificate.
 * @GNUTLS_A_ILLEGAL_PARAMETER: Illegal parameter.
 * @GNUTLS_A_UNKNOWN_CA: CA is unknown.
 * @GNUTLS_A_ACCESS_DENIED: Access was denied.
 * @GNUTLS_A_DECODE_ERROR: Decode error.
 * @GNUTLS_A_DECRYPT_ERROR: Decrypt error.
 * @GNUTLS_A_EXPORT_RESTRICTION: Export restriction.
 * @GNUTLS_A_PROTOCOL_VERSION: Error in protocol version.
 * @GNUTLS_A_INSUFFICIENT_SECURITY: Insufficient security.
 * @GNUTLS_A_USER_CANCELED: User canceled.
 * @GNUTLS_A_INTERNAL_ERROR: Internal error.
 * @GNUTLS_A_NO_RENEGOTIATION: No renegotiation is allowed.
 * @GNUTLS_A_CERTIFICATE_UNOBTAINABLE: Could not retrieve the
 *   specified certificate.
 * @GNUTLS_A_UNSUPPORTED_EXTENSION: An unsupported extension was
 *   sent.
 * @GNUTLS_A_UNRECOGNIZED_NAME: The server name sent was not
 *   recognized.
 * @GNUTLS_A_UNKNOWN_PSK_IDENTITY: The SRP/PSK username is missing
 *   or not known.
 *
 * Enumeration of different TLS alerts.
 */
  typedef enum
  {
    GNUTLS_A_CLOSE_NOTIFY,
    GNUTLS_A_UNEXPECTED_MESSAGE = 10,
    GNUTLS_A_BAD_RECORD_MAC = 20,
    GNUTLS_A_DECRYPTION_FAILED,
    GNUTLS_A_RECORD_OVERFLOW,
    GNUTLS_A_DECOMPRESSION_FAILURE = 30,
    GNUTLS_A_HANDSHAKE_FAILURE = 40,
    GNUTLS_A_SSL3_NO_CERTIFICATE = 41,
    GNUTLS_A_BAD_CERTIFICATE = 42,
    GNUTLS_A_UNSUPPORTED_CERTIFICATE,
    GNUTLS_A_CERTIFICATE_REVOKED,
    GNUTLS_A_CERTIFICATE_EXPIRED,
    GNUTLS_A_CERTIFICATE_UNKNOWN,
    GNUTLS_A_ILLEGAL_PARAMETER,
    GNUTLS_A_UNKNOWN_CA,
    GNUTLS_A_ACCESS_DENIED,
    GNUTLS_A_DECODE_ERROR = 50,
    GNUTLS_A_DECRYPT_ERROR,
    GNUTLS_A_EXPORT_RESTRICTION = 60,
    GNUTLS_A_PROTOCOL_VERSION = 70,
    GNUTLS_A_INSUFFICIENT_SECURITY,
    GNUTLS_A_INTERNAL_ERROR = 80,
    GNUTLS_A_USER_CANCELED = 90,
    GNUTLS_A_NO_RENEGOTIATION = 100,
    GNUTLS_A_UNSUPPORTED_EXTENSION = 110,
    GNUTLS_A_CERTIFICATE_UNOBTAINABLE = 111,
    GNUTLS_A_UNRECOGNIZED_NAME = 112,
    GNUTLS_A_UNKNOWN_PSK_IDENTITY = 115,
    GNUTLS_A_NO_APPLICATION_PROTOCOL = 120,
  } gnutls_alert_description_t;

/**
 * gnutls_handshake_description_t:
 * @GNUTLS_HANDSHAKE_HELLO_REQUEST: Hello request.
 * @GNUTLS_HANDSHAKE_HELLO_VERIFY_REQUEST: DTLS Hello verify request.
 * @GNUTLS_HANDSHAKE_CLIENT_HELLO: Client hello.
 * @GNUTLS_HANDSHAKE_SERVER_HELLO: Server hello.
 * @GNUTLS_HANDSHAKE_NEW_SESSION_TICKET: New session ticket.
 * @GNUTLS_HANDSHAKE_CERTIFICATE_PKT: Certificate packet.
 * @GNUTLS_HANDSHAKE_SERVER_KEY_EXCHANGE: Server key exchange.
 * @GNUTLS_HANDSHAKE_CERTIFICATE_REQUEST: Certificate request.
 * @GNUTLS_HANDSHAKE_SERVER_HELLO_DONE: Server hello done.
 * @GNUTLS_HANDSHAKE_CERTIFICATE_VERIFY: Certificate verify.
 * @GNUTLS_HANDSHAKE_CLIENT_KEY_EXCHANGE: Client key exchange.
 * @GNUTLS_HANDSHAKE_FINISHED: Finished.
 * @GNUTLS_HANDSHAKE_CERTIFICATE_STATUS: Certificate status (OCSP).
 * @GNUTLS_HANDSHAKE_SUPPLEMENTAL: Supplemental.
 * @GNUTLS_HANDSHAKE_CHANGE_CIPHER_SPEC: Change Cipher Spec.
 * @GNUTLS_HANDSHAKE_CLIENT_HELLO_V2: SSLv2 Client Hello.
 *
 * Enumeration of different TLS handshake packets.
 */
  typedef enum
  {
    GNUTLS_HANDSHAKE_HELLO_REQUEST = 0,
    GNUTLS_HANDSHAKE_CLIENT_HELLO = 1,
    GNUTLS_HANDSHAKE_SERVER_HELLO = 2,
    GNUTLS_HANDSHAKE_HELLO_VERIFY_REQUEST = 3,
    GNUTLS_HANDSHAKE_NEW_SESSION_TICKET = 4,
    GNUTLS_HANDSHAKE_CERTIFICATE_PKT = 11,
    GNUTLS_HANDSHAKE_SERVER_KEY_EXCHANGE = 12,
    GNUTLS_HANDSHAKE_CERTIFICATE_REQUEST = 13,
    GNUTLS_HANDSHAKE_SERVER_HELLO_DONE = 14,
    GNUTLS_HANDSHAKE_CERTIFICATE_VERIFY = 15,
    GNUTLS_HANDSHAKE_CLIENT_KEY_EXCHANGE = 16,
    GNUTLS_HANDSHAKE_FINISHED = 20,
    GNUTLS_HANDSHAKE_CERTIFICATE_STATUS = 22,
    GNUTLS_HANDSHAKE_SUPPLEMENTAL = 23,
    GNUTLS_HANDSHAKE_CHANGE_CIPHER_SPEC = 254,
    GNUTLS_HANDSHAKE_CLIENT_HELLO_V2 = 1024,
  } gnutls_handshake_description_t;

/**
 * gnutls_certificate_status_t:
 * @GNUTLS_CERT_INVALID: The certificate is not signed by one of the
 *   known authorities or the signature is invalid (deprecated by the flags 
 *   %GNUTLS_CERT_SIGNATURE_FAILURE and %GNUTLS_CERT_SIGNER_NOT_FOUND).
 * @GNUTLS_CERT_SIGNATURE_FAILURE: The signature verification failed.
 * @GNUTLS_CERT_REVOKED: Certificate is revoked by its authority.  In X.509 this will be
 *   set only if CRLs are checked.
 * @GNUTLS_CERT_SIGNER_NOT_FOUND: The certificate's issuer is not known. 
 *   This is the case if the issuer is not included in the trusted certificate list.
 * @GNUTLS_CERT_SIGNER_NOT_CA: The certificate's signer was not a CA. This
 *   may happen if this was a version 1 certificate, which is common with 
 *   some CAs, or a version 3 certificate without the basic constrains extension.
 * @GNUTLS_CERT_SIGNER_CONSTRAINTS_FAILURE: The certificate's signer constraints were
 *   violated.
 * @GNUTLS_CERT_INSECURE_ALGORITHM:  The certificate was signed using an insecure
 *   algorithm such as MD2 or MD5. These algorithms have been broken and
 *   should not be trusted.
 * @GNUTLS_CERT_NOT_ACTIVATED: The certificate is not yet activated.
 * @GNUTLS_CERT_EXPIRED: The certificate has expired.
 * @GNUTLS_CERT_REVOCATION_DATA_SUPERSEDED: The revocation data are old and have been superseded.
 * @GNUTLS_CERT_REVOCATION_DATA_ISSUED_IN_FUTURE: The revocation data have a future issue date.
 * @GNUTLS_CERT_UNEXPECTED_OWNER: The owner is not the expected one.
 * @GNUTLS_CERT_MISMATCH: The certificate presented isn't the expected one (TOFU)
 *
 * Enumeration of certificate status codes.  Note that the status
 * bits may have different meanings in OpenPGP keys and X.509
 * certificate verification.
 */
  typedef enum
  {
    GNUTLS_CERT_INVALID = 1<<1,
    GNUTLS_CERT_REVOKED = 1<<5,
    GNUTLS_CERT_SIGNER_NOT_FOUND = 1<<6,
    GNUTLS_CERT_SIGNER_NOT_CA = 1<<7,
    GNUTLS_CERT_INSECURE_ALGORITHM = 1<<8,
    GNUTLS_CERT_NOT_ACTIVATED = 1<<9,
    GNUTLS_CERT_EXPIRED = 1<<10,
    GNUTLS_CERT_SIGNATURE_FAILURE = 1<<11,
    GNUTLS_CERT_REVOCATION_DATA_SUPERSEDED = 1<<12,
    GNUTLS_CERT_UNEXPECTED_OWNER = 1<<14,
    GNUTLS_CERT_REVOCATION_DATA_ISSUED_IN_FUTURE = 1<<15,
    GNUTLS_CERT_SIGNER_CONSTRAINTS_FAILURE = 1<<16,
    GNUTLS_CERT_MISMATCH = 1<<17,
  } gnutls_certificate_status_t;

/**
 * gnutls_certificate_request_t:
 * @GNUTLS_CERT_IGNORE: Ignore certificate.
 * @GNUTLS_CERT_REQUEST: Request certificate.
 * @GNUTLS_CERT_REQUIRE: Require certificate.
 *
 * Enumeration of certificate request types.
 */
  typedef enum
  {
    GNUTLS_CERT_IGNORE = 0,
    GNUTLS_CERT_REQUEST = 1,
    GNUTLS_CERT_REQUIRE = 2
  } gnutls_certificate_request_t;

/**
 * gnutls_openpgp_crt_status_t:
 * @GNUTLS_OPENPGP_CERT: Send entire certificate.
 * @GNUTLS_OPENPGP_CERT_FINGERPRINT: Send only certificate fingerprint.
 *
 * Enumeration of ways to send OpenPGP certificate.
 */
  typedef enum
  {
    GNUTLS_OPENPGP_CERT = 0,
    GNUTLS_OPENPGP_CERT_FINGERPRINT = 1
  } gnutls_openpgp_crt_status_t;

/**
 * gnutls_close_request_t:
 * @GNUTLS_SHUT_RDWR: Disallow further receives/sends.
 * @GNUTLS_SHUT_WR: Disallow further sends.
 *
 * Enumeration of how TLS session should be terminated.  See gnutls_bye().
 */
  typedef enum
  {
    GNUTLS_SHUT_RDWR = 0,
    GNUTLS_SHUT_WR = 1
  } gnutls_close_request_t;

/**
 * gnutls_protocol_t:
 * @GNUTLS_SSL3: SSL version 3.0.
 * @GNUTLS_TLS1_0: TLS version 1.0.
 * @GNUTLS_TLS1: Same as %GNUTLS_TLS1_0.
 * @GNUTLS_TLS1_1: TLS version 1.1.
 * @GNUTLS_TLS1_2: TLS version 1.2.
 * @GNUTLS_DTLS1_0: DTLS version 1.0.
 * @GNUTLS_DTLS1_2: DTLS version 1.2.
 * @GNUTLS_DTLS0_9: DTLS version 0.9 (Cisco AnyConnect / OpenSSL 0.9.8e).
 * @GNUTLS_VERSION_MAX: Maps to the highest supported TLS version.
 * @GNUTLS_VERSION_UNKNOWN: Unknown SSL/TLS version.
 *
 * Enumeration of different SSL/TLS protocol versions.
 */
  typedef enum
  {
    GNUTLS_SSL3 = 1,
    GNUTLS_TLS1_0 = 2,
    GNUTLS_TLS1 = GNUTLS_TLS1_0,
    GNUTLS_TLS1_1 = 3,
    GNUTLS_TLS1_2 = 4,
    GNUTLS_DTLS0_9 = 6, /* FIXME: at some point change it to 200 */
    GNUTLS_DTLS1_0 = 5, /* 201 */
    GNUTLS_DTLS1_2 = 202,
    GNUTLS_DTLS_VERSION_MIN = GNUTLS_DTLS1_0,
    GNUTLS_DTLS_VERSION_MAX = GNUTLS_DTLS1_2,
    GNUTLS_TLS_VERSION_MAX = GNUTLS_TLS1_2,
    GNUTLS_VERSION_UNKNOWN = 0xff /* change it to 0xffff */
  } gnutls_protocol_t;

/**
 * gnutls_certificate_type_t:
 * @GNUTLS_CRT_UNKNOWN: Unknown certificate type.
 * @GNUTLS_CRT_X509: X.509 Certificate.
 * @GNUTLS_CRT_OPENPGP: OpenPGP certificate.
 * @GNUTLS_CRT_RAW: Raw public key (SubjectPublicKey)
 *
 * Enumeration of different certificate types.
 */
  typedef enum
  {
    GNUTLS_CRT_UNKNOWN = 0,
    GNUTLS_CRT_X509 = 1,
    GNUTLS_CRT_OPENPGP = 2,
    GNUTLS_CRT_RAW = 3
  } gnutls_certificate_type_t;

/**
 * gnutls_x509_crt_fmt_t:
 * @GNUTLS_X509_FMT_DER: X.509 certificate in DER format (binary).
 * @GNUTLS_X509_FMT_PEM: X.509 certificate in PEM format (text).
 *
 * Enumeration of different certificate encoding formats.
 */
  typedef enum
  {
    GNUTLS_X509_FMT_DER = 0,
    GNUTLS_X509_FMT_PEM = 1
  } gnutls_x509_crt_fmt_t;

/**
 * gnutls_certificate_print_formats_t:
 * @GNUTLS_CRT_PRINT_FULL: Full information about certificate.
 * @GNUTLS_CRT_PRINT_FULL_NUMBERS: Full information about certificate and include easy to parse public key parameters.
 * @GNUTLS_CRT_PRINT_COMPACT: Information about certificate name in one line, plus identification of the public key.
 * @GNUTLS_CRT_PRINT_ONELINE: Information about certificate in one line.
 * @GNUTLS_CRT_PRINT_UNSIGNED_FULL: All info for an unsigned certificate.
 *
 * Enumeration of different certificate printing variants.
 */
  typedef enum gnutls_certificate_print_formats
  {
    GNUTLS_CRT_PRINT_FULL = 0,
    GNUTLS_CRT_PRINT_ONELINE = 1,
    GNUTLS_CRT_PRINT_UNSIGNED_FULL = 2,
    GNUTLS_CRT_PRINT_COMPACT = 3,
    GNUTLS_CRT_PRINT_FULL_NUMBERS = 4,
  } gnutls_certificate_print_formats_t;


/**
 * gnutls_pk_algorithm_t:
 * @GNUTLS_PK_UNKNOWN: Unknown public-key algorithm.
 * @GNUTLS_PK_RSA: RSA public-key algorithm.
 * @GNUTLS_PK_DSA: DSA public-key algorithm.
 * @GNUTLS_PK_DH: Diffie-Hellman algorithm. Used to generate parameters.
 * @GNUTLS_PK_EC: Elliptic curve algorithm. Used to generate parameters.
 *
 * Enumeration of different public-key algorithms.
 */
  typedef enum
  {
    GNUTLS_PK_UNKNOWN = 0,
    GNUTLS_PK_RSA = 1,
    GNUTLS_PK_DSA = 2,
    GNUTLS_PK_DH = 3,
    GNUTLS_PK_EC = 4,
  } gnutls_pk_algorithm_t;

  const char *gnutls_pk_algorithm_get_name (gnutls_pk_algorithm_t algorithm);

/**
 * gnutls_sign_algorithm_t:
 * @GNUTLS_SIGN_UNKNOWN: Unknown signature algorithm.
 * @GNUTLS_SIGN_RSA_SHA1: Digital signature algorithm RSA with SHA-1
 * @GNUTLS_SIGN_RSA_SHA: Same as %GNUTLS_SIGN_RSA_SHA1.
 * @GNUTLS_SIGN_DSA_SHA1: Digital signature algorithm DSA with SHA-1
 * @GNUTLS_SIGN_DSA_SHA224: Digital signature algorithm DSA with SHA-224
 * @GNUTLS_SIGN_DSA_SHA256: Digital signature algorithm DSA with SHA-256
 * @GNUTLS_SIGN_DSA_SHA: Same as %GNUTLS_SIGN_DSA_SHA1.
 * @GNUTLS_SIGN_RSA_MD5: Digital signature algorithm RSA with MD5.
 * @GNUTLS_SIGN_RSA_MD2: Digital signature algorithm RSA with MD2.
 * @GNUTLS_SIGN_RSA_RMD160: Digital signature algorithm RSA with RMD-160.
 * @GNUTLS_SIGN_RSA_SHA256: Digital signature algorithm RSA with SHA-256.
 * @GNUTLS_SIGN_RSA_SHA384: Digital signature algorithm RSA with SHA-384.
 * @GNUTLS_SIGN_RSA_SHA512: Digital signature algorithm RSA with SHA-512.
 * @GNUTLS_SIGN_RSA_SHA224: Digital signature algorithm RSA with SHA-224.
 * @GNUTLS_SIGN_ECDSA_SHA1: ECDSA with SHA1.
 * @GNUTLS_SIGN_ECDSA_SHA256: Digital signature algorithm ECDSA with SHA-256.
 * @GNUTLS_SIGN_ECDSA_SHA384: Digital signature algorithm ECDSA with SHA-384.
 * @GNUTLS_SIGN_ECDSA_SHA512: Digital signature algorithm ECDSA with SHA-512.
 * @GNUTLS_SIGN_ECDSA_SHA224: Digital signature algorithm ECDSA with SHA-224.
 *
 * Enumeration of different digital signature algorithms.
 */
  typedef enum
  {
    GNUTLS_SIGN_UNKNOWN = 0,
    GNUTLS_SIGN_RSA_SHA1 = 1,
    GNUTLS_SIGN_RSA_SHA = GNUTLS_SIGN_RSA_SHA1,
    GNUTLS_SIGN_DSA_SHA1 = 2,
    GNUTLS_SIGN_DSA_SHA = GNUTLS_SIGN_DSA_SHA1,
    GNUTLS_SIGN_RSA_MD5 = 3,
    GNUTLS_SIGN_RSA_MD2 = 4,
    GNUTLS_SIGN_RSA_RMD160 = 5,
    GNUTLS_SIGN_RSA_SHA256 = 6,
    GNUTLS_SIGN_RSA_SHA384 = 7,
    GNUTLS_SIGN_RSA_SHA512 = 8,
    GNUTLS_SIGN_RSA_SHA224 = 9,
    GNUTLS_SIGN_DSA_SHA224 = 10,
    GNUTLS_SIGN_DSA_SHA256 = 11,
    GNUTLS_SIGN_ECDSA_SHA1 = 12,
    GNUTLS_SIGN_ECDSA_SHA224 = 13,
    GNUTLS_SIGN_ECDSA_SHA256 = 14,
    GNUTLS_SIGN_ECDSA_SHA384 = 15,
    GNUTLS_SIGN_ECDSA_SHA512 = 16,
  } gnutls_sign_algorithm_t;

/**
 * gnutls_ecc_curve_t:
 * @GNUTLS_ECC_CURVE_INVALID: Cannot be known
 * @GNUTLS_ECC_CURVE_SECP192R1: the SECP192R1 curve
 * @GNUTLS_ECC_CURVE_SECP224R1: the SECP224R1 curve
 * @GNUTLS_ECC_CURVE_SECP256R1: the SECP256R1 curve
 * @GNUTLS_ECC_CURVE_SECP384R1: the SECP384R1 curve
 * @GNUTLS_ECC_CURVE_SECP521R1: the SECP521R1 curve
 *
 * Enumeration of ECC curves.
 */
typedef enum
{
  GNUTLS_ECC_CURVE_INVALID=0,
  GNUTLS_ECC_CURVE_SECP224R1,
  GNUTLS_ECC_CURVE_SECP256R1,
  GNUTLS_ECC_CURVE_SECP384R1,
  GNUTLS_ECC_CURVE_SECP521R1,
  GNUTLS_ECC_CURVE_SECP192R1,
} gnutls_ecc_curve_t;

/**
 * gnutls_sec_param_t:
 * @GNUTLS_SEC_PARAM_UNKNOWN: Cannot be known
 * @GNUTLS_SEC_PARAM_INSECURE: Less than 42 bits of security
 * @GNUTLS_SEC_PARAM_EXPORT: 42 bits of security
 * @GNUTLS_SEC_PARAM_VERY_WEAK: 64 bits of security
 * @GNUTLS_SEC_PARAM_WEAK: 72 bits of security
 * @GNUTLS_SEC_PARAM_LOW: 80 bits of security
 * @GNUTLS_SEC_PARAM_LEGACY: 96 bits of security
 * @GNUTLS_SEC_PARAM_NORMAL: 112 bits of security
 * @GNUTLS_SEC_PARAM_HIGH: 128 bits of security
 * @GNUTLS_SEC_PARAM_ULTRA: 192 bits of security
 *
 * Enumeration of security parameters for passive attacks.
 */
  typedef enum
  {
    GNUTLS_SEC_PARAM_INSECURE = -20,
    GNUTLS_SEC_PARAM_EXPORT = -15,
    GNUTLS_SEC_PARAM_VERY_WEAK = -12,
    GNUTLS_SEC_PARAM_WEAK = -10,
    GNUTLS_SEC_PARAM_UNKNOWN = 0,
    GNUTLS_SEC_PARAM_LOW = 1,
    GNUTLS_SEC_PARAM_LEGACY = 2,
    GNUTLS_SEC_PARAM_NORMAL = 3,
    GNUTLS_SEC_PARAM_HIGH = 4,
    GNUTLS_SEC_PARAM_ULTRA = 5,
  } gnutls_sec_param_t;

/**
 * gnutls_channel_binding_t:
 * @GNUTLS_CB_TLS_UNIQUE: "tls-unique" (RFC 5929) channel binding
 *
 * Enumeration of support channel binding types.
 */
  typedef enum
  {
    GNUTLS_CB_TLS_UNIQUE
  } gnutls_channel_binding_t;


/* If you want to change this, then also change the define in
 * gnutls_int.h, and recompile.
 */
  typedef void *gnutls_transport_ptr_t;

  struct gnutls_session_int;
  typedef struct gnutls_session_int *gnutls_session_t;

  struct gnutls_dh_params_int;
  typedef struct gnutls_dh_params_int *gnutls_dh_params_t;

  struct gnutls_ecdh_params_int;
  typedef struct gnutls_ecdh_params_int *gnutls_ecdh_params_t;

  /* XXX ugly. */
  struct gnutls_x509_privkey_int;
  typedef struct gnutls_x509_privkey_int *gnutls_rsa_params_t;

  struct gnutls_priority_st;
  typedef struct gnutls_priority_st *gnutls_priority_t;

  typedef struct
  {
    unsigned char *data;
    unsigned int size;
  } gnutls_datum_t;


  typedef struct gnutls_params_st
  {
    gnutls_params_type_t type;
    union params
    {
      gnutls_dh_params_t dh;
      gnutls_ecdh_params_t ecdh;
      gnutls_rsa_params_t rsa_export;
    } params;
    int deinit;
  } gnutls_params_st;

  typedef int gnutls_params_function (gnutls_session_t, gnutls_params_type_t,
                                      gnutls_params_st *);

/* internal functions */

  int gnutls_init (gnutls_session_t * session,
                   unsigned int flags);
  void gnutls_deinit (gnutls_session_t session);


  int gnutls_bye (gnutls_session_t session, gnutls_close_request_t how);

  int gnutls_handshake (gnutls_session_t session);


  void gnutls_handshake_set_timeout (gnutls_session_t session,
         unsigned int ms);
  int gnutls_rehandshake (gnutls_session_t session);

  gnutls_alert_description_t gnutls_alert_get (gnutls_session_t session);
  int gnutls_alert_send (gnutls_session_t session,
                         gnutls_alert_level_t level,
                         gnutls_alert_description_t desc);
  int gnutls_alert_send_appropriate (gnutls_session_t session, int err);
  const char *gnutls_alert_get_name (gnutls_alert_description_t alert);
  const char * gnutls_alert_get_strname (gnutls_alert_description_t alert);

  gnutls_sec_param_t gnutls_pk_bits_to_sec_param (gnutls_pk_algorithm_t algo,
                                                  unsigned int bits);
  const char *gnutls_sec_param_get_name (gnutls_sec_param_t param);
  unsigned int gnutls_sec_param_to_pk_bits (gnutls_pk_algorithm_t algo,
                                            gnutls_sec_param_t param);

/* Elliptic curves */
const char * gnutls_ecc_curve_get_name (gnutls_ecc_curve_t curve);
int gnutls_ecc_curve_get_size (gnutls_ecc_curve_t curve);
gnutls_ecc_curve_t gnutls_ecc_curve_get(gnutls_session_t session);

/* get information on the current session */
  gnutls_cipher_algorithm_t gnutls_cipher_get (gnutls_session_t session);
  gnutls_kx_algorithm_t gnutls_kx_get (gnutls_session_t session);
  gnutls_mac_algorithm_t gnutls_mac_get (gnutls_session_t session);
  gnutls_compression_method_t
    gnutls_compression_get (gnutls_session_t session);
  gnutls_certificate_type_t
    gnutls_certificate_type_get (gnutls_session_t session);

  int gnutls_sign_algorithm_get (gnutls_session_t session);
  int gnutls_sign_algorithm_get_client (gnutls_session_t session);

  int gnutls_sign_algorithm_get_requested (gnutls_session_t session,
                                           size_t indx,
                                           gnutls_sign_algorithm_t * algo);

/* the name of the specified algorithms */
  const char *gnutls_cipher_get_name (gnutls_cipher_algorithm_t algorithm);
  const char *gnutls_mac_get_name (gnutls_mac_algorithm_t algorithm);
  const char *gnutls_compression_get_name (gnutls_compression_method_t
                                           algorithm);
  const char *gnutls_kx_get_name (gnutls_kx_algorithm_t algorithm);
  const char *gnutls_certificate_type_get_name (gnutls_certificate_type_t
                                                type);
  const char *gnutls_pk_get_name (gnutls_pk_algorithm_t algorithm);
  const char *gnutls_sign_get_name (gnutls_sign_algorithm_t algorithm);

  size_t gnutls_cipher_get_key_size (gnutls_cipher_algorithm_t algorithm);
  size_t gnutls_mac_get_key_size (gnutls_mac_algorithm_t algorithm);

  int gnutls_sign_is_secure (gnutls_sign_algorithm_t algorithm);
  gnutls_digest_algorithm_t
  gnutls_sign_get_hash_algorithm (gnutls_sign_algorithm_t sign);
  gnutls_pk_algorithm_t
  gnutls_sign_get_pk_algorithm (gnutls_sign_algorithm_t sign);
  gnutls_sign_algorithm_t
  gnutls_pk_to_sign (gnutls_pk_algorithm_t pk,
       gnutls_digest_algorithm_t hash);



  gnutls_mac_algorithm_t gnutls_mac_get_id (const char *name);
  gnutls_compression_method_t gnutls_compression_get_id (const char *name);
  gnutls_cipher_algorithm_t gnutls_cipher_get_id (const char *name);
  gnutls_kx_algorithm_t gnutls_kx_get_id (const char *name);
  gnutls_protocol_t gnutls_protocol_get_id (const char *name);
  gnutls_certificate_type_t gnutls_certificate_type_get_id (const char *name);
  gnutls_pk_algorithm_t gnutls_pk_get_id (const char *name);
  gnutls_sign_algorithm_t gnutls_sign_get_id (const char *name);

  /* list supported algorithms */
  const gnutls_ecc_curve_t * gnutls_ecc_curve_list (void);
  const gnutls_cipher_algorithm_t *gnutls_cipher_list (void);
  const gnutls_mac_algorithm_t *gnutls_mac_list (void);
  const gnutls_compression_method_t *gnutls_compression_list (void);
  const gnutls_protocol_t *gnutls_protocol_list (void);
  const gnutls_certificate_type_t *gnutls_certificate_type_list (void);
  const gnutls_kx_algorithm_t *gnutls_kx_list (void);
  const gnutls_pk_algorithm_t *gnutls_pk_list (void);
  const gnutls_sign_algorithm_t *gnutls_sign_list (void);
  const char *gnutls_cipher_suite_info (size_t idx,
                                        unsigned char *cs_id,
                                        gnutls_kx_algorithm_t * kx,
                                        gnutls_cipher_algorithm_t * cipher,
                                        gnutls_mac_algorithm_t * mac,
                                        gnutls_protocol_t * min_version);

  /* error functions */
  int gnutls_error_is_fatal (int error);
  int gnutls_error_to_alert (int err, int *level);

  void gnutls_perror (int error);
  const char *gnutls_strerror (int error);
  const char *gnutls_strerror_name (int error);

/* Semi-internal functions.
 */
  void gnutls_handshake_set_private_extensions (gnutls_session_t session,
                                                int allow);
  int gnutls_handshake_set_random (gnutls_session_t session, const gnutls_datum_t* random);

    gnutls_handshake_description_t
    gnutls_handshake_get_last_out (gnutls_session_t session);
    gnutls_handshake_description_t
    gnutls_handshake_get_last_in (gnutls_session_t session);

/* Record layer functions.
 */

  int gnutls_heartbeat_ping (gnutls_session_t session, size_t data_size,
                       unsigned int max_tries, unsigned int flags);
  int gnutls_heartbeat_pong (gnutls_session_t session, unsigned int flags);

  void gnutls_record_set_timeout (gnutls_session_t session, unsigned int ms);
  void gnutls_record_disable_padding (gnutls_session_t session);

  void gnutls_record_cork (gnutls_session_t session);

  int gnutls_record_uncork (gnutls_session_t session, unsigned int flags);

  typedef struct {
    size_t low;
    size_t high;
  } gnutls_range_st;

  int gnutls_range_split (gnutls_session_t session,
                              const gnutls_range_st *orig,
                              gnutls_range_st * small_range,
                              gnutls_range_st * rem_range);

  ssize_t gnutls_record_send (gnutls_session_t session, const void *data,
                              size_t data_size);
  ssize_t gnutls_record_send_range (gnutls_session_t session, const void *data,
                                    size_t data_size, const gnutls_range_st *range);
  ssize_t gnutls_record_recv (gnutls_session_t session, void *data,
                              size_t data_size);


  ssize_t gnutls_record_recv_seq (gnutls_session_t session, void *data, size_t data_size,
    unsigned char *seq);

  void gnutls_session_enable_compatibility_mode (gnutls_session_t session);
  void gnutls_record_set_max_empty_records (gnutls_session_t session, const unsigned int i);

  int gnutls_record_can_use_length_hiding (gnutls_session_t session);

  int gnutls_record_get_direction (gnutls_session_t session);

  size_t gnutls_record_get_max_size (gnutls_session_t session);
  ssize_t gnutls_record_set_max_size (gnutls_session_t session, size_t size);

  size_t gnutls_record_check_pending (gnutls_session_t session);

  void gnutls_session_force_valid (gnutls_session_t session);

  int gnutls_prf (gnutls_session_t session,
                  size_t label_size, const char *label,
                  int server_random_first,
                  size_t extra_size, const char *extra,
                  size_t outsize, char *out);

  int gnutls_prf_raw (gnutls_session_t session,
                      size_t label_size, const char *label,
                      size_t seed_size, const char *seed,
                      size_t outsize, char *out);

/**
 * gnutls_server_name_type_t:
 * @GNUTLS_NAME_DNS: Domain Name System name type.
 *
 * Enumeration of different server name types.
 */
  typedef enum
  {
    GNUTLS_NAME_DNS = 1
  } gnutls_server_name_type_t;

  int gnutls_server_name_set (gnutls_session_t session,
                              gnutls_server_name_type_t type,
                              const void *name, size_t name_length);

  int gnutls_server_name_get (gnutls_session_t session,
                              void *data, size_t * data_length,
                              unsigned int *type, unsigned int indx);

  unsigned int gnutls_heartbeat_get_timeout (gnutls_session_t session);
  void gnutls_heartbeat_set_timeouts (gnutls_session_t session, unsigned int retrans_timeout,
                                      unsigned int total_timeout);




  /* Heartbeat */
  void gnutls_heartbeat_enable (gnutls_session_t session, unsigned int type);


  int gnutls_heartbeat_allowed (gnutls_session_t session, unsigned int type);

  /* Safe renegotiation */
  int gnutls_safe_renegotiation_status (gnutls_session_t session);

/**
 * gnutls_supplemental_data_format_type_t:
 * @GNUTLS_SUPPLEMENTAL_USER_MAPPING_DATA: Supplemental user mapping data.
 *
 * Enumeration of different supplemental data types (RFC 4680).
 */
  typedef enum
  {
    GNUTLS_SUPPLEMENTAL_USER_MAPPING_DATA = 0
  } gnutls_supplemental_data_format_type_t;

  const char
    *gnutls_supplemental_get_name (gnutls_supplemental_data_format_type_t
                                   type);

  /* SessionTicket, RFC 5077. */
  int gnutls_session_ticket_key_generate (gnutls_datum_t * key);
  int gnutls_session_ticket_enable_client (gnutls_session_t session);
  int gnutls_session_ticket_enable_server (gnutls_session_t session,
                                           const gnutls_datum_t * key);

  /* SRTP, RFC 5764 */

/**
 * gnutls_srtp_profile_t:
 * @GNUTLS_SRTP_AES128_CM_HMAC_SHA1_80: 128 bit AES with a 80 bit HMAC-SHA1
 * @GNUTLS_SRTP_AES128_CM_HMAC_SHA1_32: 128 bit AES with a 32 bit HMAC-SHA1
 * @GNUTLS_SRTP_NULL_HMAC_SHA1_80: NULL cipher with a 80 bit HMAC-SHA1
 * @GNUTLS_SRTP_NULL_HMAC_SHA1_32: NULL cipher with a 32 bit HMAC-SHA1
 *
 * Enumeration of different SRTP protection profiles.
 */
  typedef enum
  {
    GNUTLS_SRTP_AES128_CM_HMAC_SHA1_80 = 0x0001,
    GNUTLS_SRTP_AES128_CM_HMAC_SHA1_32 = 0x0002,
    GNUTLS_SRTP_NULL_HMAC_SHA1_80 = 0x0005,
    GNUTLS_SRTP_NULL_HMAC_SHA1_32 = 0x0006
  } gnutls_srtp_profile_t;

  int gnutls_srtp_set_profile (gnutls_session_t session,
                               gnutls_srtp_profile_t profile);
  int gnutls_srtp_set_profile_direct (gnutls_session_t session,
                                      const char *profiles, const char **err_pos);
  int gnutls_srtp_get_selected_profile (gnutls_session_t session,
                                        gnutls_srtp_profile_t *profile);

  const char *gnutls_srtp_get_profile_name (gnutls_srtp_profile_t profile);
  int gnutls_srtp_get_profile_id (const char *name,
                                  gnutls_srtp_profile_t *profile);
  int gnutls_srtp_get_keys (gnutls_session_t session,
                      void *key_material,
                      unsigned int key_material_size,
                      gnutls_datum_t *client_key,
                      gnutls_datum_t *client_salt,
                      gnutls_datum_t *server_key,
                      gnutls_datum_t *server_salt);

  int gnutls_srtp_set_mki (gnutls_session_t session, const gnutls_datum_t *mki);
  int gnutls_srtp_get_mki (gnutls_session_t session, gnutls_datum_t *mki);

/* ALPN TLS extension */

  int gnutls_alpn_get_selected_protocol (gnutls_session_t session,
                                   gnutls_datum_t * protocol);
  int gnutls_alpn_set_protocols (gnutls_session_t session,
                           const gnutls_datum_t * protocols, unsigned protocols_size,
                           unsigned flags);

  int gnutls_key_generate (gnutls_datum_t * key, unsigned int key_size);

/* if you just want some defaults, use the following.
 */
  int gnutls_priority_init (gnutls_priority_t * priority_cache,
                            const char *priorities, const char **err_pos);
  void gnutls_priority_deinit (gnutls_priority_t priority_cache);
  int gnutls_priority_get_cipher_suite_index (gnutls_priority_t pcache, unsigned int idx, unsigned int *sidx);

  int gnutls_priority_set (gnutls_session_t session,
                           gnutls_priority_t priority);
  int gnutls_priority_set_direct (gnutls_session_t session,
                                  const char *priorities,
                                  const char **err_pos);

  int gnutls_priority_certificate_type_list (gnutls_priority_t pcache, const unsigned int** list);
  int gnutls_priority_sign_list (gnutls_priority_t pcache, const unsigned int** list);
  int gnutls_priority_protocol_list (gnutls_priority_t pcache, const unsigned int** list);
  int gnutls_priority_compression_list (gnutls_priority_t pcache, const unsigned int** list);
  int gnutls_priority_ecc_curve_list (gnutls_priority_t pcache, const unsigned int** list);

  /* for compatibility
   */
  int gnutls_set_default_priority (gnutls_session_t session);

/* Returns the name of a cipher suite */
  const char *gnutls_cipher_suite_get_name (gnutls_kx_algorithm_t
                                            kx_algorithm,
                                            gnutls_cipher_algorithm_t
                                            cipher_algorithm,
                                            gnutls_mac_algorithm_t
                                            mac_algorithm);

/* get the currently used protocol version */
  gnutls_protocol_t gnutls_protocol_get_version (gnutls_session_t session);

  const char *gnutls_protocol_get_name (gnutls_protocol_t version);


/* get/set session 
 */
  int gnutls_session_set_data (gnutls_session_t session,
                               const void *session_data,
                               size_t session_data_size);
  int gnutls_session_get_data (gnutls_session_t session, void *session_data,
                               size_t * session_data_size);
  int gnutls_session_get_data2 (gnutls_session_t session,
                                gnutls_datum_t * data);
  void gnutls_session_get_random (gnutls_session_t session, gnutls_datum_t* client,
                                  gnutls_datum_t* server);
  char * gnutls_session_get_desc (gnutls_session_t session);

  int gnutls_session_set_premaster (gnutls_session_t session, unsigned int entity,
                           gnutls_protocol_t version,
                           gnutls_kx_algorithm_t kx,
                           gnutls_cipher_algorithm_t cipher,
                           gnutls_mac_algorithm_t mac,
                           gnutls_compression_method_t comp,
                           const gnutls_datum_t* master,
                           const gnutls_datum_t * session_id);

/* returns the session ID */

  int gnutls_session_get_id (gnutls_session_t session, void *session_id,
                             size_t * session_id_size);
  int gnutls_session_get_id2 (gnutls_session_t session, gnutls_datum_t *session_id);

  int gnutls_session_set_id (gnutls_session_t session,
                              const gnutls_datum_t * sid);

  int gnutls_session_channel_binding (gnutls_session_t session,
                                      gnutls_channel_binding_t cbtype,
                                      gnutls_datum_t * cb);

/* checks if this session is a resumed one 
 */
  int gnutls_session_is_resumed (gnutls_session_t session);
  int gnutls_session_resumption_requested (gnutls_session_t session);

  typedef int (*gnutls_db_store_func) (void *, gnutls_datum_t key,
                                       gnutls_datum_t data);
  typedef int (*gnutls_db_remove_func) (void *, gnutls_datum_t key);
  typedef gnutls_datum_t (*gnutls_db_retr_func) (void *, gnutls_datum_t key);

  void gnutls_db_set_cache_expiration (gnutls_session_t session, int seconds);

  void gnutls_db_remove_session (gnutls_session_t session);
  void gnutls_db_set_retrieve_function (gnutls_session_t session,
                                        gnutls_db_retr_func retr_func);
  void gnutls_db_set_remove_function (gnutls_session_t session,
                                      gnutls_db_remove_func rem_func);
  void gnutls_db_set_store_function (gnutls_session_t session,
                                     gnutls_db_store_func store_func);
  void gnutls_db_set_ptr (gnutls_session_t session, void *ptr);
  void *gnutls_db_get_ptr (gnutls_session_t session);
  int gnutls_db_check_entry (gnutls_session_t session,
                             gnutls_datum_t session_entry);
  time_t gnutls_db_check_entry_time (gnutls_datum_t *entry);

  typedef int (*gnutls_handshake_post_client_hello_func) (gnutls_session_t);
  void
    gnutls_handshake_set_post_client_hello_function (gnutls_session_t session,
                                                     gnutls_handshake_post_client_hello_func
                                                     func);

  void gnutls_handshake_set_max_packet_length (gnutls_session_t session,
                                               size_t max);

/* returns libgnutls version (call it with a NULL argument)
 */
  const char *gnutls_check_version (const char *req_version);

/* Functions for setting/clearing credentials
 */
  void gnutls_credentials_clear (gnutls_session_t session);

/* cred is a structure defined by the kx algorithm
 */
  int gnutls_credentials_set (gnutls_session_t session,
                              gnutls_credentials_type_t type, void *cred);


/* x.509 types */

  struct gnutls_pubkey_st;
  typedef struct gnutls_pubkey_st *gnutls_pubkey_t;

  struct gnutls_privkey_st;
  typedef struct gnutls_privkey_st *gnutls_privkey_t;

  struct gnutls_x509_privkey_int;
  typedef struct gnutls_x509_privkey_int *gnutls_x509_privkey_t;

  struct gnutls_x509_crl_int;
  typedef struct gnutls_x509_crl_int *gnutls_x509_crl_t;

  struct gnutls_x509_crt_int;
  typedef struct gnutls_x509_crt_int *gnutls_x509_crt_t;

  struct gnutls_x509_crq_int;
  typedef struct gnutls_x509_crq_int *gnutls_x509_crq_t;

  struct gnutls_openpgp_keyring_int;
  typedef struct gnutls_openpgp_keyring_int *gnutls_openpgp_keyring_t;


/* Credential structures - used in gnutls_credentials_set(); */

  struct gnutls_certificate_credentials_st;
  typedef struct gnutls_certificate_credentials_st
    *gnutls_certificate_credentials_t;
  typedef gnutls_certificate_credentials_t
    gnutls_certificate_server_credentials;
  typedef gnutls_certificate_credentials_t
    gnutls_certificate_client_credentials;

  typedef struct gnutls_anon_server_credentials_st
    *gnutls_anon_server_credentials_t;
  typedef struct gnutls_anon_client_credentials_st
    *gnutls_anon_client_credentials_t;

  void gnutls_anon_free_server_credentials (gnutls_anon_server_credentials_t
                                            sc);
  int
    gnutls_anon_allocate_server_credentials (gnutls_anon_server_credentials_t
                                             * sc);

  void gnutls_anon_set_server_dh_params (gnutls_anon_server_credentials_t res,
                                         gnutls_dh_params_t dh_params);

  void
    gnutls_anon_set_server_params_function (gnutls_anon_server_credentials_t
                                            res,
                                            gnutls_params_function * func);

  void
    gnutls_anon_free_client_credentials (gnutls_anon_client_credentials_t sc);
  int
    gnutls_anon_allocate_client_credentials (gnutls_anon_client_credentials_t
                                             * sc);

/* CERTFILE is an x509 certificate in PEM form.
 * KEYFILE is a pkcs-1 private key in PEM form (for RSA keys).
 */
  void
    gnutls_certificate_free_credentials (gnutls_certificate_credentials_t sc);
  int
    gnutls_certificate_allocate_credentials (gnutls_certificate_credentials_t
                                             * res);

  int
    gnutls_certificate_get_issuer (gnutls_certificate_credentials_t sc,
    gnutls_x509_crt_t cert, gnutls_x509_crt_t* issuer, unsigned int flags);

  void gnutls_certificate_free_keys (gnutls_certificate_credentials_t sc);
  void gnutls_certificate_free_cas (gnutls_certificate_credentials_t sc);
  void gnutls_certificate_free_ca_names (gnutls_certificate_credentials_t sc);
  void gnutls_certificate_free_crls (gnutls_certificate_credentials_t sc);

  void gnutls_certificate_set_dh_params (gnutls_certificate_credentials_t res,
                                         gnutls_dh_params_t dh_params);
  void gnutls_certificate_set_verify_flags (gnutls_certificate_credentials_t
                                            res, unsigned int flags);
  void gnutls_certificate_set_verify_limits (gnutls_certificate_credentials_t
                                             res, unsigned int max_bits,
                                             unsigned int max_depth);

  int
    gnutls_certificate_set_x509_system_trust (gnutls_certificate_credentials_t cred);

  int
    gnutls_certificate_set_x509_trust_file (gnutls_certificate_credentials_t
                                            cred, const char *cafile,
                                            gnutls_x509_crt_fmt_t type);
  int gnutls_certificate_set_x509_trust_mem (gnutls_certificate_credentials_t
                                             res, const gnutls_datum_t * ca,
                                             gnutls_x509_crt_fmt_t type);

  int
    gnutls_certificate_set_x509_crl_file (gnutls_certificate_credentials_t
                                          res, const char *crlfile,
                                          gnutls_x509_crt_fmt_t type);
  int gnutls_certificate_set_x509_crl_mem (gnutls_certificate_credentials_t
                                           res, const gnutls_datum_t * CRL,
                                           gnutls_x509_crt_fmt_t type);

  int
    gnutls_certificate_set_x509_key_file (gnutls_certificate_credentials_t
                                          res, const char *certfile,
                                          const char *keyfile,
                                          gnutls_x509_crt_fmt_t type);

  int
    gnutls_certificate_set_x509_key_file2 (gnutls_certificate_credentials_t
                                          res, const char *certfile,
                                          const char *keyfile,
                                          gnutls_x509_crt_fmt_t type,
                                          const char* pass,
                                          unsigned int flags);

  int gnutls_certificate_set_x509_key_mem (gnutls_certificate_credentials_t
                                           res, const gnutls_datum_t * cert,
                                           const gnutls_datum_t * key,
                                           gnutls_x509_crt_fmt_t type);

  int gnutls_certificate_set_x509_key_mem2 (gnutls_certificate_credentials_t
                                           res, const gnutls_datum_t * cert,
                                           const gnutls_datum_t * key,
                                           gnutls_x509_crt_fmt_t type,
                                           const char* pass,
                                           unsigned int flags);

  void gnutls_certificate_send_x509_rdn_sequence (gnutls_session_t session,
                                                  int status);

  int gnutls_certificate_set_x509_simple_pkcs12_file (gnutls_certificate_credentials_t res, const char *pkcs12file,
     gnutls_x509_crt_fmt_t type, const char *password);
  int gnutls_certificate_set_x509_simple_pkcs12_mem (gnutls_certificate_credentials_t res, const gnutls_datum_t * p12blob,
     gnutls_x509_crt_fmt_t type, const char *password);

/* New functions to allow setting already parsed X.509 stuff.
 */

  int gnutls_certificate_set_x509_key (gnutls_certificate_credentials_t res,
                                       gnutls_x509_crt_t * cert_list,
                                       int cert_list_size,
                                       gnutls_x509_privkey_t key);
  int gnutls_certificate_set_x509_trust (gnutls_certificate_credentials_t res,
                                         gnutls_x509_crt_t * ca_list,
                                         int ca_list_size);
  int gnutls_certificate_set_x509_crl (gnutls_certificate_credentials_t res,
                                       gnutls_x509_crl_t * crl_list,
                                       int crl_list_size);

  /* OCSP status request extension, RFC 6066 */
  typedef int (*gnutls_status_request_ocsp_func)
  (gnutls_session_t session, void *ptr, gnutls_datum_t *ocsp_response);

  void gnutls_certificate_set_ocsp_status_request_function (gnutls_certificate_credentials_t res,
                                                           gnutls_status_request_ocsp_func ocsp_func,
                                                           void *ptr);

  int gnutls_certificate_set_ocsp_status_request_file (gnutls_certificate_credentials_t res,
                                                       const char* response_file, unsigned int flags);

  int gnutls_ocsp_status_request_enable_client (gnutls_session_t session,
             gnutls_datum_t *responder_id,
                                                size_t responder_id_size,
             gnutls_datum_t *request_extensions);

  int gnutls_ocsp_status_request_get (gnutls_session_t session, gnutls_datum_t *response);

  int gnutls_ocsp_status_request_is_checked (gnutls_session_t session, unsigned int flags);

/* global state functions
 */
  int gnutls_global_init (void);
  void gnutls_global_deinit (void);

  /**
   * gnutls_time_func:
   * @t: where to store time.
   *
   * Function prototype for time()-like function.  Set with
   * gnutls_global_set_time_function().
   *
   * Returns: Number of seconds since the epoch, or (time_t)-1 on errors.
   */
  typedef time_t (*gnutls_time_func) (time_t *t);

  typedef int (*mutex_init_func) (void **mutex);
  typedef int (*mutex_lock_func) (void **mutex);
  typedef int (*mutex_unlock_func) (void **mutex);
  typedef int (*mutex_deinit_func) (void **mutex);

  void gnutls_global_set_mutex (mutex_init_func init, mutex_deinit_func deinit,
                                mutex_lock_func lock, mutex_unlock_func unlock);

  typedef void *(*gnutls_alloc_function) (size_t);
  typedef void *(*gnutls_calloc_function) (size_t, size_t);
  typedef int (*gnutls_is_secure_function) (const void *);
  typedef void (*gnutls_free_function) (void *);
  typedef void *(*gnutls_realloc_function) (void *, size_t);

  void
    gnutls_global_set_mem_functions (gnutls_alloc_function alloc_func,
                                     gnutls_alloc_function secure_alloc_func,
                                     gnutls_is_secure_function is_secure_func,
                                     gnutls_realloc_function realloc_func,
                                     gnutls_free_function free_func);

  void gnutls_global_set_time_function (gnutls_time_func time_func);

/* For use in callbacks */
  extern gnutls_alloc_function gnutls_malloc;
  extern gnutls_alloc_function gnutls_secure_malloc;
  extern gnutls_realloc_function gnutls_realloc;
  extern gnutls_calloc_function gnutls_calloc;
  extern gnutls_free_function gnutls_free;

  extern char *(*gnutls_strdup) (const char *);

  typedef void (*gnutls_log_func) (int, const char *);
  typedef void (*gnutls_audit_log_func) (gnutls_session_t, const char *);
  void gnutls_global_set_log_function (gnutls_log_func log_func);
  void gnutls_global_set_audit_log_function (gnutls_audit_log_func log_func);
  void gnutls_global_set_log_level (int level);

/* Diffie-Hellman parameter handling.
 */
  int gnutls_dh_params_init (gnutls_dh_params_t * dh_params);
  void gnutls_dh_params_deinit (gnutls_dh_params_t dh_params);
  int gnutls_dh_params_import_raw (gnutls_dh_params_t dh_params,
                                   const gnutls_datum_t * prime,
                                   const gnutls_datum_t * generator);
  int gnutls_dh_params_import_pkcs3 (gnutls_dh_params_t params,
                                     const gnutls_datum_t * pkcs3_params,
                                     gnutls_x509_crt_fmt_t format);
  int gnutls_dh_params_generate2 (gnutls_dh_params_t params,
                                  unsigned int bits);
  int gnutls_dh_params_export_pkcs3 (gnutls_dh_params_t params,
                                     gnutls_x509_crt_fmt_t format,
                                     unsigned char *params_data,
                                     size_t * params_data_size);
  int gnutls_dh_params_export2_pkcs3 (gnutls_dh_params_t params,
                                      gnutls_x509_crt_fmt_t format,
                                      gnutls_datum_t *out);
  int gnutls_dh_params_export_raw (gnutls_dh_params_t params,
                                   gnutls_datum_t * prime,
                                   gnutls_datum_t * generator,
                                   unsigned int *bits);
  int gnutls_dh_params_cpy (gnutls_dh_params_t dst, gnutls_dh_params_t src);



/* Session stuff
 */
  typedef struct
  {
    void *iov_base; /* Starting address */
    size_t iov_len; /* Number of bytes to transfer */
  } giovec_t;

  typedef ssize_t (*gnutls_pull_func) (gnutls_transport_ptr_t, void *,
                                       size_t);
  typedef ssize_t (*gnutls_push_func) (gnutls_transport_ptr_t, const void *,
                                       size_t);

  typedef int (*gnutls_pull_timeout_func) (gnutls_transport_ptr_t, unsigned int ms);

  typedef ssize_t (*gnutls_vec_push_func) (gnutls_transport_ptr_t,
                                           const giovec_t * iov, int iovcnt);

  typedef int (*gnutls_errno_func) (gnutls_transport_ptr_t);

/* This will be defined as macro.
  void gnutls_transport_set_int (gnutls_session_t session, int r);
 */
  void gnutls_transport_set_int2 (gnutls_session_t session, int r, int s);


  void gnutls_transport_get_int2 (gnutls_session_t session, int * r, int *s);
  int gnutls_transport_get_int (gnutls_session_t session);

  void gnutls_transport_set_ptr (gnutls_session_t session,
                                 gnutls_transport_ptr_t ptr);
  void gnutls_transport_set_ptr2 (gnutls_session_t session,
                                  gnutls_transport_ptr_t recv_ptr,
                                  gnutls_transport_ptr_t send_ptr);

  gnutls_transport_ptr_t gnutls_transport_get_ptr (gnutls_session_t session);
  void gnutls_transport_get_ptr2 (gnutls_session_t session,
                                  gnutls_transport_ptr_t * recv_ptr,
                                  gnutls_transport_ptr_t * send_ptr);

  void gnutls_transport_set_vec_push_function (gnutls_session_t session,
                                            gnutls_vec_push_func vec_func);
  void gnutls_transport_set_push_function (gnutls_session_t session,
                                           gnutls_push_func push_func);
  void gnutls_transport_set_pull_function (gnutls_session_t session,
                                           gnutls_pull_func pull_func);

  void gnutls_transport_set_pull_timeout_function (gnutls_session_t session,
                                            gnutls_pull_timeout_func func);

  void gnutls_transport_set_errno_function (gnutls_session_t session,
                                            gnutls_errno_func errno_func);

  void gnutls_transport_set_errno (gnutls_session_t session, int err);

/* session specific 
 */
  void gnutls_session_set_ptr (gnutls_session_t session, void *ptr);
  void *gnutls_session_get_ptr (gnutls_session_t session);

  void gnutls_openpgp_send_cert (gnutls_session_t session,
                                 gnutls_openpgp_crt_status_t status);

/* This function returns the hash of the given data.
 */
  int gnutls_fingerprint (gnutls_digest_algorithm_t algo,
                          const gnutls_datum_t * data, void *result,
                          size_t * result_size);

  /**
   * gnutls_random_art_t:
   * @GNUTLS_RANDOM_ART_OPENSSH: OpenSSH-style random art.
   *
   * Enumeration of different random art types.
   */
  typedef enum gnutls_random_art
  {
    GNUTLS_RANDOM_ART_OPENSSH=1,
  } gnutls_random_art_t;

  int gnutls_random_art (gnutls_random_art_t type,
                         const char* key_type, unsigned int key_size,
                         void * fpr, size_t fpr_size,
                         gnutls_datum_t* art);

/* SRP 
 */

  typedef struct gnutls_srp_server_credentials_st
    *gnutls_srp_server_credentials_t;
  typedef struct gnutls_srp_client_credentials_st
    *gnutls_srp_client_credentials_t;

  void
    gnutls_srp_free_client_credentials (gnutls_srp_client_credentials_t sc);
  int
    gnutls_srp_allocate_client_credentials (gnutls_srp_client_credentials_t *
                                            sc);
  int gnutls_srp_set_client_credentials (gnutls_srp_client_credentials_t res,
                                         const char *username,
                                         const char *password);

  void
    gnutls_srp_free_server_credentials (gnutls_srp_server_credentials_t sc);
  int
    gnutls_srp_allocate_server_credentials (gnutls_srp_server_credentials_t *
                                            sc);
  int gnutls_srp_set_server_credentials_file (gnutls_srp_server_credentials_t
                                              res, const char *password_file,
                                              const char *password_conf_file);

  const char *gnutls_srp_server_get_username (gnutls_session_t session);

  extern void gnutls_srp_set_prime_bits (gnutls_session_t session,
                                         unsigned int bits);

  int gnutls_srp_verifier (const char *username,
                           const char *password,
                           const gnutls_datum_t * salt,
                           const gnutls_datum_t * generator,
                           const gnutls_datum_t * prime,
                           gnutls_datum_t * res);

/* The static parameters defined in draft-ietf-tls-srp-05
 * Those should be used as input to gnutls_srp_verifier().
 */
  extern const gnutls_datum_t gnutls_srp_4096_group_prime;
  extern const gnutls_datum_t gnutls_srp_4096_group_generator;

  extern const gnutls_datum_t gnutls_srp_3072_group_prime;
  extern const gnutls_datum_t gnutls_srp_3072_group_generator;

  extern const gnutls_datum_t gnutls_srp_2048_group_prime;
  extern const gnutls_datum_t gnutls_srp_2048_group_generator;

  extern const gnutls_datum_t gnutls_srp_1536_group_prime;
  extern const gnutls_datum_t gnutls_srp_1536_group_generator;

  extern const gnutls_datum_t gnutls_srp_1024_group_prime;
  extern const gnutls_datum_t gnutls_srp_1024_group_generator;

  typedef int gnutls_srp_server_credentials_function (gnutls_session_t,
                                                      const char *username,
                                                      gnutls_datum_t * salt,
                                                      gnutls_datum_t *
                                                      verifier,
                                                      gnutls_datum_t *
                                                      generator,
                                                      gnutls_datum_t * prime);
  void
    gnutls_srp_set_server_credentials_function (
     gnutls_srp_server_credentials_t cred,
     gnutls_srp_server_credentials_function * func);

  typedef int gnutls_srp_client_credentials_function (gnutls_session_t,
                                                      char **, char **);
  void
    gnutls_srp_set_client_credentials_function (
     gnutls_srp_client_credentials_t cred,
     gnutls_srp_client_credentials_function * func);

  int gnutls_srp_base64_encode (const gnutls_datum_t * data, char *result,
                                size_t * result_size);
  int gnutls_srp_base64_encode_alloc (const gnutls_datum_t * data,
                                      gnutls_datum_t * result);

  int gnutls_srp_base64_decode (const gnutls_datum_t * b64_data, char *result,
                                size_t * result_size);
  int gnutls_srp_base64_decode_alloc (const gnutls_datum_t * b64_data,
                                      gnutls_datum_t * result);

/* PSK stuff */
  typedef struct gnutls_psk_server_credentials_st
    *gnutls_psk_server_credentials_t;
  typedef struct gnutls_psk_client_credentials_st
    *gnutls_psk_client_credentials_t;

/**
 * gnutls_psk_key_flags:
 * @GNUTLS_PSK_KEY_RAW: PSK-key in raw format.
 * @GNUTLS_PSK_KEY_HEX: PSK-key in hex format.
 *
 * Enumeration of different PSK key flags.
 */
  typedef enum gnutls_psk_key_flags
  {
    GNUTLS_PSK_KEY_RAW = 0,
    GNUTLS_PSK_KEY_HEX
  } gnutls_psk_key_flags;

  void
    gnutls_psk_free_client_credentials (gnutls_psk_client_credentials_t sc);
  int
    gnutls_psk_allocate_client_credentials (gnutls_psk_client_credentials_t *
                                            sc);
  int gnutls_psk_set_client_credentials (gnutls_psk_client_credentials_t res,
                                         const char *username,
                                         const gnutls_datum_t * key,
                                         gnutls_psk_key_flags flags);

  void
    gnutls_psk_free_server_credentials (gnutls_psk_server_credentials_t sc);
  int
    gnutls_psk_allocate_server_credentials (gnutls_psk_server_credentials_t *
                                            sc);
  int gnutls_psk_set_server_credentials_file (gnutls_psk_server_credentials_t
                                              res, const char *password_file);

  int
    gnutls_psk_set_server_credentials_hint (gnutls_psk_server_credentials_t
                                            res, const char *hint);

  const char *gnutls_psk_server_get_username (gnutls_session_t session);
  const char *gnutls_psk_client_get_hint (gnutls_session_t session);

  typedef int gnutls_psk_server_credentials_function (gnutls_session_t,
                                                      const char *username,
                                                      gnutls_datum_t * key);
  void
    gnutls_psk_set_server_credentials_function (
     gnutls_psk_server_credentials_t cred,
     gnutls_psk_server_credentials_function * func);

  typedef int gnutls_psk_client_credentials_function (gnutls_session_t,
                                                      char **username,
                                                      gnutls_datum_t * key);
  void
    gnutls_psk_set_client_credentials_function (
     gnutls_psk_client_credentials_t cred,
     gnutls_psk_client_credentials_function * func);

  int gnutls_hex_encode (const gnutls_datum_t * data, char *result,
                         size_t * result_size);
  int gnutls_hex_decode (const gnutls_datum_t * hex_data, void *result,
                         size_t * result_size);

  void
    gnutls_psk_set_server_dh_params (gnutls_psk_server_credentials_t res,
                                     gnutls_dh_params_t dh_params);

  void
    gnutls_psk_set_server_params_function (gnutls_psk_server_credentials_t
                                           res,
                                           gnutls_params_function * func);

/**
 * gnutls_x509_subject_alt_name_t:
 * @GNUTLS_SAN_DNSNAME: DNS-name SAN.
 * @GNUTLS_SAN_RFC822NAME: E-mail address SAN.
 * @GNUTLS_SAN_URI: URI SAN.
 * @GNUTLS_SAN_IPADDRESS: IP address SAN.
 * @GNUTLS_SAN_OTHERNAME: OtherName SAN.
 * @GNUTLS_SAN_DN: DN SAN.
 * @GNUTLS_SAN_OTHERNAME_XMPP: Virtual SAN, used by
 *   gnutls_x509_crt_get_subject_alt_othername_oid.
 *
 * Enumeration of different subject alternative names types.
 */
  typedef enum gnutls_x509_subject_alt_name_t
  {
    GNUTLS_SAN_DNSNAME = 1,
    GNUTLS_SAN_RFC822NAME = 2,
    GNUTLS_SAN_URI = 3,
    GNUTLS_SAN_IPADDRESS = 4,
    GNUTLS_SAN_OTHERNAME = 5,
    GNUTLS_SAN_DN = 6,
    /* The following are "virtual" subject alternative name types, in
       that they are represented by an otherName value and an OID.
       Used by gnutls_x509_crt_get_subject_alt_othername_oid.  */
    GNUTLS_SAN_OTHERNAME_XMPP = 1000
  } gnutls_x509_subject_alt_name_t;

  struct gnutls_openpgp_crt_int;
  typedef struct gnutls_openpgp_crt_int *gnutls_openpgp_crt_t;

  struct gnutls_openpgp_privkey_int;
  typedef struct gnutls_openpgp_privkey_int *gnutls_openpgp_privkey_t;

  struct gnutls_pkcs11_privkey_st;
  typedef struct gnutls_pkcs11_privkey_st *gnutls_pkcs11_privkey_t;

/**
 * gnutls_privkey_type_t:
 * @GNUTLS_PRIVKEY_X509: X.509 private key, #gnutls_x509_privkey_t.
 * @GNUTLS_PRIVKEY_OPENPGP: OpenPGP private key, #gnutls_openpgp_privkey_t.
 * @GNUTLS_PRIVKEY_PKCS11: PKCS11 private key, #gnutls_pkcs11_privkey_t.
 * @GNUTLS_PRIVKEY_EXT: External private key, operating using callbacks.
 *
 * Enumeration of different private key types.
 */
  typedef enum
    {
      GNUTLS_PRIVKEY_X509,
      GNUTLS_PRIVKEY_OPENPGP,
      GNUTLS_PRIVKEY_PKCS11,
      GNUTLS_PRIVKEY_EXT
    } gnutls_privkey_type_t;

  typedef struct gnutls_retr2_st
  {
    gnutls_certificate_type_t cert_type;
    gnutls_privkey_type_t key_type;

    union
    {
      gnutls_x509_crt_t *x509;
      gnutls_openpgp_crt_t pgp;
    } cert;
    unsigned int ncerts; /* one for pgp keys */

    union
    {
      gnutls_x509_privkey_t x509;
      gnutls_openpgp_privkey_t pgp;
      gnutls_pkcs11_privkey_t pkcs11;
    } key;

    unsigned int deinit_all; /* if non zero all keys will be deinited */
  } gnutls_retr2_st;


  /* Functions that allow auth_info_t structures handling
   */

  gnutls_credentials_type_t gnutls_auth_get_type (gnutls_session_t session);
    gnutls_credentials_type_t
    gnutls_auth_server_get_type (gnutls_session_t session);
    gnutls_credentials_type_t
    gnutls_auth_client_get_type (gnutls_session_t session);

  /* DH */

  void gnutls_dh_set_prime_bits (gnutls_session_t session, unsigned int bits);
  int gnutls_dh_get_secret_bits (gnutls_session_t session);
  int gnutls_dh_get_peers_public_bits (gnutls_session_t session);
  int gnutls_dh_get_prime_bits (gnutls_session_t session);

  int gnutls_dh_get_group (gnutls_session_t session, gnutls_datum_t * raw_gen,
                           gnutls_datum_t * raw_prime);
  int gnutls_dh_get_pubkey (gnutls_session_t session,
                            gnutls_datum_t * raw_key);

  /* X509PKI */


  /* These are set on the credentials structure.
   */

  /* use gnutls_certificate_set_retrieve_function2() in abstract.h
   * instead. It's much more efficient.
   */

  typedef int gnutls_certificate_retrieve_function (gnutls_session_t,
                                                    const
                                                    gnutls_datum_t *
                                                    req_ca_rdn,
                                                    int nreqs,
                                                    const
                                                    gnutls_pk_algorithm_t
                                                    * pk_algos,
                                                    int
                                                    pk_algos_length,
                                                    gnutls_retr2_st *);


  void gnutls_certificate_set_retrieve_function (
     gnutls_certificate_credentials_t cred,
     gnutls_certificate_retrieve_function * func);

  typedef int gnutls_certificate_verify_function (gnutls_session_t);
  void
    gnutls_certificate_set_verify_function (gnutls_certificate_credentials_t
                                            cred,
                                            gnutls_certificate_verify_function
                                            * func);

  void
    gnutls_certificate_server_set_request (gnutls_session_t session,
                                           gnutls_certificate_request_t req);

  /* get data from the session
   */
  const gnutls_datum_t *gnutls_certificate_get_peers (gnutls_session_t
                                                      session,
                                                      unsigned int
                                                      *list_size);
  const gnutls_datum_t *gnutls_certificate_get_ours (gnutls_session_t
                                                     session);

  int gnutls_certificate_get_peers_subkey_id(gnutls_session_t session,
                                             gnutls_datum_t *id);

  time_t gnutls_certificate_activation_time_peers (gnutls_session_t session);
  time_t gnutls_certificate_expiration_time_peers (gnutls_session_t session);

  int gnutls_certificate_client_get_request_status (gnutls_session_t session);
  int gnutls_certificate_verify_peers2 (gnutls_session_t session,
                                        unsigned int *status);
  int gnutls_certificate_verify_peers3 (gnutls_session_t session,
                                        const char* hostname,
                                        unsigned int *status);

  int gnutls_certificate_verification_status_print (unsigned int status,
                       gnutls_certificate_type_t type,
                       gnutls_datum_t * out, unsigned int flags);

  int gnutls_pem_base64_encode (const char *msg, const gnutls_datum_t * data,
                                char *result, size_t * result_size);
  int gnutls_pem_base64_decode (const char *header,
                                const gnutls_datum_t * b64_data,
                                unsigned char *result, size_t * result_size);

  int gnutls_pem_base64_encode_alloc (const char *msg,
                                      const gnutls_datum_t * data,
                                      gnutls_datum_t * result);
  int gnutls_pem_base64_decode_alloc (const char *header,
                                      const gnutls_datum_t * b64_data,
                                      gnutls_datum_t * result);

  /* key_usage will be an OR of the following values:
   */

  /* when the key is to be used for signing: */


  /* when the key is to be used for encryption: */
# 1870 "/usr/include/gnutls/gnutls.h" 3 4
  void
    gnutls_certificate_set_params_function (gnutls_certificate_credentials_t
                                            res,
                                            gnutls_params_function * func);
  void gnutls_anon_set_params_function (gnutls_anon_server_credentials_t res,
                                        gnutls_params_function * func);
  void gnutls_psk_set_params_function (gnutls_psk_server_credentials_t res,
                                       gnutls_params_function * func);

  int gnutls_hex2bin (const char *hex_data, size_t hex_size,
                      void *bin_data, size_t * bin_size);

  /* Trust on first use (or ssh like) functions */

  /* stores the provided information to a database
   */
  typedef int (*gnutls_tdb_store_func) (const char* db_name,
                                             const char* host,
                                             const char* service,
                                             time_t expiration,
                                             const gnutls_datum_t* pubkey);

  typedef int (*gnutls_tdb_store_commitment_func) (const char* db_name,
                                             const char* host,
                                             const char* service,
                                             time_t expiration,
                                             gnutls_digest_algorithm_t hash_algo,
                                             const gnutls_datum_t* hash);

  /* searches for the provided host/service pair that match the
   * provided public key in the database. */
  typedef int (*gnutls_tdb_verify_func) (const char* db_name,
                                            const char* host,
                                            const char* service,
                                            const gnutls_datum_t *pubkey);


  struct gnutls_tdb_int;
  typedef struct gnutls_tdb_int *gnutls_tdb_t;

  int gnutls_tdb_init (gnutls_tdb_t *tdb);
  void gnutls_tdb_set_store_func (gnutls_tdb_t tdb,
      gnutls_tdb_store_func store);
  void gnutls_tdb_set_store_commitment_func (gnutls_tdb_t tdb,
         gnutls_tdb_store_commitment_func cstore);
  void gnutls_tdb_set_verify_func (gnutls_tdb_t tdb,
       gnutls_tdb_verify_func verify);
  void gnutls_tdb_deinit (gnutls_tdb_t tdb);

  int gnutls_verify_stored_pubkey (const char* db_name,
       gnutls_tdb_t tdb,
       const char* host,
       const char* service,
       gnutls_certificate_type_t cert_type,
       const gnutls_datum_t * cert,
       unsigned int flags);

  int gnutls_store_commitment (const char* db_name,
          gnutls_tdb_t tdb,
          const char* host,
          const char* service,
          gnutls_digest_algorithm_t hash_algo,
          const gnutls_datum_t* hash,
          time_t expiration,
          unsigned int flags);

  int gnutls_store_pubkey (const char* db_name,
      gnutls_tdb_t tdb,
      const char* host,
      const char* service,
      gnutls_certificate_type_t cert_type,
      const gnutls_datum_t * cert,
      time_t expiration,
      unsigned int flags);

  /* Other helper functions */
int gnutls_load_file(const char* filename, gnutls_datum_t * data);

int gnutls_url_is_supported (const char* url);

  /* PIN callback */

/**
 * gnutls_pin_flag_t:
 * @GNUTLS_PIN_USER: The PIN for the user.
 * @GNUTLS_PIN_SO: The PIN for the security officer (admin).
 * @GNUTLS_PIN_CONTEXT_SPECIFIC: The PIN is for a specific action and key like signing.
 * @GNUTLS_PIN_FINAL_TRY: This is the final try before blocking.
 * @GNUTLS_PIN_COUNT_LOW: Few tries remain before token blocks.
 * @GNUTLS_PIN_WRONG: Last given PIN was not correct.
 *
 * Enumeration of different flags that are input to the PIN function.
 */
  typedef enum
    {
    GNUTLS_PIN_USER = (1 << 0),
    GNUTLS_PIN_SO = (1 << 1),
    GNUTLS_PIN_FINAL_TRY = (1 << 2),
    GNUTLS_PIN_COUNT_LOW = (1 << 3),
    GNUTLS_PIN_CONTEXT_SPECIFIC = (1 << 4),
    GNUTLS_PIN_WRONG = (1 << 5),
  } gnutls_pin_flag_t;
# 1980 "/usr/include/gnutls/gnutls.h" 3 4
/**
 * gnutls_pin_callback_t:
 * @userdata: user-controlled data from gnutls_pkcs11_set_pin_function().
 * @attempt: pin-attempt counter, initially 0.
 * @token_url: URL of token.
 * @token_label: label of token.
 * @flags: a #gnutls_pin_flag_t flag.
 * @pin: buffer to hold PIN, of size @pin_max.
 * @pin_max: size of @pin buffer.
 *
 * Callback function type for PKCS#11 or TPM PIN entry.  It is set by
 * functions like gnutls_pkcs11_set_pin_function().
 *
 * The callback should provides the PIN code to unlock the token with
 * label @token_label, specified by the URL @token_url.
 *
 * The PIN code, as a NUL-terminated ASCII string, should be copied
 * into the @pin buffer (of maximum size @pin_max), and return 0 to
 * indicate success.  Alternatively, the callback may return a
 * negative gnutls error code to indicate failure and cancel PIN entry
 * (in which case, the contents of the @pin parameter are ignored).
 *
 * When a PIN is required, the callback will be invoked repeatedly
 * (and indefinitely) until either the returned PIN code is correct,
 * the callback returns failure, or the token refuses login (e.g. when
 * the token is locked due to too many incorrect PINs!).  For the
 * first such invocation, the @attempt counter will have value zero;
 * it will increase by one for each subsequent attempt.
 *
 * Returns: %GNUTLS_E_SUCCESS (0) on success or a negative error code on error.
 *
 * Since: 2.12.0
 **/
typedef int (*gnutls_pin_callback_t) (void *userdata, int attempt,
                                             const char *token_url,
                                             const char *token_label,
          unsigned int flags,
                                             char *pin, size_t pin_max);

  void gnutls_certificate_set_pin_function (gnutls_certificate_credentials_t,
                                            gnutls_pin_callback_t fn, void *userdata);

  /* Gnutls error codes. The mapping to a TLS alert is also shown in
   * comments.
   */
# 2085 "/usr/include/gnutls/gnutls.h" 3 4
  /* returned if you need to generate temporary RSA
   * parameters. These are needed for export cipher suites.
   */
# 2100 "/usr/include/gnutls/gnutls.h" 3 4
  /* For certificate and key stuff
   */
# 2167 "/usr/include/gnutls/gnutls.h" 3 4
/* PKCS11 related */
# 2223 "/usr/include/gnutls/gnutls.h" 3 4
# 1 "/usr/include/gnutls/compat.h" 1 3 4
/*
 * Copyright (C) 2008-2012 Free Software Foundation, Inc.
 *
 * Author: Nikos Mavrogiannopoulos
 *
 * This file is part of GnuTLS.
 *
 * The GnuTLS is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 */

/* Typedefs for more compatibility with older GnuTLS. */
# 49 "/usr/include/gnutls/compat.h" 3 4
/* gnutls_connection_end_t was made redundant in 2.99.0 */
typedef unsigned int gnutls_connection_end_t __attribute__ ((__deprecated__));

/* Stuff deprected in 2.x */
typedef gnutls_cipher_algorithm_t gnutls_cipher_algorithm __attribute__ ((__deprecated__));
typedef gnutls_kx_algorithm_t gnutls_kx_algorithm __attribute__ ((__deprecated__));
typedef gnutls_mac_algorithm_t gnutls_mac_algorithm __attribute__ ((__deprecated__));
typedef gnutls_digest_algorithm_t gnutls_digest_algorithm __attribute__ ((__deprecated__));
typedef gnutls_compression_method_t gnutls_compression_method __attribute__ ((__deprecated__));
typedef gnutls_connection_end_t gnutls_connection_end __attribute__ ((__deprecated__));
typedef gnutls_x509_crt_fmt_t gnutls_x509_crt_fmt __attribute__ ((__deprecated__));
typedef gnutls_pk_algorithm_t gnutls_pk_algorithm __attribute__ ((__deprecated__));
typedef gnutls_sign_algorithm_t gnutls_sign_algorithm __attribute__ ((__deprecated__));
typedef gnutls_close_request_t gnutls_close_request __attribute__ ((__deprecated__));
typedef gnutls_certificate_request_t gnutls_certificate_request __attribute__ ((__deprecated__));
typedef gnutls_certificate_status_t gnutls_certificate_status __attribute__ ((__deprecated__));
typedef gnutls_session_t gnutls_session __attribute__ ((__deprecated__));
typedef gnutls_alert_level_t gnutls_alert_level __attribute__ ((__deprecated__));
typedef gnutls_alert_description_t gnutls_alert_description __attribute__ ((__deprecated__));
typedef gnutls_x509_subject_alt_name_t gnutls_x509_subject_alt_name __attribute__ ((__deprecated__));
typedef gnutls_openpgp_privkey_t gnutls_openpgp_privkey __attribute__ ((__deprecated__));
typedef gnutls_openpgp_keyring_t gnutls_openpgp_keyring __attribute__ ((__deprecated__));
typedef gnutls_x509_crt_t gnutls_x509_crt __attribute__ ((__deprecated__));
typedef gnutls_x509_privkey_t gnutls_x509_privkey __attribute__ ((__deprecated__));
typedef gnutls_x509_crl_t gnutls_x509_crl __attribute__ ((__deprecated__));
typedef gnutls_x509_crq_t gnutls_x509_crq __attribute__ ((__deprecated__));
typedef gnutls_certificate_credentials_t gnutls_certificate_credentials __attribute__ ((__deprecated__));
typedef gnutls_anon_server_credentials_t gnutls_anon_server_credentials __attribute__ ((__deprecated__));
typedef gnutls_anon_client_credentials_t gnutls_anon_client_credentials __attribute__ ((__deprecated__));
typedef gnutls_srp_client_credentials_t gnutls_srp_client_credentials __attribute__ ((__deprecated__));
typedef gnutls_srp_server_credentials_t gnutls_srp_server_credentials __attribute__ ((__deprecated__));
typedef gnutls_dh_params_t gnutls_dh_params __attribute__ ((__deprecated__));
typedef gnutls_rsa_params_t gnutls_rsa_params __attribute__ ((__deprecated__));
typedef gnutls_params_type_t gnutls_params_type __attribute__ ((__deprecated__));
typedef gnutls_credentials_type_t gnutls_credentials_type __attribute__ ((__deprecated__));
typedef gnutls_certificate_type_t gnutls_certificate_type __attribute__ ((__deprecated__));
typedef gnutls_datum_t gnutls_datum __attribute__ ((__deprecated__));
typedef gnutls_transport_ptr_t gnutls_transport_ptr __attribute__ ((__deprecated__));

/* Old SRP alerts removed in 2.1.x because the TLS-SRP RFC was
   modified to use the PSK alert. */



/* OpenPGP stuff renamed in 2.1.x. */



typedef gnutls_openpgp_crt_status_t gnutls_openpgp_key_status_t __attribute__ ((__deprecated__));
typedef gnutls_openpgp_crt_t gnutls_openpgp_key_t __attribute__ ((__deprecated__));
# 113 "/usr/include/gnutls/compat.h" 3 4
/* OpenPGP stuff renamed in 2.3.x. */


/* New better names renamed in 2.3.x, add these for backwards
   compatibility with old poor names.*/




/* Namespace problems. */







/* The gnutls_retr_st was deprecated by gnutls_certificate_retrieve_function()
 * and gnutls_retr2_st.
 */
typedef struct gnutls_retr_st
{
  gnutls_certificate_type_t type;
  union
  {
    gnutls_x509_crt_t *x509;
    gnutls_openpgp_crt_t pgp;
  } cert;
  unsigned int ncerts; /* one for pgp keys */

  union
  {
    gnutls_x509_privkey_t x509;
    gnutls_openpgp_privkey_t pgp;
  } key;

  unsigned int deinit_all; /* if non zero all keys will be deinited */
} gnutls_retr_st;

typedef int gnutls_certificate_client_retrieve_function (gnutls_session_t,
                                                         const
                                                         gnutls_datum_t *
                                                         req_ca_rdn,
                                                         int nreqs,
                                                         const
                                                         gnutls_pk_algorithm_t
                                                         * pk_algos,
                                                         int
                                                         pk_algos_length,
                                                         gnutls_retr_st *);
typedef int gnutls_certificate_server_retrieve_function (gnutls_session_t,
                                                         gnutls_retr_st *);

void gnutls_certificate_client_set_retrieve_function
  (gnutls_certificate_credentials_t cred,
   gnutls_certificate_client_retrieve_function *
   func) __attribute__ ((__deprecated__));
void
  gnutls_certificate_server_set_retrieve_function
  (gnutls_certificate_credentials_t cred,
   gnutls_certificate_server_retrieve_function *
   func) __attribute__ ((__deprecated__));

  /* External signing callback.  No longer supported because it
   * was deprecated by the PKCS #11 API or gnutls_privkey_import_ext. */
typedef int (*gnutls_sign_func) (gnutls_session_t session,
                                 void *userdata,
                                 gnutls_certificate_type_t cert_type,
                                 const gnutls_datum_t * cert,
                                 const gnutls_datum_t * hash,
                                 gnutls_datum_t * signature);

void
gnutls_sign_callback_set (gnutls_session_t session,
                          gnutls_sign_func sign_func, void *userdata)
  __attribute__ ((__deprecated__));
gnutls_sign_func
gnutls_sign_callback_get (gnutls_session_t session, void **userdata)
 __attribute__ ((__deprecated__));

/* This is a very dangerous and error-prone function.
 * Use gnutls_privkey_sign_hash() instead.
 */
  int gnutls_x509_privkey_sign_hash (gnutls_x509_privkey_t key,
                                        const gnutls_datum_t * hash,
                                        gnutls_datum_t * signature)
                                        __attribute__ ((__deprecated__));

  int gnutls_openpgp_privkey_sign_hash (gnutls_openpgp_privkey_t key,
                                       const gnutls_datum_t * hash,
                                       gnutls_datum_t * signature)
                                       __attribute__ ((__deprecated__));

/* we support the gnutls_privkey_sign_data() instead.
 */
  int gnutls_x509_privkey_sign_data (gnutls_x509_privkey_t key,
                                     gnutls_digest_algorithm_t digest,
                                     unsigned int flags,
                                     const gnutls_datum_t * data,
                                     void *signature,
                                     size_t * signature_size)
                                     __attribute__ ((__deprecated__));

  /* gnutls_pubkey_verify_data() */
  int gnutls_x509_crt_verify_data (gnutls_x509_crt_t crt,
                                   unsigned int flags,
                                   const gnutls_datum_t * data,
                                   const gnutls_datum_t * signature)
                                   __attribute__ ((__deprecated__));


  /* gnutls_pubkey_verify_hash() */
  int gnutls_x509_crt_verify_hash (gnutls_x509_crt_t crt,
                                   unsigned int flags,
                                   const gnutls_datum_t * hash,
                                   const gnutls_datum_t * signature)
                                   __attribute__ ((__deprecated__));

  /* gnutls_pubkey_get_verify_algorithm() */
  int gnutls_x509_crt_get_verify_algorithm (gnutls_x509_crt_t crt,
                                            const gnutls_datum_t * signature,
                                            gnutls_digest_algorithm_t * hash)
                                            __attribute__ ((__deprecated__));

  /* gnutls_pubkey_get_preferred_hash_algorithm() */
  int gnutls_x509_crt_get_preferred_hash_algorithm (gnutls_x509_crt_t crt,
                                                    gnutls_digest_algorithm_t
                                                    * hash,
                                                    unsigned int *mand)
                                                    __attribute__ ((__deprecated__));

  /* gnutls_x509_crq_privkey_sign() */
  int gnutls_x509_crq_sign (gnutls_x509_crq_t crq, gnutls_x509_privkey_t key)
                              __attribute__ ((__deprecated__));



  /* gnutls_x509_crl_privkey_sign */
  int gnutls_x509_crl_sign (gnutls_x509_crl_t crl,
                            gnutls_x509_crt_t issuer,
                            gnutls_x509_privkey_t issuer_key)
                            __attribute__ ((__deprecated__));

  /* functions to set priority of cipher suites
   */
  int gnutls_cipher_set_priority (gnutls_session_t session, const int *list)
  __attribute__ ((__deprecated__));
  int gnutls_mac_set_priority (gnutls_session_t session, const int *list)
  __attribute__ ((__deprecated__));
  int gnutls_compression_set_priority (gnutls_session_t session,
                                       const int *list)
                                       __attribute__ ((__deprecated__));
  int gnutls_kx_set_priority (gnutls_session_t session, const int *list)
  __attribute__ ((__deprecated__));
  int gnutls_protocol_set_priority (gnutls_session_t session,
                                    const int *list)
                                    __attribute__ ((__deprecated__));
  int gnutls_certificate_type_set_priority (gnutls_session_t session,
                                            const int *list)
                                            __attribute__ ((__deprecated__));

/* RSA params 
 */
  int gnutls_rsa_params_init (gnutls_rsa_params_t * rsa_params) __attribute__ ((__deprecated__));
  void gnutls_rsa_params_deinit (gnutls_rsa_params_t rsa_params) __attribute__ ((__deprecated__));
  int gnutls_rsa_params_cpy (gnutls_rsa_params_t dst,
                             gnutls_rsa_params_t src) __attribute__ ((__deprecated__));
  int gnutls_rsa_params_import_raw (gnutls_rsa_params_t rsa_params,
                                    const gnutls_datum_t * m,
                                    const gnutls_datum_t * e,
                                    const gnutls_datum_t * d,
                                    const gnutls_datum_t * p,
                                    const gnutls_datum_t * q,
                                    const gnutls_datum_t * u);
  int gnutls_rsa_params_generate2 (gnutls_rsa_params_t params,
                                   unsigned int bits) __attribute__ ((__deprecated__));
  int gnutls_rsa_params_export_raw (gnutls_rsa_params_t rsa,
                                    gnutls_datum_t * m, gnutls_datum_t * e,
                                    gnutls_datum_t * d, gnutls_datum_t * p,
                                    gnutls_datum_t * q, gnutls_datum_t * u,
                                    unsigned int *bits) __attribute__ ((__deprecated__));
  int gnutls_rsa_params_export_pkcs1 (gnutls_rsa_params_t params,
                                      gnutls_x509_crt_fmt_t format,
                                      unsigned char *params_data,
                                      size_t * params_data_size) __attribute__ ((__deprecated__));
  int gnutls_rsa_params_import_pkcs1 (gnutls_rsa_params_t params,
                                      const gnutls_datum_t * pkcs1_params,
                                      gnutls_x509_crt_fmt_t format) __attribute__ ((__deprecated__));

  int gnutls_rsa_export_get_pubkey (gnutls_session_t session,
                                    gnutls_datum_t * exponent,
                                    gnutls_datum_t * modulus) __attribute__ ((__deprecated__));
  int gnutls_rsa_export_get_modulus_bits (gnutls_session_t session) __attribute__ ((__deprecated__));
  int gnutls_set_default_export_priority (gnutls_session_t session) __attribute__ ((__deprecated__));

  void
    gnutls_certificate_set_rsa_export_params (gnutls_certificate_credentials_t
                                              res,
                                              gnutls_rsa_params_t rsa_params) __attribute__ ((__deprecated__));

  /* use gnutls_privkey_sign_hash() with the GNUTLS_PRIVKEY_SIGN_FLAG_TLS1_RSA flag */
  int gnutls_privkey_sign_raw_data (gnutls_privkey_t key,
         unsigned flags,
                              const gnutls_datum_t * data,
                              gnutls_datum_t * signature) __attribute__ ((__deprecated__));
# 2224 "/usr/include/gnutls/gnutls.h" 2 3 4
# 302 "src/tls-gnu.c" 2
/* needed for cert checks in verification and DN extraction: */
# 1 "/usr/include/gnutls/x509.h" 1 3 4
/*
 * Copyright (C) 2003-2012 Free Software Foundation, Inc.
 *
 * Author: Nikos Mavrogiannopoulos
 *
 * This file is part of GnuTLS.
 *
 * The GnuTLS is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 */

/* This file contains the types and prototypes for the X.509
 * certificate and CRL handling functions.
 */




# 1 "/usr/include/gnutls/gnutls.h" 1 3 4
/* -*- c -*-
 * Copyright (C) 2000-2012 Free Software Foundation, Inc.
 *
 * Author: Nikos Mavrogiannopoulos
 *
 * This file is part of GnuTLS.
 *
 * The GnuTLS is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 */

/* This file contains the types and prototypes for all the
 * high level functionality of the gnutls main library.
 *
 * If the optional C++ binding was built, it is available in
 * gnutls/gnutlsxx.h.
 *
 * The openssl compatibility layer (which is under the GNU GPL
 * license) is in gnutls/openssl.h.
 *
 * The low level cipher functionality is in gnutls/crypto.h.
 */
# 31 "/usr/include/gnutls/x509.h" 2 3 4






/* Some OIDs usually found in Distinguished names, or
 * in Subject Directory Attribute extensions.
 */
# 60 "/usr/include/gnutls/x509.h" 3 4
/* The following should not be included in DN.
 */
# 70 "/usr/include/gnutls/x509.h" 3 4
/* Key purpose Object Identifiers.
 */
# 89 "/usr/include/gnutls/x509.h" 3 4
/* Certificate handling functions.
 */

/**
 * gnutls_certificate_import_flags:
 * @GNUTLS_X509_CRT_LIST_IMPORT_FAIL_IF_EXCEED: Fail if the
 *   certificates in the buffer are more than the space allocated for
 *   certificates. The error code will be %GNUTLS_E_SHORT_MEMORY_BUFFER.
 * @GNUTLS_X509_CRT_LIST_FAIL_IF_UNSORTED: Fail if the certificates
 *   in the buffer are not ordered starting from subject to issuer.
 *   The error code will be %GNUTLS_E_CERTIFICATE_LIST_UNSORTED.
 *
 * Enumeration of different certificate import flags.
 */
  typedef enum gnutls_certificate_import_flags
  {
    GNUTLS_X509_CRT_LIST_IMPORT_FAIL_IF_EXCEED = 1,
    GNUTLS_X509_CRT_LIST_FAIL_IF_UNSORTED = 2
  } gnutls_certificate_import_flags;

  int gnutls_x509_crt_init (gnutls_x509_crt_t * cert);
  void gnutls_x509_crt_deinit (gnutls_x509_crt_t cert);
  int gnutls_x509_crt_import (gnutls_x509_crt_t cert,
                              const gnutls_datum_t * data,
                              gnutls_x509_crt_fmt_t format);
  int gnutls_x509_crt_list_import2 (gnutls_x509_crt_t ** certs,
                             unsigned int * size,
                             const gnutls_datum_t * data,
                             gnutls_x509_crt_fmt_t format, unsigned int flags);
  int gnutls_x509_crt_list_import (gnutls_x509_crt_t * certs,
                                   unsigned int *cert_max,
                                   const gnutls_datum_t * data,
                                   gnutls_x509_crt_fmt_t format,
                                   unsigned int flags);
  int gnutls_x509_crt_export (gnutls_x509_crt_t cert,
                              gnutls_x509_crt_fmt_t format,
                              void *output_data, size_t * output_data_size);
  int gnutls_x509_crt_export2 (gnutls_x509_crt_t cert,
                               gnutls_x509_crt_fmt_t format,
                               gnutls_datum_t* out);
  int gnutls_x509_crt_get_private_key_usage_period (gnutls_x509_crt_t cert, time_t* activation, time_t* expiration,
                                     unsigned int *critical);

  int gnutls_x509_crt_get_issuer_dn (gnutls_x509_crt_t cert, char *buf,
                                     size_t * buf_size);
  int gnutls_x509_crt_get_issuer_dn2 (gnutls_x509_crt_t cert, gnutls_datum_t* dn);
  int gnutls_x509_crt_get_issuer_dn_oid (gnutls_x509_crt_t cert, int indx,
                                         void *oid, size_t * oid_size);
  int gnutls_x509_crt_get_issuer_dn_by_oid (gnutls_x509_crt_t cert,
                                            const char *oid, int indx,
                                            unsigned int raw_flag,
                                            void *buf, size_t * buf_size);
  int gnutls_x509_crt_get_dn (gnutls_x509_crt_t cert, char *buf,
                              size_t * buf_size);
  int gnutls_x509_crt_get_dn2 (gnutls_x509_crt_t cert, gnutls_datum_t* dn);
  int gnutls_x509_crt_get_dn_oid (gnutls_x509_crt_t cert, int indx,
                                  void *oid, size_t * oid_size);
  int gnutls_x509_crt_get_dn_by_oid (gnutls_x509_crt_t cert,
                                     const char *oid, int indx,
                                     unsigned int raw_flag, void *buf,
                                     size_t * buf_size);
  int gnutls_x509_crt_check_hostname (gnutls_x509_crt_t cert,
                                      const char *hostname);

  int gnutls_x509_crt_get_signature_algorithm (gnutls_x509_crt_t cert);
  int gnutls_x509_crt_get_signature (gnutls_x509_crt_t cert,
                                     char *sig, size_t * sizeof_sig);
  int gnutls_x509_crt_get_version (gnutls_x509_crt_t cert);
  int gnutls_x509_crt_get_key_id (gnutls_x509_crt_t crt,
                                  unsigned int flags,
                                  unsigned char *output_data,
                                  size_t * output_data_size);

  int gnutls_x509_crt_set_private_key_usage_period (gnutls_x509_crt_t crt,
                                                    time_t activation,
                                                    time_t expiration);
  int gnutls_x509_crt_set_authority_key_id (gnutls_x509_crt_t cert,
                                            const void *id, size_t id_size);
  int gnutls_x509_crt_get_authority_key_id (gnutls_x509_crt_t cert,
                                            void *id, size_t * id_size,
                                            unsigned int *critical);
  int gnutls_x509_crt_get_authority_key_gn_serial (gnutls_x509_crt_t cert,
         unsigned int seq,
         void *alt,
         size_t * alt_size,
         unsigned int *alt_type,
         void* serial,
         size_t *serial_size,
         unsigned int *critical);

  int gnutls_x509_crt_get_subject_key_id (gnutls_x509_crt_t cert,
                                          void *ret, size_t * ret_size,
                                          unsigned int *critical);

  int gnutls_x509_crt_get_subject_unique_id (gnutls_x509_crt_t crt, char *buf,
                                             size_t * buf_size);

  int gnutls_x509_crt_get_issuer_unique_id (gnutls_x509_crt_t crt, char *buf,
                                            size_t * buf_size);

  void gnutls_x509_crt_set_pin_function (gnutls_x509_crt_t crt,
                                       gnutls_pin_callback_t fn, void *userdata);

  /**
   * gnutls_info_access_what_t:
   * @GNUTLS_IA_ACCESSMETHOD_OID: Get accessMethod OID.
   * @GNUTLS_IA_ACCESSLOCATION_GENERALNAME_TYPE: Get accessLocation name type.
   * @GNUTLS_IA_URI: Get accessLocation URI value.
   * @GNUTLS_IA_OCSP_URI: get accessLocation URI value for OCSP.
   * @GNUTLS_IA_CAISSUERS_URI: get accessLocation URI value for caIssuers.
   *
   * Enumeration of types for the @what parameter of
   * gnutls_x509_crt_get_authority_info_access().
   */
  typedef enum gnutls_info_access_what_t
    {
      GNUTLS_IA_ACCESSMETHOD_OID = 1,
      GNUTLS_IA_ACCESSLOCATION_GENERALNAME_TYPE = 2,
      /* use 100-108 for the generalName types, populate as needed */
      GNUTLS_IA_URI = 106,
      /* quick-access variants that match both OID and name type. */
      GNUTLS_IA_OCSP_URI = 10006,
      GNUTLS_IA_CAISSUERS_URI = 10106
    } gnutls_info_access_what_t;

  int gnutls_x509_crt_get_authority_info_access (gnutls_x509_crt_t crt,
       unsigned int seq,
       int what,
       gnutls_datum_t * data,
       unsigned int *critical);


  /**
   * gnutls_x509_crl_reason_flags_t:
   * @GNUTLS_CRL_REASON_PRIVILEGE_WITHDRAWN: The privileges were withdrawn from the owner.
   * @GNUTLS_CRL_REASON_CERTIFICATE_HOLD: The certificate is on hold.
   * @GNUTLS_CRL_REASON_CESSATION_OF_OPERATION: The end-entity is no longer operating.
   * @GNUTLS_CRL_REASON_SUPERSEDED: There is a newer certificate of the owner.
   * @GNUTLS_CRL_REASON_AFFILIATION_CHANGED: The end-entity affiliation has changed.
   * @GNUTLS_CRL_REASON_CA_COMPROMISE: The CA was compromised.
   * @GNUTLS_CRL_REASON_KEY_COMPROMISE: The certificate's key was compromised.
   * @GNUTLS_CRL_REASON_UNUSED: The key was never used.
   * @GNUTLS_CRL_REASON_AA_COMPROMISE: AA compromised.
   *
   * Enumeration of types for the CRL revocation reasons. 
   */
  typedef enum gnutls_x509_crl_reason_flags_t
    {
      GNUTLS_CRL_REASON_UNSPECIFIED=0,
      GNUTLS_CRL_REASON_PRIVILEGE_WITHDRAWN=1,
      GNUTLS_CRL_REASON_CERTIFICATE_HOLD=2,
      GNUTLS_CRL_REASON_CESSATION_OF_OPERATION=4,
      GNUTLS_CRL_REASON_SUPERSEDED=8,
      GNUTLS_CRL_REASON_AFFILIATION_CHANGED=16,
      GNUTLS_CRL_REASON_CA_COMPROMISE=32,
      GNUTLS_CRL_REASON_KEY_COMPROMISE=64,
      GNUTLS_CRL_REASON_UNUSED=128,
      GNUTLS_CRL_REASON_AA_COMPROMISE=32768
    } gnutls_x509_crl_reason_flags_t;

  int gnutls_x509_crt_get_crl_dist_points (gnutls_x509_crt_t cert,
                                           unsigned int seq, void *ret,
                                           size_t * ret_size,
                                           unsigned int *reason_flags,
                                           unsigned int *critical);
  int gnutls_x509_crt_set_crl_dist_points2 (gnutls_x509_crt_t crt,
                                            gnutls_x509_subject_alt_name_t
                                            type, const void *data,
                                            unsigned int data_size,
                                            unsigned int reason_flags);
  int gnutls_x509_crt_set_crl_dist_points (gnutls_x509_crt_t crt,
                                           gnutls_x509_subject_alt_name_t
                                           type, const void *data_string,
                                           unsigned int reason_flags);
  int gnutls_x509_crt_cpy_crl_dist_points (gnutls_x509_crt_t dst,
                                           gnutls_x509_crt_t src);

  int gnutls_x509_crl_sign2 (gnutls_x509_crl_t crl,
                             gnutls_x509_crt_t issuer,
                             gnutls_x509_privkey_t issuer_key,
                             gnutls_digest_algorithm_t dig,
                             unsigned int flags);

  time_t gnutls_x509_crt_get_activation_time (gnutls_x509_crt_t cert);
  time_t gnutls_x509_crt_get_expiration_time (gnutls_x509_crt_t cert);
  int gnutls_x509_crt_get_serial (gnutls_x509_crt_t cert, void *result,
                                  size_t * result_size);

  int gnutls_x509_crt_get_pk_algorithm (gnutls_x509_crt_t cert,
                                        unsigned int *bits);
  int gnutls_x509_crt_get_pk_rsa_raw (gnutls_x509_crt_t crt,
                                      gnutls_datum_t * m, gnutls_datum_t * e);
  int gnutls_x509_crt_get_pk_dsa_raw (gnutls_x509_crt_t crt,
                                      gnutls_datum_t * p,
                                      gnutls_datum_t * q,
                                      gnutls_datum_t * g, gnutls_datum_t * y);

  int gnutls_x509_crt_get_subject_alt_name (gnutls_x509_crt_t cert,
                                            unsigned int seq, void *san,
                                            size_t * san_size,
                                            unsigned int *critical);
  int gnutls_x509_crt_get_subject_alt_name2 (gnutls_x509_crt_t cert,
                                             unsigned int seq, void *san,
                                             size_t * san_size,
                                             unsigned int *san_type,
                                             unsigned int *critical);

  int gnutls_x509_crt_get_subject_alt_othername_oid (gnutls_x509_crt_t cert,
                                                     unsigned int seq,
                                                     void *oid,
                                                     size_t * oid_size);

  int gnutls_x509_crt_get_issuer_alt_name (gnutls_x509_crt_t cert,
                                           unsigned int seq, void *ian,
                                           size_t * ian_size,
                                           unsigned int *critical);
  int gnutls_x509_crt_get_issuer_alt_name2 (gnutls_x509_crt_t cert,
                                            unsigned int seq, void *ian,
                                            size_t * ian_size,
                                            unsigned int *ian_type,
                                            unsigned int *critical);

  int gnutls_x509_crt_get_issuer_alt_othername_oid (gnutls_x509_crt_t cert,
                                                    unsigned int seq,
                                                    void *ret,
                                                    size_t * ret_size);

  int gnutls_x509_crt_get_ca_status (gnutls_x509_crt_t cert,
                                     unsigned int *critical);
  int gnutls_x509_crt_get_basic_constraints (gnutls_x509_crt_t cert,
                                             unsigned int *critical,
                                             unsigned int *ca, int *pathlen);

/* The key_usage flags are defined in gnutls.h. They are the
 * GNUTLS_KEY_* definitions.
 */
  int gnutls_x509_crt_get_key_usage (gnutls_x509_crt_t cert,
                                     unsigned int *key_usage,
                                     unsigned int *critical);
  int gnutls_x509_crt_set_key_usage (gnutls_x509_crt_t crt,
                                     unsigned int usage);
  int gnutls_x509_crt_set_authority_info_access (gnutls_x509_crt_t crt,
                int what,
              gnutls_datum_t * data);

  int gnutls_x509_crt_get_proxy (gnutls_x509_crt_t cert,
                                 unsigned int *critical,
                                 int *pathlen,
                                 char **policyLanguage,
                                 char **policy, size_t * sizeof_policy);



  /**
   * gnutls_x509_qualifier_t:
   * @GNUTLS_X509_QUALIFIER_UNKNOWN: Unknown qualifier.
   * @GNUTLS_X509_QUALIFIER_URI: A URL
   * @GNUTLS_X509_QUALIFIER_NOICE: A text notice.
   *
   * Enumeration of types for the X.509 qualifiers, of the certificate policy extension. 
   */
  typedef enum gnutls_x509_qualifier_t
  {
    GNUTLS_X509_QUALIFIER_UNKNOWN = 0, GNUTLS_X509_QUALIFIER_URI,
    GNUTLS_X509_QUALIFIER_NOTICE
  } gnutls_x509_qualifier_t;

  typedef struct gnutls_x509_policy_st
    {
      char* oid;
      unsigned int qualifiers;
      struct {
        gnutls_x509_qualifier_t type;
        char* data;
        unsigned int size;
      } qualifier[8];
    } gnutls_x509_policy_st;

  void gnutls_x509_policy_release(struct gnutls_x509_policy_st* policy);
  int gnutls_x509_crt_get_policy (gnutls_x509_crt_t crt, int indx,
                                  struct gnutls_x509_policy_st* policy,
                                  unsigned int * critical);
  int gnutls_x509_crt_set_policy (gnutls_x509_crt_t crt, struct gnutls_x509_policy_st* policy,
                            unsigned int critical);

  int gnutls_x509_dn_oid_known (const char *oid);


  const char* gnutls_x509_dn_oid_name (const char *oid, unsigned int flags);

  /* Read extensions by OID. */
  int gnutls_x509_crt_get_extension_oid (gnutls_x509_crt_t cert, int indx,
                                         void *oid, size_t * oid_size);
  int gnutls_x509_crt_get_extension_by_oid (gnutls_x509_crt_t cert,
                                            const char *oid, int indx,
                                            void *buf, size_t * buf_size,
                                            unsigned int *critical);

  /* Read extensions by sequence number. */
  int gnutls_x509_crt_get_extension_info (gnutls_x509_crt_t cert, int indx,
                                          void *oid, size_t * oid_size,
                                          unsigned int *critical);
  int gnutls_x509_crt_get_extension_data (gnutls_x509_crt_t cert, int indx,
                                          void *data, size_t * sizeof_data);

  int gnutls_x509_crt_set_extension_by_oid (gnutls_x509_crt_t crt,
                                            const char *oid,
                                            const void *buf,
                                            size_t sizeof_buf,
                                            unsigned int critical);

/* X.509 Certificate writing.
 */
  int gnutls_x509_crt_set_dn (gnutls_x509_crt_t crt, const char *dn, const char** err);

  int gnutls_x509_crt_set_dn_by_oid (gnutls_x509_crt_t crt,
                                     const char *oid,
                                     unsigned int raw_flag,
                                     const void *name,
                                     unsigned int sizeof_name);
  int gnutls_x509_crt_set_issuer_dn_by_oid (gnutls_x509_crt_t crt,
                                            const char *oid,
                                            unsigned int raw_flag,
                                            const void *name,
                                            unsigned int sizeof_name);
  int gnutls_x509_crt_set_issuer_dn (gnutls_x509_crt_t crt, const char *dn, const char** err);

  int gnutls_x509_crt_set_version (gnutls_x509_crt_t crt,
                                   unsigned int version);
  int gnutls_x509_crt_set_key (gnutls_x509_crt_t crt,
                               gnutls_x509_privkey_t key);
  int gnutls_x509_crt_set_ca_status (gnutls_x509_crt_t crt, unsigned int ca);
  int gnutls_x509_crt_set_basic_constraints (gnutls_x509_crt_t crt,
                                             unsigned int ca,
                                             int pathLenConstraint);
  int gnutls_x509_crt_set_subject_alternative_name (gnutls_x509_crt_t crt,
                                                    gnutls_x509_subject_alt_name_t
                                                    type,
                                                    const char *data_string);
  int gnutls_x509_crt_set_subject_alt_name (gnutls_x509_crt_t crt,
                                            gnutls_x509_subject_alt_name_t
                                            type, const void *data,
                                            unsigned int data_size,
                                            unsigned int flags);
  int gnutls_x509_crt_sign (gnutls_x509_crt_t crt, gnutls_x509_crt_t issuer,
                            gnutls_x509_privkey_t issuer_key);
  int gnutls_x509_crt_sign2 (gnutls_x509_crt_t crt, gnutls_x509_crt_t issuer,
                             gnutls_x509_privkey_t issuer_key,
                             gnutls_digest_algorithm_t dig,
                             unsigned int flags);
  int gnutls_x509_crt_set_activation_time (gnutls_x509_crt_t cert,
                                           time_t act_time);
  int gnutls_x509_crt_set_expiration_time (gnutls_x509_crt_t cert,
                                           time_t exp_time);
  int gnutls_x509_crt_set_serial (gnutls_x509_crt_t cert, const void *serial,
                                  size_t serial_size);

  int gnutls_x509_crt_set_subject_key_id (gnutls_x509_crt_t cert,
                                          const void *id, size_t id_size);

  int gnutls_x509_crt_set_proxy_dn (gnutls_x509_crt_t crt,
                                    gnutls_x509_crt_t eecrt,
                                    unsigned int raw_flag,
                                    const void *name,
                                    unsigned int sizeof_name);
  int gnutls_x509_crt_set_proxy (gnutls_x509_crt_t crt,
                                 int pathLenConstraint,
                                 const char *policyLanguage,
                                 const char *policy, size_t sizeof_policy);

  int gnutls_x509_crt_print (gnutls_x509_crt_t cert,
                             gnutls_certificate_print_formats_t format,
                             gnutls_datum_t * out);
  int gnutls_x509_crl_print (gnutls_x509_crl_t crl,
                             gnutls_certificate_print_formats_t format,
                             gnutls_datum_t * out);

  /* Access to internal Certificate fields.
   */
  int gnutls_x509_crt_get_raw_issuer_dn (gnutls_x509_crt_t cert,
                                         gnutls_datum_t * start);
  int gnutls_x509_crt_get_raw_dn (gnutls_x509_crt_t cert,
                                  gnutls_datum_t * start);

/* RDN handling.
 */
  int gnutls_x509_rdn_get (const gnutls_datum_t * idn,
                           char *buf, size_t * sizeof_buf);
  int gnutls_x509_rdn_get_oid (const gnutls_datum_t * idn,
                               int indx, void *buf, size_t * sizeof_buf);

  int gnutls_x509_rdn_get_by_oid (const gnutls_datum_t * idn,
                                  const char *oid, int indx,
                                  unsigned int raw_flag, void *buf,
                                  size_t * sizeof_buf);

  typedef void *gnutls_x509_dn_t;

  typedef struct gnutls_x509_ava_st
  {
    gnutls_datum_t oid;
    gnutls_datum_t value;
    unsigned long value_tag;
  } gnutls_x509_ava_st;

  int gnutls_x509_crt_get_subject (gnutls_x509_crt_t cert,
                                   gnutls_x509_dn_t * dn);
  int gnutls_x509_crt_get_issuer (gnutls_x509_crt_t cert,
                                  gnutls_x509_dn_t * dn);
  int gnutls_x509_dn_get_rdn_ava (gnutls_x509_dn_t dn, int irdn,
                                  int iava, gnutls_x509_ava_st * ava);

  int gnutls_x509_dn_init (gnutls_x509_dn_t * dn);

  int gnutls_x509_dn_import (gnutls_x509_dn_t dn,
                             const gnutls_datum_t * data);

  int gnutls_x509_dn_export (gnutls_x509_dn_t dn,
                             gnutls_x509_crt_fmt_t format, void *output_data,
                             size_t * output_data_size);
  int gnutls_x509_dn_export2 (gnutls_x509_dn_t dn,
                             gnutls_x509_crt_fmt_t format,
                             gnutls_datum_t * out);

  void gnutls_x509_dn_deinit (gnutls_x509_dn_t dn);


/* CRL handling functions.
 */
  int gnutls_x509_crl_init (gnutls_x509_crl_t * crl);
  void gnutls_x509_crl_deinit (gnutls_x509_crl_t crl);

  int gnutls_x509_crl_import (gnutls_x509_crl_t crl,
                              const gnutls_datum_t * data,
                              gnutls_x509_crt_fmt_t format);
  int gnutls_x509_crl_export (gnutls_x509_crl_t crl,
                              gnutls_x509_crt_fmt_t format,
                              void *output_data, size_t * output_data_size);
  int gnutls_x509_crl_export2 (gnutls_x509_crl_t crl,
                               gnutls_x509_crt_fmt_t format,
                               gnutls_datum_t *out);

  int
  gnutls_x509_crl_get_raw_issuer_dn (gnutls_x509_crl_t crl,
                                      gnutls_datum_t * dn);

  int gnutls_x509_crl_get_issuer_dn (gnutls_x509_crl_t crl,
                                     char *buf, size_t * sizeof_buf);
  int gnutls_x509_crl_get_issuer_dn2 (gnutls_x509_crl_t crl, gnutls_datum_t* dn);
  int gnutls_x509_crl_get_issuer_dn_by_oid (gnutls_x509_crl_t crl,
                                            const char *oid, int indx,
                                            unsigned int raw_flag,
                                            void *buf, size_t * sizeof_buf);
  int gnutls_x509_crl_get_dn_oid (gnutls_x509_crl_t crl, int indx,
                                  void *oid, size_t * sizeof_oid);

  int gnutls_x509_crl_get_signature_algorithm (gnutls_x509_crl_t crl);
  int gnutls_x509_crl_get_signature (gnutls_x509_crl_t crl,
                                     char *sig, size_t * sizeof_sig);
  int gnutls_x509_crl_get_version (gnutls_x509_crl_t crl);

  time_t gnutls_x509_crl_get_this_update (gnutls_x509_crl_t crl);
  time_t gnutls_x509_crl_get_next_update (gnutls_x509_crl_t crl);

  int gnutls_x509_crl_get_crt_count (gnutls_x509_crl_t crl);
  int gnutls_x509_crl_get_crt_serial (gnutls_x509_crl_t crl, int indx,
                                      unsigned char *serial,
                                      size_t * serial_size, time_t * t);



  int gnutls_x509_crl_check_issuer (gnutls_x509_crl_t crl,
                                    gnutls_x509_crt_t issuer);

  int gnutls_x509_crl_list_import2 (gnutls_x509_crl_t ** crls,
                             unsigned int * size,
                             const gnutls_datum_t * data,
                             gnutls_x509_crt_fmt_t format, unsigned int flags);

  int gnutls_x509_crl_list_import (gnutls_x509_crl_t * crls,
                                   unsigned int *crl_max,
                                   const gnutls_datum_t * data,
                                   gnutls_x509_crt_fmt_t format,
                                   unsigned int flags);
/* CRL writing.
 */
  int gnutls_x509_crl_set_version (gnutls_x509_crl_t crl,
                                   unsigned int version);
  int gnutls_x509_crl_set_this_update (gnutls_x509_crl_t crl,
                                       time_t act_time);
  int gnutls_x509_crl_set_next_update (gnutls_x509_crl_t crl,
                                       time_t exp_time);
  int gnutls_x509_crl_set_crt_serial (gnutls_x509_crl_t crl,
                                      const void *serial,
                                      size_t serial_size,
                                      time_t revocation_time);
  int gnutls_x509_crl_set_crt (gnutls_x509_crl_t crl,
                               gnutls_x509_crt_t crt, time_t revocation_time);

  int gnutls_x509_crl_get_authority_key_id (gnutls_x509_crl_t crl, void *id,
                                            size_t * id_size,
                                            unsigned int *critical);
  int gnutls_x509_crl_get_authority_key_gn_serial (gnutls_x509_crl_t crl,
         unsigned int seq,
         void *alt,
         size_t * alt_size,
         unsigned int *alt_type,
         void* serial,
         size_t *serial_size,
         unsigned int *critical);

  int gnutls_x509_crl_get_number (gnutls_x509_crl_t crl, void *ret,
                                  size_t * ret_size, unsigned int *critical);

  int gnutls_x509_crl_get_extension_oid (gnutls_x509_crl_t crl, int indx,
                                         void *oid, size_t * sizeof_oid);

  int gnutls_x509_crl_get_extension_info (gnutls_x509_crl_t crl, int indx,
                                          void *oid, size_t * sizeof_oid,
                                          unsigned int *critical);

  int gnutls_x509_crl_get_extension_data (gnutls_x509_crl_t crl, int indx,
                                          void *data, size_t * sizeof_data);

  int gnutls_x509_crl_set_authority_key_id (gnutls_x509_crl_t crl,
                                            const void *id, size_t id_size);

  int gnutls_x509_crl_set_number (gnutls_x509_crl_t crl,
                                  const void *nr, size_t nr_size);


/* PKCS7 structures handling
 */
  struct gnutls_pkcs7_int;
  typedef struct gnutls_pkcs7_int *gnutls_pkcs7_t;

  int gnutls_pkcs7_init (gnutls_pkcs7_t * pkcs7);
  void gnutls_pkcs7_deinit (gnutls_pkcs7_t pkcs7);
  int gnutls_pkcs7_import (gnutls_pkcs7_t pkcs7,
                           const gnutls_datum_t * data,
                           gnutls_x509_crt_fmt_t format);
  int gnutls_pkcs7_export (gnutls_pkcs7_t pkcs7,
                           gnutls_x509_crt_fmt_t format,
                           void *output_data, size_t * output_data_size);
  int gnutls_pkcs7_export2 (gnutls_pkcs7_t pkcs7,
                            gnutls_x509_crt_fmt_t format,
                            gnutls_datum_t *out);

  int gnutls_pkcs7_get_crt_count (gnutls_pkcs7_t pkcs7);
  int gnutls_pkcs7_get_crt_raw (gnutls_pkcs7_t pkcs7, int indx,
                                void *certificate, size_t * certificate_size);

  int gnutls_pkcs7_set_crt_raw (gnutls_pkcs7_t pkcs7,
                                const gnutls_datum_t * crt);
  int gnutls_pkcs7_set_crt (gnutls_pkcs7_t pkcs7, gnutls_x509_crt_t crt);
  int gnutls_pkcs7_delete_crt (gnutls_pkcs7_t pkcs7, int indx);

  int gnutls_pkcs7_get_crl_raw (gnutls_pkcs7_t pkcs7,
                                int indx, void *crl, size_t * crl_size);
  int gnutls_pkcs7_get_crl_count (gnutls_pkcs7_t pkcs7);

  int gnutls_pkcs7_set_crl_raw (gnutls_pkcs7_t pkcs7,
                                const gnutls_datum_t * crl);
  int gnutls_pkcs7_set_crl (gnutls_pkcs7_t pkcs7, gnutls_x509_crl_t crl);
  int gnutls_pkcs7_delete_crl (gnutls_pkcs7_t pkcs7, int indx);

/* X.509 Certificate verification functions.
 */

/**
 * gnutls_certificate_verify_flags:
 * @GNUTLS_VERIFY_DISABLE_CA_SIGN: If set a signer does not have to be
 *   a certificate authority. This flag should normaly be disabled,
 *   unless you know what this means.
 * @GNUTLS_VERIFY_DISABLE_TRUSTED_TIME_CHECKS: If set a signer in the trusted
 *   list is never checked for expiration or activation.
 * @GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT: Allow trusted CA certificates
 *   with version 1. This is safer than %GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT,
 *   and should be used instead. That way only signers in your trusted list
 *   will be allowed to have certificates of version 1. This is the default.
 * @GNUTLS_VERIFY_DO_NOT_ALLOW_X509_V1_CA_CRT: Do not allow trusted CA
 *   certificates that have version 1.  This option is to be used
 *   to deprecate all certificates of version 1.
 * @GNUTLS_VERIFY_DO_NOT_ALLOW_SAME: If a certificate is not signed by
 *   anyone trusted but exists in the trusted CA list do not treat it
 *   as trusted.
 * @GNUTLS_VERIFY_ALLOW_UNSORTED_CHAIN: A certificate chain is tolerated
 *   if unsorted (the case with many TLS servers out there). This is the
 *   default since GnuTLS 3.1.4.
 * @GNUTLS_VERIFY_DO_NOT_ALLOW_UNSORTED_CHAIN: Do not tolerate an unsorted
 *   certificate chain.
 * @GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT: Allow CA certificates that
 *   have version 1 (both root and intermediate). This might be
 *   dangerous since those haven't the basicConstraints
 *   extension. Must be used in combination with
 *   %GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT.
 * @GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD2: Allow certificates to be signed
 *   using the broken MD2 algorithm.
 * @GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5: Allow certificates to be signed
 *   using the broken MD5 algorithm.
 * @GNUTLS_VERIFY_DISABLE_TIME_CHECKS: Disable checking of activation
 *   and expiration validity periods of certificate chains. Don't set
 *   this unless you understand the security implications.
 * @GNUTLS_VERIFY_DISABLE_CRL_CHECKS: Disable checking for validity
 *   using certificate revocation lists or the available OCSP data.
 *
 * Enumeration of different certificate verify flags.
 */
  typedef enum gnutls_certificate_verify_flags
  {
    GNUTLS_VERIFY_DISABLE_CA_SIGN = 1<<0,
    GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT = 1<<1,
    GNUTLS_VERIFY_DO_NOT_ALLOW_SAME = 1<<2,
    GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT = 1<<3,
    GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD2 = 1<<4,
    GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5 = 1<<5,
    GNUTLS_VERIFY_DISABLE_TIME_CHECKS = 1<<6,
    GNUTLS_VERIFY_DISABLE_TRUSTED_TIME_CHECKS = 1<<7,
    GNUTLS_VERIFY_DO_NOT_ALLOW_X509_V1_CA_CRT = 1<<8,
    GNUTLS_VERIFY_DISABLE_CRL_CHECKS = 1<<9,
    GNUTLS_VERIFY_ALLOW_UNSORTED_CHAIN = 1<<10,
    GNUTLS_VERIFY_DO_NOT_ALLOW_UNSORTED_CHAIN = 1<<11,
  } gnutls_certificate_verify_flags;

  int gnutls_x509_crt_check_issuer (gnutls_x509_crt_t cert,
                                    gnutls_x509_crt_t issuer);

  int gnutls_x509_crt_list_verify (const gnutls_x509_crt_t * cert_list,
                                   int cert_list_length,
                                   const gnutls_x509_crt_t * CA_list,
                                   int CA_list_length,
                                   const gnutls_x509_crl_t * CRL_list,
                                   int CRL_list_length,
                                   unsigned int flags, unsigned int *verify);

  int gnutls_x509_crt_verify (gnutls_x509_crt_t cert,
                              const gnutls_x509_crt_t * CA_list,
                              int CA_list_length, unsigned int flags,
                              unsigned int *verify);
  int gnutls_x509_crl_verify (gnutls_x509_crl_t crl,
                              const gnutls_x509_crt_t * CA_list,
                              int CA_list_length, unsigned int flags,
                              unsigned int *verify);

  int gnutls_x509_crt_check_revocation (gnutls_x509_crt_t cert,
                                        const gnutls_x509_crl_t *
                                        crl_list, int crl_list_length);

  int gnutls_x509_crt_get_fingerprint (gnutls_x509_crt_t cert,
                                       gnutls_digest_algorithm_t algo,
                                       void *buf, size_t * buf_size);

  int gnutls_x509_crt_get_key_purpose_oid (gnutls_x509_crt_t cert,
                                           int indx, void *oid,
                                           size_t * oid_size,
                                           unsigned int *critical);
  int gnutls_x509_crt_set_key_purpose_oid (gnutls_x509_crt_t cert,
                                           const void *oid,
                                           unsigned int critical);

/* Private key handling.
 */

/* Flags for the gnutls_x509_privkey_export_pkcs8() function.
 */






/**
 * gnutls_pkcs_encrypt_flags_t:
 * @GNUTLS_PKCS_PLAIN: Unencrypted private key.
 * @GNUTLS_PKCS_NULL_PASSWORD: Some schemas distinguish between an empty and a NULL password.
 * @GNUTLS_PKCS_USE_PKCS12_3DES: PKCS-12 3DES.
 * @GNUTLS_PKCS_USE_PKCS12_ARCFOUR: PKCS-12 ARCFOUR.
 * @GNUTLS_PKCS_USE_PKCS12_RC2_40: PKCS-12 RC2-40.
 * @GNUTLS_PKCS_USE_PBES2_3DES: PBES2 3DES.
 * @GNUTLS_PKCS_USE_PBES2_AES_128: PBES2 AES-128.
 * @GNUTLS_PKCS_USE_PBES2_AES_192: PBES2 AES-192.
 * @GNUTLS_PKCS_USE_PBES2_AES_256: PBES2 AES-256.
 *
 * Enumeration of different PKCS encryption flags.
 */
  typedef enum gnutls_pkcs_encrypt_flags_t
  {
    GNUTLS_PKCS_PLAIN = 1,
    GNUTLS_PKCS_USE_PKCS12_3DES = 2,
    GNUTLS_PKCS_USE_PKCS12_ARCFOUR = 4,
    GNUTLS_PKCS_USE_PKCS12_RC2_40 = 8,
    GNUTLS_PKCS_USE_PBES2_3DES = 16,
    GNUTLS_PKCS_USE_PBES2_AES_128 = 32,
    GNUTLS_PKCS_USE_PBES2_AES_192 = 64,
    GNUTLS_PKCS_USE_PBES2_AES_256 = 128,
    GNUTLS_PKCS_NULL_PASSWORD = 256
  } gnutls_pkcs_encrypt_flags_t;

  int gnutls_x509_privkey_init (gnutls_x509_privkey_t * key);
  void gnutls_x509_privkey_deinit (gnutls_x509_privkey_t key);
  gnutls_sec_param_t gnutls_x509_privkey_sec_param (gnutls_x509_privkey_t
                                                    key);
  int gnutls_x509_privkey_cpy (gnutls_x509_privkey_t dst,
                               gnutls_x509_privkey_t src);
  int gnutls_x509_privkey_import (gnutls_x509_privkey_t key,
                                  const gnutls_datum_t * data,
                                  gnutls_x509_crt_fmt_t format);
  int gnutls_x509_privkey_import_pkcs8 (gnutls_x509_privkey_t key,
                                        const gnutls_datum_t * data,
                                        gnutls_x509_crt_fmt_t format,
                                        const char *password,
                                        unsigned int flags);
  int gnutls_x509_privkey_import_openssl (gnutls_x509_privkey_t key,
                                          const gnutls_datum_t *data,
                                          const char* password);

  int gnutls_x509_privkey_import2 (gnutls_x509_privkey_t key,
                                   const gnutls_datum_t * data,
                                   gnutls_x509_crt_fmt_t format,
                                   const char* password, unsigned int flags);

  int gnutls_x509_privkey_import_rsa_raw (gnutls_x509_privkey_t key,
                                          const gnutls_datum_t * m,
                                          const gnutls_datum_t * e,
                                          const gnutls_datum_t * d,
                                          const gnutls_datum_t * p,
                                          const gnutls_datum_t * q,
                                          const gnutls_datum_t * u);
  int gnutls_x509_privkey_import_rsa_raw2 (gnutls_x509_privkey_t key,
                                           const gnutls_datum_t * m,
                                           const gnutls_datum_t * e,
                                           const gnutls_datum_t * d,
                                           const gnutls_datum_t * p,
                                           const gnutls_datum_t * q,
                                           const gnutls_datum_t * u,
                                           const gnutls_datum_t * e1,
                                           const gnutls_datum_t * e2);
  int gnutls_x509_privkey_import_ecc_raw (gnutls_x509_privkey_t key,
                                          gnutls_ecc_curve_t curve,
                                          const gnutls_datum_t * x,
                                          const gnutls_datum_t * y,
                                          const gnutls_datum_t * k);

  int gnutls_x509_privkey_fix (gnutls_x509_privkey_t key);

  int gnutls_x509_privkey_export_dsa_raw (gnutls_x509_privkey_t key,
                                          gnutls_datum_t * p,
                                          gnutls_datum_t * q,
                                          gnutls_datum_t * g,
                                          gnutls_datum_t * y,
                                          gnutls_datum_t * x);
  int gnutls_x509_privkey_import_dsa_raw (gnutls_x509_privkey_t key,
                                          const gnutls_datum_t * p,
                                          const gnutls_datum_t * q,
                                          const gnutls_datum_t * g,
                                          const gnutls_datum_t * y,
                                          const gnutls_datum_t * x);

  int gnutls_x509_privkey_get_pk_algorithm (gnutls_x509_privkey_t key);
  int gnutls_x509_privkey_get_pk_algorithm2 (gnutls_x509_privkey_t key, unsigned int *bits);
  int gnutls_x509_privkey_get_key_id (gnutls_x509_privkey_t key,
                                      unsigned int flags,
                                      unsigned char *output_data,
                                      size_t * output_data_size);

  int gnutls_x509_privkey_generate (gnutls_x509_privkey_t key,
                                    gnutls_pk_algorithm_t algo,
                                    unsigned int bits, unsigned int flags);
  int gnutls_x509_privkey_verify_params (gnutls_x509_privkey_t key);

  int gnutls_x509_privkey_export (gnutls_x509_privkey_t key,
                                  gnutls_x509_crt_fmt_t format,
                                  void *output_data,
                                  size_t * output_data_size);
  int gnutls_x509_privkey_export2 (gnutls_x509_privkey_t key,
                                   gnutls_x509_crt_fmt_t format,
                                   gnutls_datum_t * out);
  int gnutls_x509_privkey_export_pkcs8 (gnutls_x509_privkey_t key,
                                        gnutls_x509_crt_fmt_t format,
                                        const char *password,
                                        unsigned int flags,
                                        void *output_data,
                                        size_t * output_data_size);
  int gnutls_x509_privkey_export2_pkcs8 (gnutls_x509_privkey_t key,
                                         gnutls_x509_crt_fmt_t format,
                                         const char *password,
                                         unsigned int flags,
                                         gnutls_datum_t * out);
  int gnutls_x509_privkey_export_rsa_raw2 (gnutls_x509_privkey_t key,
                                           gnutls_datum_t * m,
                                           gnutls_datum_t * e,
                                           gnutls_datum_t * d,
                                           gnutls_datum_t * p,
                                           gnutls_datum_t * q,
                                           gnutls_datum_t * u,
                                           gnutls_datum_t * e1,
                                           gnutls_datum_t * e2);
  int gnutls_x509_privkey_export_rsa_raw (gnutls_x509_privkey_t key,
                                          gnutls_datum_t * m,
                                          gnutls_datum_t * e,
                                          gnutls_datum_t * d,
                                          gnutls_datum_t * p,
                                          gnutls_datum_t * q,
                                          gnutls_datum_t * u);
  int gnutls_x509_privkey_export_ecc_raw (gnutls_x509_privkey_t key,
                                          gnutls_ecc_curve_t *curve,
                                          gnutls_datum_t * x, gnutls_datum_t * y,
                                          gnutls_datum_t* k);
/* Certificate request stuff.
 */

  int gnutls_x509_crq_sign2 (gnutls_x509_crq_t crq,
                             gnutls_x509_privkey_t key,
                             gnutls_digest_algorithm_t dig,
                             unsigned int flags);

  int gnutls_x509_crq_print (gnutls_x509_crq_t crq,
                             gnutls_certificate_print_formats_t format,
                             gnutls_datum_t * out);

  int gnutls_x509_crq_verify (gnutls_x509_crq_t crq, unsigned int flags);

  int gnutls_x509_crq_init (gnutls_x509_crq_t * crq);
  void gnutls_x509_crq_deinit (gnutls_x509_crq_t crq);
  int gnutls_x509_crq_import (gnutls_x509_crq_t crq,
                              const gnutls_datum_t * data,
                              gnutls_x509_crt_fmt_t format);

  int gnutls_x509_crq_get_private_key_usage_period (gnutls_x509_crq_t cert, time_t* activation, time_t* expiration,
                                     unsigned int *critical);

  int gnutls_x509_crq_get_dn (gnutls_x509_crq_t crq, char *buf,
                              size_t * sizeof_buf);
  int gnutls_x509_crq_get_dn2 (gnutls_x509_crq_t crq, gnutls_datum_t* dn);
  int gnutls_x509_crq_get_dn_oid (gnutls_x509_crq_t crq, int indx,
                                  void *oid, size_t * sizeof_oid);
  int gnutls_x509_crq_get_dn_by_oid (gnutls_x509_crq_t crq,
                                     const char *oid, int indx,
                                     unsigned int raw_flag, void *buf,
                                     size_t * sizeof_buf);
  int gnutls_x509_crq_set_dn (gnutls_x509_crq_t crq, const char *dn, const char** err);
  int gnutls_x509_crq_set_dn_by_oid (gnutls_x509_crq_t crq,
                                     const char *oid,
                                     unsigned int raw_flag,
                                     const void *data,
                                     unsigned int sizeof_data);
  int gnutls_x509_crq_set_version (gnutls_x509_crq_t crq,
                                   unsigned int version);
  int gnutls_x509_crq_get_version (gnutls_x509_crq_t crq);
  int gnutls_x509_crq_set_key (gnutls_x509_crq_t crq,
                               gnutls_x509_privkey_t key);

  int gnutls_x509_crq_set_challenge_password (gnutls_x509_crq_t crq,
                                              const char *pass);
  int gnutls_x509_crq_get_challenge_password (gnutls_x509_crq_t crq,
                                              char *pass,
                                              size_t * sizeof_pass);

  int gnutls_x509_crq_set_attribute_by_oid (gnutls_x509_crq_t crq,
                                            const char *oid, void *buf,
                                            size_t sizeof_buf);
  int gnutls_x509_crq_get_attribute_by_oid (gnutls_x509_crq_t crq,
                                            const char *oid, int indx,
                                            void *buf, size_t * sizeof_buf);

  int gnutls_x509_crq_export (gnutls_x509_crq_t crq,
                              gnutls_x509_crt_fmt_t format,
                              void *output_data, size_t * output_data_size);
  int gnutls_x509_crq_export2 (gnutls_x509_crq_t crq,
                               gnutls_x509_crt_fmt_t format,
                               gnutls_datum_t * out);

  int gnutls_x509_crt_set_crq (gnutls_x509_crt_t crt, gnutls_x509_crq_t crq);
  int gnutls_x509_crt_set_crq_extensions (gnutls_x509_crt_t crt,
                                          gnutls_x509_crq_t crq);

  int gnutls_x509_crq_set_private_key_usage_period (gnutls_x509_crq_t crq,
                                              time_t activation,
                                              time_t expiration);
  int gnutls_x509_crq_set_key_rsa_raw (gnutls_x509_crq_t crq,
                                       const gnutls_datum_t * m,
                                       const gnutls_datum_t * e);
  int gnutls_x509_crq_set_subject_alt_name (gnutls_x509_crq_t crq,
                                            gnutls_x509_subject_alt_name_t nt,
                                            const void *data,
                                            unsigned int data_size,
                                            unsigned int flags);

  int gnutls_x509_crq_set_key_usage (gnutls_x509_crq_t crq,
                                     unsigned int usage);
  int gnutls_x509_crq_set_basic_constraints (gnutls_x509_crq_t crq,
                                             unsigned int ca,
                                             int pathLenConstraint);
  int gnutls_x509_crq_set_key_purpose_oid (gnutls_x509_crq_t crq,
                                           const void *oid,
                                           unsigned int critical);
  int gnutls_x509_crq_get_key_purpose_oid (gnutls_x509_crq_t crq, int indx,
                                           void *oid, size_t * sizeof_oid,
                                           unsigned int *critical);

  int gnutls_x509_crq_get_extension_data (gnutls_x509_crq_t crq, int indx,
                                          void *data, size_t * sizeof_data);
  int gnutls_x509_crq_get_extension_info (gnutls_x509_crq_t crq, int indx,
                                          void *oid, size_t * sizeof_oid,
                                          unsigned int *critical);
  int gnutls_x509_crq_get_attribute_data (gnutls_x509_crq_t crq, int indx,
                                          void *data, size_t * sizeof_data);
  int gnutls_x509_crq_get_attribute_info (gnutls_x509_crq_t crq, int indx,
                                          void *oid, size_t * sizeof_oid);
  int gnutls_x509_crq_get_pk_algorithm (gnutls_x509_crq_t crq,
                                        unsigned int *bits);

  int gnutls_x509_crq_get_key_id (gnutls_x509_crq_t crq, unsigned int flags,
                                  unsigned char *output_data,
                                  size_t * output_data_size);
  int gnutls_x509_crq_get_key_rsa_raw (gnutls_x509_crq_t crq,
                                       gnutls_datum_t * m,
                                       gnutls_datum_t * e);

  int gnutls_x509_crq_get_key_usage (gnutls_x509_crq_t crq,
                                     unsigned int *key_usage,
                                     unsigned int *critical);
  int gnutls_x509_crq_get_basic_constraints (gnutls_x509_crq_t crq,
                                             unsigned int *critical,
                                             unsigned int *ca, int *pathlen);
  int gnutls_x509_crq_get_subject_alt_name (gnutls_x509_crq_t crq,
                                            unsigned int seq, void *ret,
                                            size_t * ret_size,
                                            unsigned int *ret_type,
                                            unsigned int *critical);
  int gnutls_x509_crq_get_subject_alt_othername_oid (gnutls_x509_crq_t crq,
                                                     unsigned int seq,
                                                     void *ret,
                                                     size_t * ret_size);

  int gnutls_x509_crq_get_extension_by_oid (gnutls_x509_crq_t crq,
                                            const char *oid, int indx,
                                            void *buf, size_t * sizeof_buf,
                                            unsigned int *critical);

  typedef struct gnutls_x509_trust_list_st *gnutls_x509_trust_list_t;

  int
  gnutls_x509_trust_list_init (gnutls_x509_trust_list_t * list, unsigned int size);

  void
  gnutls_x509_trust_list_deinit (gnutls_x509_trust_list_t list, unsigned int all);

  int gnutls_x509_trust_list_get_issuer(gnutls_x509_trust_list_t list,
    gnutls_x509_crt_t cert, gnutls_x509_crt_t* issuer, unsigned int flags);

  int
  gnutls_x509_trust_list_add_cas (gnutls_x509_trust_list_t list,
    const gnutls_x509_crt_t * clist, int clist_size, unsigned int flags);
  int gnutls_x509_trust_list_remove_cas(gnutls_x509_trust_list_t list,
                               const gnutls_x509_crt_t * clist,
                               int clist_size);

  int gnutls_x509_trust_list_add_named_crt (gnutls_x509_trust_list_t list,
      gnutls_x509_crt_t cert, const void* name, size_t name_size, unsigned int flags);


  int
  gnutls_x509_trust_list_add_crls (gnutls_x509_trust_list_t list,
    const gnutls_x509_crl_t * crl_list, int crl_size, unsigned int flags,
    unsigned int verification_flags);

  typedef int gnutls_verify_output_function (
    gnutls_x509_crt_t cert,
    gnutls_x509_crt_t issuer, /* The issuer if verification failed 
     * because of him. might be null.
     */
    gnutls_x509_crl_t crl, /* The CRL that caused verification failure 
     * if any. Might be null. 
     */
    unsigned int verification_output);

  int gnutls_x509_trust_list_verify_named_crt (
      gnutls_x509_trust_list_t list,
      gnutls_x509_crt_t cert,
      const void * name, size_t name_size,
      unsigned int flags,
      unsigned int *verify,
      gnutls_verify_output_function func);

  int
  gnutls_x509_trust_list_verify_crt (
    gnutls_x509_trust_list_t list,
    gnutls_x509_crt_t *cert_list,
    unsigned int cert_list_size,
    unsigned int flags,
    unsigned int *verify,
    gnutls_verify_output_function func);

  /* trust list convenience functions */
int
gnutls_x509_trust_list_add_trust_mem(gnutls_x509_trust_list_t list,
                                     const gnutls_datum_t * cas,
                                     const gnutls_datum_t * crls,
                                     gnutls_x509_crt_fmt_t type,
                                     unsigned int tl_flags,
                                     unsigned int tl_vflags);

int
gnutls_x509_trust_list_add_trust_file(gnutls_x509_trust_list_t list,
                                      const char* ca_file,
                                      const char* crl_file,
                                      gnutls_x509_crt_fmt_t type,
                                      unsigned int tl_flags,
                                      unsigned int tl_vflags);

int
gnutls_x509_trust_list_remove_trust_file(gnutls_x509_trust_list_t list,
                                      const char* ca_file,
                                      gnutls_x509_crt_fmt_t type);

int
gnutls_x509_trust_list_remove_trust_mem(gnutls_x509_trust_list_t list,
                                     const gnutls_datum_t * cas,
                                     gnutls_x509_crt_fmt_t type);

int
gnutls_x509_trust_list_add_system_trust(gnutls_x509_trust_list_t list,
                                        unsigned int tl_flags, unsigned int tl_vflags);
# 304 "src/tls-gnu.c" 2
/* man-page is incorrect, gnutls_rnd() is not in gnutls.h: */
# 1 "/usr/include/gnutls/crypto.h" 1 3 4
/*
 * Copyright (C) 2008-2012 Free Software Foundation, Inc.
 *
 * Author: Nikos Mavrogiannopoulos
 *
 * This file is part of GnuTLS.
 *
 * The GnuTLS is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 */
# 31 "/usr/include/gnutls/crypto.h" 3 4
  typedef struct api_cipher_hd_st *gnutls_cipher_hd_t;

  int gnutls_cipher_init (gnutls_cipher_hd_t * handle,
                          gnutls_cipher_algorithm_t cipher,
                          const gnutls_datum_t * key,
                          const gnutls_datum_t * iv);
  int gnutls_cipher_encrypt (const gnutls_cipher_hd_t handle,
                             void *text, size_t textlen);
  int gnutls_cipher_decrypt (const gnutls_cipher_hd_t handle,
                             void *ciphertext, size_t ciphertextlen);
  int gnutls_cipher_decrypt2 (gnutls_cipher_hd_t handle,
                              const void *ciphertext, size_t ciphertextlen,
                              void *text, size_t textlen);
  int gnutls_cipher_encrypt2 (gnutls_cipher_hd_t handle, const void *text,
                              size_t textlen, void *ciphertext,
                              size_t ciphertextlen);

  void gnutls_cipher_set_iv (gnutls_cipher_hd_t handle, void *iv, size_t ivlen);

  int gnutls_cipher_tag( gnutls_cipher_hd_t handle, void* tag, size_t tag_size);
  int gnutls_cipher_add_auth( gnutls_cipher_hd_t handle, const void* text, size_t text_size);

  void gnutls_cipher_deinit (gnutls_cipher_hd_t handle);
  int gnutls_cipher_get_block_size (gnutls_cipher_algorithm_t algorithm);
  int gnutls_cipher_get_iv_size (gnutls_cipher_algorithm_t algorithm);


  typedef struct hash_hd_st *gnutls_hash_hd_t;
  typedef struct hmac_hd_st *gnutls_hmac_hd_t;

  size_t gnutls_mac_get_nonce_size (gnutls_mac_algorithm_t algorithm);
  int gnutls_hmac_init (gnutls_hmac_hd_t * dig,
                        gnutls_mac_algorithm_t algorithm, const void *key,
                        size_t keylen);
  void gnutls_hmac_set_nonce (gnutls_hmac_hd_t handle, const void *nonce, size_t nonce_len);
  int gnutls_hmac (gnutls_hmac_hd_t handle, const void *text, size_t textlen);
  void gnutls_hmac_output (gnutls_hmac_hd_t handle, void *digest);
  void gnutls_hmac_deinit (gnutls_hmac_hd_t handle, void *digest);
  int gnutls_hmac_get_len (gnutls_mac_algorithm_t algorithm);
  int gnutls_hmac_fast (gnutls_mac_algorithm_t algorithm, const void *key,
                        size_t keylen, const void *text, size_t textlen,
                        void *digest);

  int gnutls_hash_init (gnutls_hash_hd_t * dig,
                        gnutls_digest_algorithm_t algorithm);
  int gnutls_hash (gnutls_hash_hd_t handle, const void *text, size_t textlen);
  void gnutls_hash_output (gnutls_hash_hd_t handle, void *digest);
  void gnutls_hash_deinit (gnutls_hash_hd_t handle, void *digest);
  int gnutls_hash_get_len (gnutls_digest_algorithm_t algorithm);
  int gnutls_hash_fast (gnutls_digest_algorithm_t algorithm,
                        const void *text, size_t textlen, void *digest);

/* register ciphers */


/**
 * gnutls_rnd_level_t:
 * @GNUTLS_RND_NONCE: Non-predictable random number.  Fatal in parts
 *   of session if broken, i.e., vulnerable to statistical analysis.
 * @GNUTLS_RND_RANDOM: Pseudo-random cryptographic random number.
 *   Fatal in session if broken.
 * @GNUTLS_RND_KEY: Fatal in many sessions if broken.
 *
 * Enumeration of random quality levels.
 */
  typedef enum gnutls_rnd_level
  {
    GNUTLS_RND_NONCE = 0,
    GNUTLS_RND_RANDOM = 1,
    GNUTLS_RND_KEY = 2
  } gnutls_rnd_level_t;

  int gnutls_rnd (gnutls_rnd_level_t level, void *data, size_t len);

  void gnutls_rnd_refresh (void);
# 306 "src/tls-gnu.c" 2

/* GnuTLS 2 vs 3

GnuTLS 3 only:
  gnutls_global_set_audit_log_function()

Changes:
  gnutls_certificate_verify_peers2(): is new, drop the 2 for old version
*/

/* Local static variables for GnuTLS */

/* Values for verify_requirement */

enum peer_verify_requirement { VERIFY_NONE, VERIFY_OPTIONAL, VERIFY_REQUIRED };

/* This holds most state for server or client; with this, we can set up an
outbound TLS-enabled connection in an ACL callout, while not stomping all
over the TLS variables available for expansion.

Some of these correspond to variables in globals.c; those variables will
be set to point to content in one of these instances, as appropriate for
the stage of the process lifetime.

Not handled here: globals tls_active, tls_bits, tls_cipher, tls_peerdn,
tls_certificate_verified, tls_channelbinding_b64, tls_sni.
*/

typedef struct exim_gnutls_state {
  gnutls_session_t session;
  gnutls_certificate_credentials_t x509_cred;
  gnutls_priority_t priority_cache;
  enum peer_verify_requirement verify_requirement;
  int fd_in;
  int fd_out;
  BOOL peer_cert_verified;
  BOOL trigger_sni_changes;
  BOOL have_set_peerdn;
  const struct host_item *host;
  uschar *peerdn;
  uschar *ciphersuite;
  uschar *received_sni;

  const uschar *tls_certificate;
  const uschar *tls_privatekey;
  const uschar *tls_sni; /* client send only, not received */
  const uschar *tls_verify_certificates;
  const uschar *tls_crl;
  const uschar *tls_require_ciphers;
  uschar *exp_tls_certificate;
  uschar *exp_tls_privatekey;
  uschar *exp_tls_sni;
  uschar *exp_tls_verify_certificates;
  uschar *exp_tls_crl;
  uschar *exp_tls_require_ciphers;

  uschar *xfer_buffer;
  int xfer_buffer_lwm;
  int xfer_buffer_hwm;
  int xfer_eof;
  int xfer_error;
} exim_gnutls_state_st;

static const exim_gnutls_state_st exim_gnutls_state_init = {
  ((void *)0), ((void *)0), ((void *)0), VERIFY_NONE, -1, -1, 0, 0, 0,
  ((void *)0), ((void *)0), ((void *)0), ((void *)0),
  ((void *)0), ((void *)0), ((void *)0), ((void *)0), ((void *)0), ((void *)0),
  ((void *)0), ((void *)0), ((void *)0), ((void *)0), ((void *)0), ((void *)0),
  ((void *)0), 0, 0, 0, 0,
};

/* Not only do we have our own APIs which don't pass around state, assuming
it's held in globals, GnuTLS doesn't appear to let us register callback data
for callbacks, or as part of the session, so we have to keep a "this is the
context we're currently dealing with" pointer and rely upon being
single-threaded to keep from processing data on an inbound TLS connection while
talking to another TLS connection for an outbound check.  This does mean that
there's no way for heart-beats to be responded to, for the duration of the
second connection. */

static exim_gnutls_state_st state_server, state_client;
static exim_gnutls_state_st *current_global_tls_state;

/* dh_params are initialised once within the lifetime of a process using TLS;
if we used TLS in a long-lived daemon, we'd have to reconsider this.  But we
don't want to repeat this. */

static gnutls_dh_params_t dh_server_params = ((void *)0);

/* No idea how this value was chosen; preserving it.  Default is 3600. */

static const int ssl_session_timeout = 200;

static const char * const exim_default_gnutls_priority = "NORMAL";

/* Guard library core initialisation */

static BOOL exim_gnutls_base_init_done = 0;


/* ------------------------------------------------------------------------ */
/* macros */



/* Set this to control gnutls_global_set_log_level(); values 0 to 9 will setup
the library logging; a value less than 0 disables the calls to set up logging
callbacks. */
# 422 "src/tls-gnu.c"
/* With GnuTLS 2.12.x+ we have gnutls_sec_param_to_pk_bits() with which we
can ask for a bit-strength.  Without that, we stick to the constant we had
before, for now. */
# 443 "src/tls-gnu.c"
/* ------------------------------------------------------------------------ */
/* Callback declarations */





static int exim_sni_handling_cb(gnutls_session_t session);




/* ------------------------------------------------------------------------ */
/* Static functions */

/*************************************************
*               Handle TLS error                 *
*************************************************/

/* Called from lots of places when errors occur before actually starting to do
the TLS handshake, that is, while the session is still in clear. Always returns
DEFER for a server and FAIL for a client so that most calls can use "return
tls_error(...)" to do this processing and then give an appropriate return. A
single function is used for both server and client, because it is called from
some shared functions.

Argument:
  prefix    text to include in the logged error
  msg       additional error string (may be NULL)
            usually obtained from gnutls_strerror()
  host      NULL if setting up a server;
            the connected host if setting up a client

Returns:    OK/DEFER/FAIL
*/

static int
tls_error(const uschar *prefix, const char *msg, const host_item *host)
{
if (host)
  {
  log_write(0, 1, "TLS error on connection to %s [%s] (%s)%s%s",
      host->name, host->address, prefix, msg ? ": " : "", msg ? msg : "");
  return 2;
  }
else
  {
  uschar *conn_info = smtp_get_connection_info();
  if (strncmp((const char *)(conn_info),(const char *)((unsigned char *)"SMTP "),5) == 0)
    conn_info += 5;
  log_write(0, 1, "TLS error on %s (%s)%s%s",
      conn_info, prefix, msg ? ": " : "", msg ? msg : "");
  return 1;
  }
}




/*************************************************
*    Deal with logging errors during I/O         *
*************************************************/

/* We have to get the identity of the peer from saved data.

Argument:
  state    the current GnuTLS exim state container
  rc       the GnuTLS error code, or 0 if it's a local error
  when     text identifying read or write
  text     local error text when ec is 0

Returns:   nothing
*/

static void
record_io_error(exim_gnutls_state_st *state, int rc, uschar *when, uschar *text)
{
const char *msg;

if (rc == -12)
  msg = (char *) string_sprintf("%s: %s", (unsigned char *) gnutls_strerror(rc),
    (unsigned char *) gnutls_alert_get_name(gnutls_alert_get(state->session)));
else
  msg = gnutls_strerror(rc);

tls_error(when, msg, state->host);
}




/*************************************************
*        Set various Exim expansion vars         *
*************************************************/

/* We set various Exim global variables from the state, once a session has
been established.  With TLS callouts, may need to change this to stack
variables, or just re-call it with the server state after client callout
has finished.

Make sure anything set here is inset in tls_getc().

Sets:
  tls_active                fd
  tls_bits                  strength indicator
  tls_certificate_verified  bool indicator
  tls_channelbinding_b64    for some SASL mechanisms
  tls_cipher                a string
  tls_peerdn                a string
  tls_sni                   a (UTF-8) string
Also:
  current_global_tls_state  for API limitations

Argument:
  state      the relevant exim_gnutls_state_st *
*/

static void
extract_exim_vars_from_tls_state(exim_gnutls_state_st *state)
{
gnutls_cipher_algorithm_t cipher;

int old_pool;
int rc;
gnutls_datum_t channel;


current_global_tls_state = state;

tls_active = state->fd_out;

cipher = gnutls_cipher_get(state->session);
/* returns size in "bytes" */
tls_bits = gnutls_cipher_get_key_size(cipher) * 8;

tls_cipher = state->ciphersuite;

if ((debug_selector & (0x08000000)) != 0) debug_printf("cipher: %s\n", tls_cipher);

tls_certificate_verified = state->peer_cert_verified;

/* note that tls_channelbinding_b64 is not saved to the spool file, since it's
only available for use for authenticators while this TLS session is running. */

tls_channelbinding_b64 = ((void *)0);

channel.data = ((void *)0);
channel.size = 0;
rc = gnutls_session_channel_binding(state->session, GNUTLS_CB_TLS_UNIQUE, &channel);
if (rc) {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("Channel binding error: %s\n", gnutls_strerror(rc));
} else {
  old_pool = store_pool;
  store_pool = POOL_PERM;
  tls_channelbinding_b64 = auth_b64encode(channel.data, (int)channel.size);
  store_pool = old_pool;
  if ((debug_selector & (0x08000000)) != 0) debug_printf("Have channel bindings cached for possible auth usage.\n");
}


tls_peerdn = state->peerdn;

tls_sni = state->received_sni;
}




/*************************************************
*            Setup up DH parameters              *
*************************************************/

/* Generating the D-H parameters may take a long time. They only need to
be re-generated every so often, depending on security policy. What we do is to
keep these parameters in a file in the spool directory. If the file does not
exist, we generate them. This means that it is easy to cause a regeneration.

The new file is written as a temporary file and renamed, so that an incomplete
file is never present. If two processes both compute some new parameters, you
waste a bit of effort, but it doesn't seem worth messing around with locking to
prevent this.

Returns:     OK/DEFER/FAIL
*/

static int
init_server_dh(void)
{
int fd, rc;
unsigned int dh_bits;
gnutls_datum m;
uschar filename_buf[PATH_MAX];
uschar *filename = ((void *)0);
size_t sz;
uschar *exp_tls_dhparam;
BOOL use_file_in_spool = 0;
BOOL use_fixed_file = 0;
host_item *host = ((void *)0); /* dummy for macros */

if ((debug_selector & (0x08000000)) != 0) debug_printf("Initialising GnuTLS server params.\n");

rc = gnutls_dh_params_init(&dh_server_params);
do { if (rc != 0) { return tls_error(((unsigned char *)"gnutls_dh_params_init"), gnutls_strerror(rc), host); } } while (0);

m.data = ((void *)0);
m.size = 0;

if (!expand_check(tls_dhparam, (unsigned char *)"tls_dhparam", &exp_tls_dhparam))
  return 1;

if (!exp_tls_dhparam)
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("Loading default hard-coded DH params\n");
  m.data = (unsigned char *) std_dh_prime_default();
  m.size = (int)strlen((const char *)(m.data));
  }
else if (strcmp((const char *)(exp_tls_dhparam),(const char *)("historic")) == 0)
  use_file_in_spool = 1;
else if (strcmp((const char *)(exp_tls_dhparam),(const char *)("none")) == 0)
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("Requested no DH parameters.\n");
  return 0;
  }
else if (exp_tls_dhparam[0] != '/')
  {
  m.data = (unsigned char *) std_dh_prime_named(exp_tls_dhparam);
  if (m.data == ((void *)0))
    return tls_error((unsigned char *)"No standard prime named", (char *) exp_tls_dhparam, ((void *)0));
  m.size = (int)strlen((const char *)(m.data));
  }
else
  {
  use_fixed_file = 1;
  filename = exp_tls_dhparam;
  }

if (m.data)
  {
  rc = gnutls_dh_params_import_pkcs3(dh_server_params, &m, GNUTLS_X509_FMT_PEM);
  do { if (rc != 0) { return tls_error(((unsigned char *)"gnutls_dh_params_import_pkcs3"), gnutls_strerror(rc), host); } } while (0);
  if ((debug_selector & (0x08000000)) != 0) debug_printf("Loaded fixed standard D-H parameters\n");
  return 0;
  }


/* If you change this constant, also change dh_param_fn_ext so that we can use a
different filename and ensure we have sufficient bits. */
dh_bits = gnutls_sec_param_to_pk_bits(GNUTLS_PK_DH, GNUTLS_SEC_PARAM_NORMAL);
if (!dh_bits)
  return tls_error((unsigned char *)"gnutls_sec_param_to_pk_bits() failed", ((void *)0), ((void *)0));
if ((debug_selector & (0x08000000)) != 0)
  debug_printf("GnuTLS tells us that for D-H PK, NORMAL is %d bits.\n",
      dh_bits);







/* Some clients have hard-coded limits. */
if (dh_bits > tls_dh_max_bits)
  {
  if ((debug_selector & (0x08000000)) != 0)
    debug_printf("tls_dh_max_bits clamping override, using %d bits instead.\n",
        tls_dh_max_bits);
  dh_bits = tls_dh_max_bits;
  }

if (use_file_in_spool)
  {
  if (!string_format(filename_buf, sizeof(filename_buf),
        "%s/gnutls-params-%d", spool_directory, dh_bits))
    return tls_error((unsigned char *)"overlong filename", ((void *)0), ((void *)0));
  filename = filename_buf;
  }

/* Open the cache file for reading and if successful, read it and set up the
parameters. */

fd = open((const char *)(filename),O_RDONLY,0);
if (fd >= 0)
  {
  struct stat statbuf;
  FILE *fp;
  int saved_errno;

  if (fstat(fd, &statbuf) < 0) /* EIO */
    {
    saved_errno = errno;
    (void)close(fd);
    return tls_error((unsigned char *)"TLS cache stat failed", strerror(saved_errno), ((void *)0));
    }
  if (!S_ISREG(statbuf.st_mode))
    {
    (void)close(fd);
    return tls_error((unsigned char *)"TLS cache not a file", ((void *)0), ((void *)0));
    }
  fp = fdopen(fd, "rb");
  if (!fp)
    {
    saved_errno = errno;
    (void)close(fd);
    return tls_error((unsigned char *)"fdopen(TLS cache stat fd) failed",
        strerror(saved_errno), ((void *)0));
    }

  m.size = statbuf.st_size;
  m.data = malloc(m.size);
  if (m.data == ((void *)0))
    {
    fclose(fp);
    return tls_error((unsigned char *)"malloc failed", strerror(errno), ((void *)0));
    }
  sz = fread(m.data, m.size, 1, fp);
  if (!sz)
    {
    saved_errno = errno;
    fclose(fp);
    free(m.data);
    return tls_error((unsigned char *)"fread failed", strerror(saved_errno), ((void *)0));
    }
  fclose(fp);

  rc = gnutls_dh_params_import_pkcs3(dh_server_params, &m, GNUTLS_X509_FMT_PEM);
  free(m.data);
  do { if (rc != 0) { return tls_error(((unsigned char *)"gnutls_dh_params_import_pkcs3"), gnutls_strerror(rc), host); } } while (0);
  if ((debug_selector & (0x08000000)) != 0) debug_printf("read D-H parameters from file \"%s\"\n", filename);
  }

/* If the file does not exist, fall through to compute new data and cache it.
If there was any other opening error, it is serious. */

else if (errno == ENOENT)
  {
  rc = -1;
  if ((debug_selector & (0x08000000)) != 0)
    debug_printf("D-H parameter cache file \"%s\" does not exist\n", filename);
  }
else
  return tls_error(string_open_failed(errno, "\"%s\" for reading", filename),
      ((void *)0), ((void *)0));

/* If ret < 0, either the cache file does not exist, or the data it contains
is not useful. One particular case of this is when upgrading from an older
release of Exim in which the data was stored in a different format. We don't
try to be clever and support both formats; we just regenerate new data in this
case. */

if (rc < 0)
  {
  uschar *temp_fn;
  unsigned int dh_bits_gen = dh_bits;

  if ((PATH_MAX - (int)strlen((const char *)(filename))) < 10)
    return tls_error((unsigned char *)"Filename too long to generate replacement",
        (char *) filename, ((void *)0));

  temp_fn = string_copy((unsigned char *) "%s.XXXXXXX");
  fd = mkstemp((char *) temp_fn); /* modifies temp_fn */
  if (fd < 0)
    return tls_error((unsigned char *)"Unable to open temp file", strerror(errno), ((void *)0));
  (void)fchown(fd, exim_uid, exim_gid); /* Probably not necessary */

  /* GnuTLS overshoots!
   * If we ask for 2236, we might get 2237 or more.
   * But there's no way to ask GnuTLS how many bits there really are.
   * We can ask how many bits were used in a TLS session, but that's it!
   * The prime itself is hidden behind too much abstraction.
   * So we ask for less, and proceed on a wing and a prayer.
   * First attempt, subtracted 3 for 2233 and got 2240.
   */
  if (dh_bits >= 1024 + 10)
    {
    dh_bits_gen = dh_bits - 10;
    if ((debug_selector & (0x08000000)) != 0)
      debug_printf("being paranoid about DH generation, make it '%d' bits'\n",
          dh_bits_gen);
    }

  if ((debug_selector & (0x08000000)) != 0)
    debug_printf("requesting generation of %d bit Diffie-Hellman prime ...\n",
        dh_bits_gen);
  rc = gnutls_dh_params_generate2(dh_server_params, dh_bits_gen);
  do { if (rc != 0) { return tls_error(((unsigned char *)"gnutls_dh_params_generate2"), gnutls_strerror(rc), host); } } while (0);

  /* gnutls_dh_params_export_pkcs3() will tell us the exact size, every time,
  and I confirmed that a NULL call to get the size first is how the GnuTLS
  sample apps handle this. */

  sz = 0;
  m.data = ((void *)0);
  rc = gnutls_dh_params_export_pkcs3(dh_server_params, GNUTLS_X509_FMT_PEM,
      m.data, &sz);
  if (rc != -51)
    do { if (rc != 0) { return tls_error(((unsigned char *)"gnutls_dh_params_export_pkcs3(NULL) sizing"), gnutls_strerror(rc), host); } } while (0);
  m.size = sz;
  m.data = malloc(m.size);
  if (m.data == ((void *)0))
    return tls_error((unsigned char *)"memory allocation failed", strerror(errno), ((void *)0));
  /* this will return a size 1 less than the allocation size above */
  rc = gnutls_dh_params_export_pkcs3(dh_server_params, GNUTLS_X509_FMT_PEM,
      m.data, &sz);
  if (rc != 0)
    {
    free(m.data);
    do { if (rc != 0) { return tls_error(((unsigned char *)"gnutls_dh_params_export_pkcs3() real"), gnutls_strerror(rc), host); } } while (0);
    }
  m.size = sz; /* shrink by 1, probably */

  sz = write_to_fd_buf(fd, m.data, (size_t) m.size);
  if (sz != m.size)
    {
    free(m.data);
    return tls_error((unsigned char *)"TLS cache write D-H params failed",
        strerror(errno), ((void *)0));
    }
  free(m.data);
  sz = write_to_fd_buf(fd, (unsigned char *)"\n", 1);
  if (sz != 1)
    return tls_error((unsigned char *)"TLS cache write D-H params final newline failed",
        strerror(errno), ((void *)0));

  rc = close(fd);
  if (rc)
    return tls_error((unsigned char *)"TLS cache write close() failed",
        strerror(errno), ((void *)0));

  if (rename((const char *)(temp_fn),(const char *)(filename)) < 0)
    return tls_error(string_sprintf("failed to rename \"%s\" as \"%s\"",
          temp_fn, filename), strerror(errno), ((void *)0));

  if ((debug_selector & (0x08000000)) != 0) debug_printf("wrote D-H parameters to file \"%s\"\n", filename);
  }

if ((debug_selector & (0x08000000)) != 0) debug_printf("initialized server D-H parameters\n");
return 0;
}




/*************************************************
*       Variables re-expanded post-SNI           *
*************************************************/

/* Called from both server and client code, via tls_init(), and also from
the SNI callback after receiving an SNI, if tls_certificate includes "tls_sni".

We can tell the two apart by state->received_sni being non-NULL in callback.

The callback should not call us unless state->trigger_sni_changes is true,
which we are responsible for setting on the first pass through.

Arguments:
  state           exim_gnutls_state_st *

Returns:          OK/DEFER/FAIL
*/

static int
tls_expand_session_files(exim_gnutls_state_st *state)
{
struct stat statbuf;
int rc;
const host_item *host = state->host; /* macro should be reconsidered? */
uschar *saved_tls_certificate = ((void *)0);
uschar *saved_tls_privatekey = ((void *)0);
uschar *saved_tls_verify_certificates = ((void *)0);
uschar *saved_tls_crl = ((void *)0);
int cert_count;

/* We check for tls_sni *before* expansion. */
if (!state->host)
  {
  if (!state->received_sni)
    {
    if (state->tls_certificate && (unsigned char *) strstr((const char *)(state->tls_certificate),(const char *)((unsigned char *)"tls_sni")))
      {
      if ((debug_selector & (0x08000000)) != 0) debug_printf("We will re-expand TLS session files if we receive SNI.\n");
      state->trigger_sni_changes = 1;
      }
    }
  else
    {
    /* useful for debugging */
    saved_tls_certificate = state->exp_tls_certificate;
    saved_tls_privatekey = state->exp_tls_privatekey;
    saved_tls_verify_certificates = state->exp_tls_verify_certificates;
    saved_tls_crl = state->exp_tls_crl;
    }
  }

rc = gnutls_certificate_allocate_credentials(&state->x509_cred);
do { if (rc != 0) { return tls_error(((unsigned char *)"gnutls_certificate_allocate_credentials"), gnutls_strerror(rc), host); } } while (0);

/* remember: expand_check_tlsvar() is expand_check() but fiddling with
state members, assuming consistent naming; and expand_check() returns
false if expansion failed, unless expansion was forced to fail. */

/* check if we at least have a certificate, before doing expensive
D-H generation. */

if (!expand_check(state->tls_certificate, (unsigned char *) "tls_certificate", &state->exp_tls_certificate))
  return 1;

/* certificate is mandatory in server, optional in client */

if ((state->exp_tls_certificate == ((void *)0)) ||
    (*state->exp_tls_certificate == '\0'))
  {
  if (state->host == ((void *)0))
    return tls_error((unsigned char *)"no TLS server certificate is specified", ((void *)0), ((void *)0));
  else
    if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS: no client certificate specified; okay\n");
  }

if (state->tls_privatekey && !expand_check(state->tls_privatekey, (unsigned char *) "tls_privatekey", &state->exp_tls_privatekey))
  return 1;

/* tls_privatekey is optional, defaulting to same file as certificate */

if (state->tls_privatekey == ((void *)0) || *state->tls_privatekey == '\0')
  {
  state->tls_privatekey = state->tls_certificate;
  state->exp_tls_privatekey = state->exp_tls_certificate;
  }


if (state->exp_tls_certificate && *state->exp_tls_certificate)
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("certificate file = %s\nkey file = %s\n",
      state->exp_tls_certificate, state->exp_tls_privatekey);

  if (state->received_sni)
    {
    if ((strcmp((const char *)(state->exp_tls_certificate),(const char *)(saved_tls_certificate)) == 0) &&
        (strcmp((const char *)(state->exp_tls_privatekey),(const char *)(saved_tls_privatekey)) == 0))
      {
      if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS SNI: cert and key unchanged\n");
      }
    else
      {
      if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS SNI: have a changed cert/key pair.\n");
      }
    }

  rc = gnutls_certificate_set_x509_key_file(state->x509_cred,
      (char *) state->exp_tls_certificate, (char *) state->exp_tls_privatekey,
      GNUTLS_X509_FMT_PEM);
  do { if (rc != 0) { return tls_error((string_sprintf("cert/key setup: cert=%s key=%s", state->exp_tls_certificate, state->exp_tls_privatekey)), gnutls_strerror(rc), host); } } while (0)

                                                               ;
  if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS: cert/key registered\n");
  } /* tls_certificate */

/* Set the trusted CAs file if one is provided, and then add the CRL if one is
provided. Experiment shows that, if the certificate file is empty, an unhelpful
error message is provided. However, if we just refrain from setting anything up
in that case, certificate verification fails, which seems to be the correct
behaviour. */

if (state->tls_verify_certificates && *state->tls_verify_certificates)
  {
  if (!expand_check(state->tls_verify_certificates, (unsigned char *) "tls_verify_certificates", &state->exp_tls_verify_certificates))
    return 1;
  if (state->tls_crl && *state->tls_crl)
    if (!expand_check(state->tls_crl, (unsigned char *) "tls_crl", &state->exp_tls_crl))
      return 1;

  if (!(state->exp_tls_verify_certificates &&
        *state->exp_tls_verify_certificates))
    {
    if ((debug_selector & (0x08000000)) != 0)
      debug_printf("TLS: tls_verify_certificates expanded empty, ignoring\n");
    /* With no tls_verify_certificates, we ignore tls_crl too */
    return 0;
    }
  }
else
  {
  if ((debug_selector & (0x08000000)) != 0)
    debug_printf("TLS: tls_verify_certificates not set or empty, ignoring\n");
  return 0;
  }

if (stat((const char *)(state->exp_tls_verify_certificates),&statbuf) < 0)
  {
  log_write(0, 1|2, "could not stat %s "
      "(tls_verify_certificates): %s", state->exp_tls_verify_certificates,
      strerror(errno));
  return 1;
  }

/* The test suite passes in /dev/null; we could check for that path explicitly,
but who knows if someone has some weird FIFO which always dumps some certs, or
other weirdness.  The thing we really want to check is that it's not a
directory, since while OpenSSL supports that, GnuTLS does not.
So s/!S_ISREG/S_ISDIR/ and change some messsaging ... */
if (S_ISDIR(statbuf.st_mode))
  {
  if ((debug_selector & (0x08000000)) != 0)
    debug_printf("verify certificates path is a dir: \"%s\"\n",
        state->exp_tls_verify_certificates);
  log_write(0, 1|2,
      "tls_verify_certificates \"%s\" is a directory",
      state->exp_tls_verify_certificates);
  return 1;
  }

if ((debug_selector & (0x08000000)) != 0) debug_printf("verify certificates = %s size=" "%ld" "\n",
        state->exp_tls_verify_certificates, statbuf.st_size);

if (statbuf.st_size == 0)
  {
  if ((debug_selector & (0x08000000)) != 0)
    debug_printf("cert file empty, no certs, no verification, ignoring any CRL\n");
  return 0;
  }

cert_count = gnutls_certificate_set_x509_trust_file(state->x509_cred,
    (char *) state->exp_tls_verify_certificates, GNUTLS_X509_FMT_PEM);
if (cert_count < 0)
  {
  rc = cert_count;
  do { if (rc != 0) { return tls_error(((unsigned char *)"gnutls_certificate_set_x509_trust_file"), gnutls_strerror(rc), host); } } while (0);
  }
if ((debug_selector & (0x08000000)) != 0) debug_printf("Added %d certificate authorities.\n", cert_count);

if (state->tls_crl && *state->tls_crl &&
    state->exp_tls_crl && *state->exp_tls_crl)
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("loading CRL file = %s\n", state->exp_tls_crl);
  cert_count = gnutls_certificate_set_x509_crl_file(state->x509_cred,
      (char *) state->exp_tls_crl, GNUTLS_X509_FMT_PEM);
  if (cert_count < 0)
    {
    rc = cert_count;
    do { if (rc != 0) { return tls_error(((unsigned char *)"gnutls_certificate_set_x509_crl_file"), gnutls_strerror(rc), host); } } while (0);
    }
  if ((debug_selector & (0x08000000)) != 0) debug_printf("Processed %d CRLs.\n", cert_count);
  }

return 0;
}




/*************************************************
*          Set X.509 state variables             *
*************************************************/

/* In GnuTLS, the registered cert/key are not replaced by a later
set of a cert/key, so for SNI support we need a whole new x509_cred
structure.  Which means various other non-re-expanded pieces of state
need to be re-set in the new struct, so the setting logic is pulled
out to this.

Arguments:
  state           exim_gnutls_state_st *

Returns:          OK/DEFER/FAIL
*/

static int
tls_set_remaining_x509(exim_gnutls_state_st *state)
{
int rc;
const host_item *host = state->host; /* macro should be reconsidered? */

/* Create D-H parameters, or read them from the cache file. This function does
its own SMTP error messaging. This only happens for the server, TLS D-H ignores
client-side params. */

if (!state->host)
  {
  if (!dh_server_params)
    {
    rc = init_server_dh();
    if (rc != 0) return rc;
    }
  gnutls_certificate_set_dh_params(state->x509_cred, dh_server_params);
  }

/* Link the credentials to the session. */

rc = gnutls_credentials_set(state->session, GNUTLS_CRD_CERTIFICATE, state->x509_cred);
do { if (rc != 0) { return tls_error(((unsigned char *)"gnutls_credentials_set"), gnutls_strerror(rc), host); } } while (0);

return 0;
}

/*************************************************
*            Initialize for GnuTLS               *
*************************************************/

/* Called from both server and client code. In the case of a server, errors
before actual TLS negotiation return DEFER.

Arguments:
  host            connected host, if client; NULL if server
  certificate     certificate file
  privatekey      private key file
  sni             TLS SNI to send, sometimes when client; else NULL
  cas             CA certs file
  crl             CRL file
  require_ciphers tls_require_ciphers setting

Returns:          OK/DEFER/FAIL
*/

static int
tls_init(
    const host_item *host,
    const uschar *certificate,
    const uschar *privatekey,
    const uschar *sni,
    const uschar *cas,
    const uschar *crl,
    const uschar *require_ciphers,
    exim_gnutls_state_st **caller_state)
{
exim_gnutls_state_st *state;
int rc;
size_t sz;
const char *errpos;
uschar *p;
BOOL want_default_priorities;

if (!exim_gnutls_base_init_done)
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("GnuTLS global init required.\n");

  rc = gnutls_global_init();
  do { if (rc != 0) { return tls_error(((unsigned char *)"gnutls_global_init"), gnutls_strerror(rc), host); } } while (0);
# 1189 "src/tls-gnu.c"
  exim_gnutls_base_init_done = 1;
  }

if (host)
  {
  state = &state_client;
  memcpy(state, &exim_gnutls_state_init, sizeof(exim_gnutls_state_init));
  if ((debug_selector & (0x08000000)) != 0) debug_printf("initialising GnuTLS client session\n");
  rc = gnutls_init(&state->session, (1<<1));
  }
else
  {
  state = &state_server;
  memcpy(state, &exim_gnutls_state_init, sizeof(exim_gnutls_state_init));
  if ((debug_selector & (0x08000000)) != 0) debug_printf("initialising GnuTLS server session\n");
  rc = gnutls_init(&state->session, 1);
  }
do { if (rc != 0) { return tls_error(((unsigned char *)"gnutls_init"), gnutls_strerror(rc), host); } } while (0);

state->host = host;

state->tls_certificate = certificate;
state->tls_privatekey = privatekey;
state->tls_require_ciphers = require_ciphers;
state->tls_sni = sni;
state->tls_verify_certificates = cas;
state->tls_crl = crl;

/* This handles the variables that might get re-expanded after TLS SNI;
that's tls_certificate, tls_privatekey, tls_verify_certificates, tls_crl */

if ((debug_selector & (0x08000000)) != 0)
  debug_printf("Expanding various TLS configuration options for session credentials.\n");
rc = tls_expand_session_files(state);
if (rc != 0) return rc;

/* These are all other parts of the x509_cred handling, since SNI in GnuTLS
requires a new structure afterwards. */

rc = tls_set_remaining_x509(state);
if (rc != 0) return rc;

/* set SNI in client, only */
if (host)
  {
  if (!expand_check(state->tls_sni, (unsigned char *) "tls_sni", &state->exp_tls_sni))
    return 1;
  if (state->exp_tls_sni && *state->exp_tls_sni)
    {
    if ((debug_selector & (0x08000000)) != 0)
      debug_printf("Setting TLS client SNI to \"%s\"\n", state->exp_tls_sni);
    sz = (int)strlen((const char *)(state->exp_tls_sni));
    rc = gnutls_server_name_set(state->session,
        GNUTLS_NAME_DNS, state->exp_tls_sni, sz);
    do { if (rc != 0) { return tls_error(((unsigned char *)"gnutls_server_name_set"), gnutls_strerror(rc), host); } } while (0);
    }
  }
else if (state->tls_sni)
  if ((debug_selector & (0x08000000)) != 0) debug_printf("*** PROBABLY A BUG *** "
      "have an SNI set for a client [%s]\n", state->tls_sni);

/* This is the priority string support,
http://www.gnu.org/software/gnutls/manual/html_node/Priority-Strings.html
and replaces gnutls_require_kx, gnutls_require_mac & gnutls_require_protocols.
This was backwards incompatible, but means Exim no longer needs to track
all algorithms and provide string forms for them. */

want_default_priorities = 1;

if (state->tls_require_ciphers && *state->tls_require_ciphers)
  {
  if (!expand_check(state->tls_require_ciphers, (unsigned char *) "tls_require_ciphers", &state->exp_tls_require_ciphers))
    return 1;
  if (state->exp_tls_require_ciphers && *state->exp_tls_require_ciphers)
    {
    if ((debug_selector & (0x08000000)) != 0) debug_printf("GnuTLS session cipher/priority \"%s\"\n",
        state->exp_tls_require_ciphers);

    rc = gnutls_priority_init(&state->priority_cache,
        (char *) state->exp_tls_require_ciphers, &errpos);
    want_default_priorities = 0;
    p = state->exp_tls_require_ciphers;
    }
  }
if (want_default_priorities)
  {
  if ((debug_selector & (0x08000000)) != 0)
    debug_printf("GnuTLS using default session cipher/priority \"%s\"\n",
        exim_default_gnutls_priority);
  rc = gnutls_priority_init(&state->priority_cache,
      exim_default_gnutls_priority, &errpos);
  p = (unsigned char *) exim_default_gnutls_priority;
  }

do { if (rc != 0) { return tls_error((string_sprintf( "gnutls_priority_init(%s) failed at offset %ld, \"%.6s..\"", p, errpos - (char *) p, errpos)), gnutls_strerror(rc), host); } } while (0)

                                ;

rc = gnutls_priority_set(state->session, state->priority_cache);
do { if (rc != 0) { return tls_error(((unsigned char *)"gnutls_priority_set"), gnutls_strerror(rc), host); } } while (0);

gnutls_db_set_cache_expiration(state->session, ssl_session_timeout);

/* Reduce security in favour of increased compatibility, if the admin
decides to make that trade-off. */
if (gnutls_compat_mode)
  {

  if ((debug_selector & (0x08000000)) != 0) debug_printf("lowering GnuTLS security, compatibility mode\n");
  gnutls_session_enable_compatibility_mode(state->session);



  }

*caller_state = state;
/* needs to happen before callbacks during handshake */
current_global_tls_state = state;
return 0;
}




/*************************************************
*            Extract peer information            *
*************************************************/

/* Called from both server and client code.
Only this is allowed to set state->peerdn and state->have_set_peerdn
and we use that to detect double-calls.

NOTE: the state blocks last while the TLS connection is up, which is fine
for logging in the server side, but for the client side, we log after teardown
in src/deliver.c.  While the session is up, we can twist about states and
repoint tls_* globals, but those variables used for logging or other variable
expansion that happens _after_ delivery need to have a longer life-time.

So for those, we get the data from POOL_PERM; the re-invoke guard keeps us from
doing this more than once per generation of a state context.  We set them in
the state context, and repoint tls_* to them.  After the state goes away, the
tls_* copies of the pointers remain valid and client delivery logging is happy.

tls_certificate_verified is a BOOL, so the tls_peerdn and tls_cipher issues
don't apply.

Arguments:
  state           exim_gnutls_state_st *

Returns:          OK/DEFER/FAIL
*/

static int
peer_status(exim_gnutls_state_st *state)
{
uschar cipherbuf[256];
const gnutls_datum *cert_list;
int old_pool, rc;
unsigned int cert_list_size = 0;
gnutls_protocol_t protocol;
gnutls_cipher_algorithm_t cipher;
gnutls_kx_algorithm_t kx;
gnutls_mac_algorithm_t mac;
gnutls_certificate_type_t ct;
gnutls_x509_crt_t crt;
uschar *p, *dn_buf;
size_t sz;

if (state->have_set_peerdn)
  return 0;
state->have_set_peerdn = 1;

state->peerdn = ((void *)0);

/* tls_cipher */
cipher = gnutls_cipher_get(state->session);
protocol = gnutls_protocol_get_version(state->session);
mac = gnutls_mac_get(state->session);
kx = gnutls_kx_get(state->session);

string_format(cipherbuf, sizeof(cipherbuf),
    "%s:%s:%d",
    gnutls_protocol_get_name(protocol),
    gnutls_cipher_suite_get_name(kx, cipher, mac),
    (int) gnutls_cipher_get_key_size(cipher) * 8);

/* I don't see a way that spaces could occur, in the current GnuTLS
code base, but it was a concern in the old code and perhaps older GnuTLS
releases did return "TLS 1.0"; play it safe, just in case. */
for (p = cipherbuf; *p != '\0'; ++p)
  if (isspace(*p))
    *p = '-';
old_pool = store_pool;
store_pool = POOL_PERM;
state->ciphersuite = string_copy(cipherbuf);
store_pool = old_pool;
tls_cipher = state->ciphersuite;

/* tls_peerdn */
cert_list = gnutls_certificate_get_peers(state->session, &cert_list_size);

if (cert_list == ((void *)0) || cert_list_size == 0)
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS: no certificate from peer (%p & %d)\n",
      cert_list, cert_list_size);
  if (state->verify_requirement == VERIFY_REQUIRED)
    return tls_error((unsigned char *)"certificate verification failed",
        "no certificate received from peer", state->host);
  return 0;
  }

ct = gnutls_certificate_type_get(state->session);
if (ct != GNUTLS_CRT_X509)
  {
  const char *ctn = gnutls_certificate_type_get_name(ct);
  if ((debug_selector & (0x08000000)) != 0)
    debug_printf("TLS: peer cert not X.509 but instead \"%s\"\n", ctn);
  if (state->verify_requirement == VERIFY_REQUIRED)
    return tls_error((unsigned char *)"certificate verification not possible, unhandled type",
        ctn, state->host);
  return 0;
  }







rc = gnutls_x509_crt_init(&crt);
do { if (rc != 0) { if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS: peer cert problem: %s: %s\n", ((unsigned char *)"gnutls_x509_crt_init (crt)"), gnutls_strerror(rc)); if (state->verify_requirement == VERIFY_REQUIRED) { return tls_error(((unsigned char *)"gnutls_x509_crt_init (crt)"), gnutls_strerror(rc), state->host); } return 0; } } while (0);

rc = gnutls_x509_crt_import(crt, &cert_list[0], GNUTLS_X509_FMT_DER);
do { if (rc != 0) { if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS: peer cert problem: %s: %s\n", ((unsigned char *)"failed to import certificate [gnutls_x509_crt_import(cert 0)]"), gnutls_strerror(rc)); if (state->verify_requirement == VERIFY_REQUIRED) { return tls_error(((unsigned char *)"failed to import certificate [gnutls_x509_crt_import(cert 0)]"), gnutls_strerror(rc), state->host); } return 0; } } while (0);
sz = 0;
rc = gnutls_x509_crt_get_dn(crt, ((void *)0), &sz);
if (rc != -51)
  {
  do { if (rc != 0) { if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS: peer cert problem: %s: %s\n", ((unsigned char *)"getting size for cert DN failed"), gnutls_strerror(rc)); if (state->verify_requirement == VERIFY_REQUIRED) { return tls_error(((unsigned char *)"getting size for cert DN failed"), gnutls_strerror(rc), state->host); } return 0; } } while (0);
  return 2; /* should not happen */
  }
dn_buf = store_get_perm_3(sz, "src/tls-gnu.c", 1430);
rc = gnutls_x509_crt_get_dn(crt, (char *) dn_buf, &sz);
do { if (rc != 0) { if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS: peer cert problem: %s: %s\n", ((unsigned char *)"failed to extract certificate DN [gnutls_x509_crt_get_dn(cert 0)]"), gnutls_strerror(rc)); if (state->verify_requirement == VERIFY_REQUIRED) { return tls_error(((unsigned char *)"failed to extract certificate DN [gnutls_x509_crt_get_dn(cert 0)]"), gnutls_strerror(rc), state->host); } return 0; } } while (0);
state->peerdn = dn_buf;

return 0;

}




/*************************************************
*            Verify peer certificate             *
*************************************************/

/* Called from both server and client code.
*Should* be using a callback registered with
gnutls_certificate_set_verify_function() to fail the handshake if we dislike
the peer information, but that's too new for some OSes.

Arguments:
  state           exim_gnutls_state_st *
  error           where to put an error message

Returns:
  FALSE     if the session should be rejected
  TRUE      if the cert is okay or we just don't care
*/

static BOOL
verify_certificate(exim_gnutls_state_st *state, const char **error)
{
int rc;
unsigned int verify;

*error = ((void *)0);

rc = peer_status(state);
if (rc != 0)
  {
  verify = GNUTLS_CERT_INVALID;
  *error = "not supplied";
  }
else
  {
  rc = gnutls_certificate_verify_peers2(state->session, &verify);
  }

/* Handle the result of verification. INVALID seems to be set as well
as REVOKED, but leave the test for both. */

if ((rc < 0) || (verify & (GNUTLS_CERT_INVALID|GNUTLS_CERT_REVOKED)) != 0)
  {
  state->peer_cert_verified = 0;
  if (*error == ((void *)0))
    *error = ((verify & GNUTLS_CERT_REVOKED) != 0) ? "revoked" : "invalid";

  if ((debug_selector & (0x08000000)) != 0)
    debug_printf("TLS certificate verification failed (%s): peerdn=%s\n",
        *error, state->peerdn ? state->peerdn : (unsigned char *)"<unset>");

  if (state->verify_requirement == VERIFY_REQUIRED)
    {
    gnutls_alert_send(state->session, GNUTLS_AL_FATAL, GNUTLS_A_BAD_CERTIFICATE);
    return 0;
    }
  if ((debug_selector & (0x08000000)) != 0)
    debug_printf("TLS verify failure overridden (host in tls_try_verify_hosts)\n");
  }
else
  {
  state->peer_cert_verified = 1;
  if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS certificate verified: peerdn=%s\n",
      state->peerdn ? state->peerdn : (unsigned char *)"<unset>");
  }

tls_peerdn = state->peerdn;

return 1;
}




/* ------------------------------------------------------------------------ */
/* Callbacks */

/* Logging function which can be registered with
 *   gnutls_global_set_log_function()
 *   gnutls_global_set_log_level() 0..9
 */
# 1538 "src/tls-gnu.c"
/* Called after client hello, should handle SNI work.
This will always set tls_sni (state->received_sni) if available,
and may trigger presenting different certificates,
if state->trigger_sni_changes is TRUE.

Should be registered with
  gnutls_handshake_set_post_client_hello_function()

"This callback must return 0 on success or a gnutls error code to terminate the
handshake.".

For inability to get SNI information, we return 0.
We only return non-zero if re-setup failed.
*/

static int
exim_sni_handling_cb(gnutls_session_t session)
{
char sni_name[255];
size_t data_len = 255;
exim_gnutls_state_st *state = current_global_tls_state;
unsigned int sni_type;
int rc, old_pool;

rc = gnutls_server_name_get(session, sni_name, &data_len, &sni_type, 0);
if (rc != 0)
  {
  if ((debug_selector & (0x08000000)) != 0) {
    if (rc == -56)
      debug_printf("TLS: no SNI presented in handshake.\n");
    else
      debug_printf("TLS failure: gnutls_server_name_get(): %s [%d]\n",
        gnutls_strerror(rc), rc);
  };
  return 0;
  }

if (sni_type != GNUTLS_NAME_DNS)
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS: ignoring SNI of unhandled type %u\n", sni_type);
  return 0;
  }

/* We now have a UTF-8 string in sni_name */
old_pool = store_pool;
store_pool = POOL_PERM;
state->received_sni = string_copyn((unsigned char *) sni_name, data_len);
store_pool = old_pool;

/* We set this one now so that variable expansions below will work */
tls_sni = state->received_sni;

if ((debug_selector & (0x08000000)) != 0) debug_printf("Received TLS SNI \"%s\"%s\n", sni_name,
    state->trigger_sni_changes ? "" : " (unused for certificate selection)");

if (!state->trigger_sni_changes)
  return 0;

rc = tls_expand_session_files(state);
if (rc != 0)
  {
  /* If the setup of certs/etc failed before handshake, TLS would not have
  been offered.  The best we can do now is abort. */
  return -65500;
  }

rc = tls_set_remaining_x509(state);
if (rc != 0) return -65500;

return 0;
}




/* ------------------------------------------------------------------------ */
/* Exported functions */




/*************************************************
*       Start a TLS session in a server          *
*************************************************/

/* This is called when Exim is running as a server, after having received
the STARTTLS command. It must respond to that command, and then negotiate
a TLS session.

Arguments:
  require_ciphers  list of allowed ciphers or NULL

Returns:           OK on success
                   DEFER for errors before the start of the negotiation
                   FAIL for errors during the negotation; the server can't
                     continue running.
*/

int
tls_server_start(const uschar *require_ciphers)
{
int rc;
const char *error;
exim_gnutls_state_st *state = ((void *)0);

/* Check for previous activation */
/* nb: this will not be TLS callout safe, needs reworking as part of that. */

if (tls_active >= 0)
  {
  tls_error((unsigned char *)"STARTTLS received after TLS started", "", ((void *)0));
  smtp_printf("554 Already in TLS\r\n");
  return 2;
  }

/* Initialize the library. If it fails, it will already have logged the error
and sent an SMTP response. */

if ((debug_selector & (0x08000000)) != 0) debug_printf("initialising GnuTLS as a server\n");

rc = tls_init(((void *)0), tls_certificate, tls_privatekey,
    ((void *)0), tls_verify_certificates, tls_crl,
    require_ciphers, &state);
if (rc != 0) return rc;

/* If this is a host for which certificate verification is mandatory or
optional, set up appropriately. */

if (verify_check_host(&tls_verify_hosts) == 0)
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS: a client certificate will be required.\n");
  state->verify_requirement = VERIFY_REQUIRED;
  gnutls_certificate_server_set_request(state->session, GNUTLS_CERT_REQUIRE);
  }
else if (verify_check_host(&tls_try_verify_hosts) == 0)
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS: a client certificate will be requested but not required.\n");
  state->verify_requirement = VERIFY_OPTIONAL;
  gnutls_certificate_server_set_request(state->session, GNUTLS_CERT_REQUEST);
  }
else
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS: a client certificate will not be requested.\n");
  state->verify_requirement = VERIFY_NONE;
  gnutls_certificate_server_set_request(state->session, GNUTLS_CERT_IGNORE);
  }

/* Register SNI handling; always, even if not in tls_certificate, so that the
expansion variable $tls_sni is always available. */

gnutls_handshake_set_post_client_hello_function(state->session,
    exim_sni_handling_cb);

/* Set context and tell client to go ahead, except in the case of TLS startup
on connection, where outputting anything now upsets the clients and tends to
make them disconnect. We need to have an explicit fflush() here, to force out
the response. Other smtp_printf() calls do not need it, because in non-TLS
mode, the fflush() happens when smtp_getc() is called. */

if (!tls_on_connect)
  {
  smtp_printf("220 TLS go ahead\r\n");
  fflush(smtp_out);
  }

/* Now negotiate the TLS session. We put our own timer on it, since it seems
that the GnuTLS library doesn't. */

gnutls_transport_set_ptr2(state->session,
    (gnutls_transport_ptr)fileno(smtp_in),
    (gnutls_transport_ptr)fileno(smtp_out));
state->fd_in = fileno(smtp_in);
state->fd_out = fileno(smtp_out);

sigalrm_seen = 0;
if (smtp_receive_timeout > 0) alarm(smtp_receive_timeout);
do
  {
  rc = gnutls_handshake(state->session);
  } while ((rc == -28) ||
      (rc == -52 && !sigalrm_seen));
alarm(0);

if (rc != 0)
  {
  tls_error((unsigned char *)"gnutls_handshake",
      sigalrm_seen ? "timed out" : gnutls_strerror(rc), ((void *)0));
  /* It seems that, except in the case of a timeout, we have to close the
  connection right here; otherwise if the other end is running OpenSSL it hangs
  until the server times out. */

  if (!sigalrm_seen)
    {
    (void)fclose(smtp_out);
    (void)fclose(smtp_in);
    }

  return 2;
  }

if ((debug_selector & (0x08000000)) != 0) debug_printf("gnutls_handshake was successful\n");

/* Verify after the fact */

if (state->verify_requirement != VERIFY_NONE)
  {
  if (!verify_certificate(state, &error))
    {
    if (state->verify_requirement == VERIFY_OPTIONAL)
      {
      if ((debug_selector & (0x08000000)) != 0)
        debug_printf("TLS: continuing on only because verification was optional, after: %s\n",
            error);
      }
    else
      {
      tls_error((unsigned char *)"certificate verification failed", error, ((void *)0));
      return 2;
      }
    }
  }

/* Figure out peer DN, and if authenticated, etc. */

rc = peer_status(state);
if (rc != 0) return rc;

/* Sets various Exim expansion variables; always safe within server */

extract_exim_vars_from_tls_state(state);

/* TLS has been set up. Adjust the input functions to read via TLS,
and initialize appropriately. */

state->xfer_buffer = store_malloc_3(ssl_xfer_buffer_size, "src/tls-gnu.c", 1772);

receive_getc = tls_getc;
receive_ungetc = tls_ungetc;
receive_feof = tls_feof;
receive_ferror = tls_ferror;
receive_smtp_buffered = tls_smtp_buffered;

return 0;
}




/*************************************************
*    Start a TLS session in a client             *
*************************************************/

/* Called from the smtp transport after STARTTLS has been accepted.

Arguments:
  fd                the fd of the connection
  host              connected host (for messages)
  addr              the first address (not used)
  dhparam           DH parameter file (ignored, we're a client)
  certificate       certificate file
  privatekey        private key file
  sni               TLS SNI to send to remote host
  verify_certs      file for certificate verify
  verify_crl        CRL for verify
  require_ciphers   list of allowed ciphers or NULL
  timeout           startup timeout

Returns:            OK/DEFER/FAIL (because using common functions),
                    but for a client, DEFER and FAIL have the same meaning
*/

int
tls_client_start(int fd, host_item *host,
    address_item *addr __attribute__((__unused__)), uschar *dhparam __attribute__((__unused__)),
    uschar *certificate, uschar *privatekey, uschar *sni,
    uschar *verify_certs, uschar *verify_crl,
    uschar *require_ciphers, int timeout)
{
int rc;
const char *error;
exim_gnutls_state_st *state = ((void *)0);

if ((debug_selector & (0x08000000)) != 0) debug_printf("initialising GnuTLS as a client on fd %d\n", fd);

rc = tls_init(host, certificate, privatekey,
    sni, verify_certs, verify_crl, require_ciphers, &state);
if (rc != 0) return rc;

gnutls_dh_set_prime_bits(state->session, 1024);

if (verify_certs == ((void *)0))
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS: server certificate verification not required\n");
  state->verify_requirement = VERIFY_NONE;
  /* we still ask for it, to log it, etc */
  gnutls_certificate_server_set_request(state->session, GNUTLS_CERT_REQUEST);
  }
else
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("TLS: server certificate verification required\n");
  state->verify_requirement = VERIFY_REQUIRED;
  gnutls_certificate_server_set_request(state->session, GNUTLS_CERT_REQUIRE);
  }

gnutls_transport_set_ptr(state->session, (gnutls_transport_ptr)fd);
state->fd_in = fd;
state->fd_out = fd;

/* There doesn't seem to be a built-in timeout on connection. */

sigalrm_seen = 0;
alarm(timeout);
do
  {
  rc = gnutls_handshake(state->session);
  } while ((rc == -28) ||
      (rc == -52 && !sigalrm_seen));
alarm(0);

if (rc != 0)
  return tls_error((unsigned char *)"gnutls_handshake",
      sigalrm_seen ? "timed out" : gnutls_strerror(rc), state->host);

if ((debug_selector & (0x08000000)) != 0) debug_printf("gnutls_handshake was successful\n");

/* Verify late */

if (state->verify_requirement != VERIFY_NONE &&
    !verify_certificate(state, &error))
  return tls_error((unsigned char *)"certificate verification failed", error, state->host);

/* Figure out peer DN, and if authenticated, etc. */

rc = peer_status(state);
if (rc != 0) return rc;

/* Sets various Exim expansion variables; may need to adjust for ACL callouts */

extract_exim_vars_from_tls_state(state);

return 0;
}




/*************************************************
*         Close down a TLS session               *
*************************************************/

/* This is also called from within a delivery subprocess forked from the
daemon, to shut down the TLS library, without actually doing a shutdown (which
would tamper with the TLS session in the parent process).

Arguments:   TRUE if gnutls_bye is to be called
Returns:     nothing
*/

void
tls_close(BOOL shutdown)
{
exim_gnutls_state_st *state = current_global_tls_state;

if (tls_active < 0) return; /* TLS was not active */

if (shutdown)
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("tls_close(): shutting down TLS\n");
  gnutls_bye(state->session, GNUTLS_SHUT_WR);
  }

gnutls_deinit(state->session);

memcpy(state, &exim_gnutls_state_init, sizeof(exim_gnutls_state_init));

if ((state_server.session == ((void *)0)) && (state_client.session == ((void *)0)))
  {
  gnutls_global_deinit();
  exim_gnutls_base_init_done = 0;
  }

tls_active = -1;
}




/*************************************************
*            TLS version of getc                 *
*************************************************/

/* This gets the next byte from the TLS input buffer. If the buffer is empty,
it refills the buffer via the GnuTLS reading function.

This feeds DKIM and should be used for all message-body reads.

Arguments:  none
Returns:    the next character or EOF
*/

int
tls_getc(void)
{
exim_gnutls_state_st *state = current_global_tls_state;
if (state->xfer_buffer_lwm >= state->xfer_buffer_hwm)
  {
  ssize_t inbytes;

  if ((debug_selector & (0x08000000)) != 0) debug_printf("Calling gnutls_record_recv(%p, %p, %u)\n",
    state->session, state->xfer_buffer, ssl_xfer_buffer_size);

  if (smtp_receive_timeout > 0) alarm(smtp_receive_timeout);
  inbytes = gnutls_record_recv(state->session, state->xfer_buffer,
    ssl_xfer_buffer_size);
  alarm(0);

  /* A zero-byte return appears to mean that the TLS session has been
     closed down, not that the socket itself has been closed down. Revert to
     non-TLS handling. */

  if (inbytes == 0)
    {
    if ((debug_selector & (0x08000000)) != 0) debug_printf("Got TLS_EOF\n");

    receive_getc = smtp_getc;
    receive_ungetc = smtp_ungetc;
    receive_feof = smtp_feof;
    receive_ferror = smtp_ferror;
    receive_smtp_buffered = smtp_buffered;

    gnutls_deinit(state->session);
    state->session = ((void *)0);
    tls_active = -1;
    tls_bits = 0;
    tls_certificate_verified = 0;
    tls_channelbinding_b64 = ((void *)0);
    tls_cipher = ((void *)0);
    tls_peerdn = ((void *)0);

    return smtp_getc();
    }

  /* Handle genuine errors */

  else if (inbytes < 0)
    {
    record_io_error(state, (int) inbytes, (unsigned char *)"recv", ((void *)0));
    state->xfer_error = 1;
    return (-1);
    }

  dkim_exim_verify_feed(state->xfer_buffer, inbytes);

  state->xfer_buffer_hwm = (int) inbytes;
  state->xfer_buffer_lwm = 0;
  }

/* Something in the buffer; return next uschar */

return state->xfer_buffer[state->xfer_buffer_lwm++];
}




/*************************************************
*          Read bytes from TLS channel           *
*************************************************/

/* This does not feed DKIM, so if the caller uses this for reading message body,
then the caller must feed DKIM.
Arguments:
  buff      buffer of data
  len       size of buffer

Returns:    the number of bytes read
            -1 after a failed read
*/

int
tls_read(uschar *buff, size_t len)
{
exim_gnutls_state_st *state = current_global_tls_state;
ssize_t inbytes;

if (len > INT_MAX)
  len = INT_MAX;

if (state->xfer_buffer_lwm < state->xfer_buffer_hwm)
  if ((debug_selector & (0x08000000)) != 0)
    debug_printf("*** PROBABLY A BUG *** "
        "tls_read() called with data in the tls_getc() buffer, %d ignored\n",
        state->xfer_buffer_hwm - state->xfer_buffer_lwm);

if ((debug_selector & (0x08000000)) != 0)
  debug_printf("Calling gnutls_record_recv(%p, %p, " "%lu" ")\n",
      state->session, buff, len);

inbytes = gnutls_record_recv(state->session, buff, len);
if (inbytes > 0) return inbytes;
if (inbytes == 0)
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("Got TLS_EOF\n");
  }
else record_io_error(state, (int)inbytes, (unsigned char *)"recv", ((void *)0));

return -1;
}




/*************************************************
*         Write bytes down TLS channel           *
*************************************************/

/*
Arguments:
  buff      buffer of data
  len       number of bytes

Returns:    the number of bytes after a successful write,
            -1 after a failed write
*/

int
tls_write(const uschar *buff, size_t len)
{
ssize_t outbytes;
size_t left = len;
exim_gnutls_state_st *state = current_global_tls_state;

if ((debug_selector & (0x08000000)) != 0) debug_printf("tls_do_write(%p, " "%lu" ")\n", buff, left);
while (left > 0)
  {
  if ((debug_selector & (0x08000000)) != 0) debug_printf("gnutls_record_send(SSL, %p, " "%lu" ")\n",
      buff, left);
  outbytes = gnutls_record_send(state->session, buff, left);

  if ((debug_selector & (0x08000000)) != 0) debug_printf("outbytes=" "%ld" "\n", outbytes);
  if (outbytes < 0)
    {
    record_io_error(state, outbytes, (unsigned char *)"send", ((void *)0));
    return -1;
    }
  if (outbytes == 0)
    {
    record_io_error(state, 0, (unsigned char *)"send", (unsigned char *)"TLS channel closed on write");
    return -1;
    }

  left -= outbytes;
  buff += outbytes;
  }

if (len > INT_MAX)
  {
  if ((debug_selector & (0x08000000)) != 0)
    debug_printf("Whoops!  Wrote more bytes (" "%lu" ") than INT_MAX\n",
        len);
  len = INT_MAX;
  }

return (int) len;
}




/*************************************************
*            Random number generation            *
*************************************************/

/* Pseudo-random number generation.  The result is not expected to be
cryptographically strong but not so weak that someone will shoot themselves
in the foot using it as a nonce in input in some email header scheme or
whatever weirdness they'll twist this into.  The result should handle fork()
and avoid repeating sequences.  OpenSSL handles that for us.

Arguments:
  max       range maximum
Returns     a random number in range [0, max-1]
*/


int
vaguely_random_number(int max)
{
unsigned int r;
int i, needed_len;
uschar *p;
uschar smallbuf[sizeof(r)];

if (max <= 1)
  return 0;

needed_len = sizeof(r);
/* Don't take 8 times more entropy than needed if int is 8 octets and we were
 * asked for a number less than 10. */
for (r = max, i = 0; r; ++i)
  r >>= 1;
i = (i + 7) / 8;
if (i < needed_len)
  needed_len = i;

i = gnutls_rnd(GNUTLS_RND_NONCE, smallbuf, needed_len);
if (i < 0)
  {
  if ((debug_selector & (0xffffffff)) != 0) debug_printf("gnutls_rnd() failed, using fallback.\n");
  return vaguely_random_number_fallback(max);
  }
r = 0;
for (p = smallbuf; needed_len; --needed_len, ++p)
  {
  r *= 256;
  r += *p;
  }

/* We don't particularly care about weighted results; if someone wants
 * smooth distribution and cares enough then they should submit a patch then. */
return r % max;
}
# 2171 "src/tls-gnu.c"
/*************************************************
*  Let tls_require_ciphers be checked at startup *
*************************************************/

/* The tls_require_ciphers option, if set, must be something which the
library can parse.

Returns:     NULL on success, or error message
*/

uschar *
tls_validate_require_cipher(void)
{
int rc;
uschar *expciphers = ((void *)0);
gnutls_priority_t priority_cache;
const char *errpos;






if (exim_gnutls_base_init_done)
  log_write(0, 1|2,
      "already initialised GnuTLS, Exim developer bug");

rc = gnutls_global_init();
do { if (rc != 0) { if (exim_gnutls_base_init_done) gnutls_global_deinit(); return string_sprintf("%s failed: %s", ((unsigned char *)"gnutls_global_init()"), gnutls_strerror(rc)); } } while (0);
exim_gnutls_base_init_done = 1;

if (!(tls_require_ciphers && *tls_require_ciphers))
  do { gnutls_global_deinit(); return (((void *)0)); } while (0);

if (!expand_check(tls_require_ciphers, (unsigned char *)"tls_require_ciphers", &expciphers))
  do { gnutls_global_deinit(); return ((unsigned char *)"failed to expand tls_require_ciphers"); } while (0);

if (!(expciphers && *expciphers))
  do { gnutls_global_deinit(); return (((void *)0)); } while (0);

if ((debug_selector & (0x08000000)) != 0)
  debug_printf("tls_require_ciphers expands to \"%s\"\n", expciphers);

rc = gnutls_priority_init(&priority_cache, (char *) expciphers, &errpos);
do { if (rc != 0) { if (exim_gnutls_base_init_done) gnutls_global_deinit(); return string_sprintf("%s failed: %s", (string_sprintf( "gnutls_priority_init(%s) failed at offset %ld, \"%.8s..\"", expciphers, errpos - (char *) expciphers, errpos)), gnutls_strerror(rc)); } } while (0)

                                                  ;



gnutls_global_deinit();

return ((void *)0);
}




/*************************************************
*         Report the library versions.           *
*************************************************/

/* See a description in tls-openssl.c for an explanation of why this exists.

Arguments:   a FILE* to print the results to
Returns:     nothing
*/

void
tls_version_report(FILE *f)
{
fprintf(f, "Library version: GnuTLS: Compile: %s\n"
           "                         Runtime: %s\n",
           "3.2.1",
           gnutls_check_version(((void *)0)));
}

/* End of tls-gnu.c */
